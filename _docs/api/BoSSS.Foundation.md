---
title: "BoSSS.Foundation"
parent: "API Reference"
nav_order: 6
permalink: /docs/api/BoSSS.Foundation/
---
# Namespace: BoSSS.Foundation

## Class: BoSSS.Foundation.IO.AdvancedLookupBinder <a id="bosss.foundation.io.advancedlookupbinder"></a>

**Summary:** Helps within Jupyter notebook, where the JSON formatter 
sometimes is not able to resolve all types and assemblies automatically.


## Method: BoSSS.Foundation.IO.AdvancedLookupBinder.GetAllAssemblies(System.Reflection.Assembly,System.Collections.Generic.HashSet{System.Reflection.Assembly}) <a id="bosss.foundation.io.advancedlookupbinder.getallassemblies(system.reflection.assembly,system.collections.generic.hashset{system.reflection.assembly})"></a>
**Summary:** Recursive collection of all dependencies of some assembly.
**Parameter:** `a` - 
**Parameter:** `assiList` - Output, list where all dependent assemblies are collected.

## Class: BoSSS.Foundation.IO.CellFieldDataSet <a id="bosss.foundation.io.cellfielddataset"></a>

**Summary:** Items of the data-vector that is stored for one time-step; an instance
of this class contains basically the DG coordinates of multiple DG
fields, for one cell.


### Field: BoSSS.Foundation.IO.CellFieldDataSet.GlobalID <a id="bosss.foundation.io.cellfielddataset.globalid"></a>
**Summary:** Global ID of the cell


### Field: BoSSS.Foundation.IO.CellFieldDataSet.DGData <a id="bosss.foundation.io.cellfielddataset.dgdata"></a>
**Summary:** a buffer of data -- must be altered with unsafe methods -- Har, har!
- 0th int: No of stored DG fields, Q;
- 1st int to Q-th int: number of DG coordinates for the respective field
after that: doubles that store the DG data


## Method: BoSSS.Foundation.IO.CellFieldDataSet.AppendDGCoordinates(System.Double[]) <a id="bosss.foundation.io.cellfielddataset.appenddgcoordinates(system.double[])"></a>
**Summary:** Appends DG coordinate data to [BoSSS.Foundation.IO.CellFieldDataSet.DGData](#bosss.foundation.io.cellfielddataset.dgdata)
**Parameter:** `Coords` - DG coordinates in respective cell


### Property: BoSSS.Foundation.IO.CellFieldDataSet.NoOfFields <a id="bosss.foundation.io.cellfielddataset.nooffields"></a>
**Summary:** number of fields stored in this data set.


## Method: BoSSS.Foundation.IO.CellFieldDataSet.GetDGCoordinates(System.Int32) <a id="bosss.foundation.io.cellfielddataset.getdgcoordinates(system.int32)"></a>
**Summary:** returns the DG coordinates of the 'ifld'-th field.

## Class: BoSSS.Foundation.IO.DatabaseController <a id="bosss.foundation.io.databasecontroller"></a>

**Summary:** Manages operations on higher-level objects of a database,
e.g. session and grid info objects, as opposed to the file-based
operations in [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)


### Field: BoSSS.Foundation.IO.DatabaseController.PasswordCallback <a id="bosss.foundation.io.databasecontroller.passwordcallback"></a>
**Summary:** Allows registering a callback function that can ask for passwords
if the connection to the database is password-proected


## Method: BoSSS.Foundation.IO.DatabaseController.GetFileSystemDriver(System.String) <a id="bosss.foundation.io.databasecontroller.getfilesystemdriver(system.string)"></a>
**Summary:** Creates the appropriate file system driver for accessing the given
'path'
**Parameter:** `path` - A fully qualified path.
**Returns:**
- If the path is
null, [BoSSS.Foundation.IO.NullFileSystemDriver](#bosss.foundation.io.nullfilesystemdriver) will be used. 
- Otherwise,
a local path will be assumed, which thus makes use of
[BoSSS.Foundation.IO.StandardFsDriver](#bosss.foundation.io.standardfsdriver)


## Method: BoSSS.Foundation.IO.DatabaseController.LoadDatabaseInfosFromXML <a id="bosss.foundation.io.databasecontroller.loaddatabaseinfosfromxml"></a>
**Summary:** Loads the list of databases from the user's DBE.xml.
**Returns:**
A list of databases as listed in DBE.xml.


## Method: BoSSS.Foundation.IO.DatabaseController.#ctor(BoSSS.Foundation.IO.DatabaseInfo) <a id="bosss.foundation.io.databasecontroller.#ctor(bosss.foundation.io.databaseinfo)"></a>
**Summary:** Creates a new instance of [BoSSS.Foundation.IO.DatabaseController](#bosss.foundation.io.databasecontroller)


### Property: BoSSS.Foundation.IO.DatabaseController.Database <a id="bosss.foundation.io.databasecontroller.database"></a>
**Summary:** The driver's database


### Property: BoSSS.Foundation.IO.DatabaseController.DBDriver <a id="bosss.foundation.io.databasecontroller.dbdriver"></a>
**Summary:** IO DatabaseDriver for lower-level operations


### Property: BoSSS.Foundation.IO.DatabaseController.SessionCount <a id="bosss.foundation.io.databasecontroller.sessioncount"></a>
**Summary:** The number of sessions within this database. Does not require the
actual sessions to be loaded.


### Property: BoSSS.Foundation.IO.DatabaseController.GridCount <a id="bosss.foundation.io.databasecontroller.gridcount"></a>
**Summary:** The number of grids within this database. Does not require the
actual grids to be loaded.


### Property: BoSSS.Foundation.IO.DatabaseController.Sessions <a id="bosss.foundation.io.databasecontroller.sessions"></a>
**Summary:** The sessions associated with this driver's database


### Field: BoSSS.Foundation.IO.DatabaseController.m_Sessions <a id="bosss.foundation.io.databasecontroller.m_sessions"></a>
**Summary:** Cache for the database's session.


## Method: BoSSS.Foundation.IO.DatabaseController.GetSessionInfos(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.databasecontroller.getsessioninfos(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves all sessions using a particular 'grid'.
**Parameter:** `grid` - The grid in question.
**Returns:**
A collection of sessions using the grid.


## Method: BoSSS.Foundation.IO.DatabaseController.GetSessionInfo(System.Guid) <a id="bosss.foundation.io.databasecontroller.getsessioninfo(system.guid)"></a>
**Summary:** Obtains the session information associated with the given
'sessionID' through deserialization.
**Parameter:** `sessionID` - The id of the requested session
**Returns:**
A lightweight representation of the session.


## Method: BoSSS.Foundation.IO.DatabaseController.LoadSessionInfos <a id="bosss.foundation.io.databasecontroller.loadsessioninfos"></a>
**Summary:** Retrieves all session info objects of this database through
deserialization. Strictly intended for populating
[BoSSS.Foundation.IO.DatabaseController.m_Sessions](#bosss.foundation.io.databasecontroller.m_sessions).
**Returns:**
All session infos stored in the database.


## Method: BoSSS.Foundation.IO.DatabaseController.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasecontroller.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Saves a session info object to a file on the disk.
**Parameter:** `session` - The session to be saved.


## Method: BoSSS.Foundation.IO.DatabaseController.DeleteSession(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasecontroller.deletesession(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Deletes a session from the database and its files from the filesystem.
**Parameter:** `session` - The session to be deleted.


## Method: BoSSS.Foundation.IO.DatabaseController.CopySession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasecontroller.copysession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies a session to another database.
**Parameter:** `session` - The session to be copied.
**Parameter:** `dest` - The destination database.
**Returns:**
An info object for the session in the destination database.


## Method: BoSSS.Foundation.IO.DatabaseController.MoveSession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasecontroller.movesession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Moves a session to another database.
**Parameter:** `session` - The session to be moved.
**Parameter:** `dest` - The destination database.
**Returns:**
An info object for the session in the destination database.


## Method: BoSSS.Foundation.IO.DatabaseController.CopyOrMoveSession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo,System.Boolean) <a id="bosss.foundation.io.databasecontroller.copyormovesession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo,system.boolean)"></a>
**Summary:** Copies or moves a session to another database.
**Parameter:** `session` - Session to be moved.
**Parameter:** `dest` - Destination database.
**Parameter:** `copy` - true, if the session is to be copied; 
false if the session should be moved.
**Returns:**
An ISessionInfo object of the copied/moved session.


## Method: BoSSS.Foundation.IO.DatabaseController.DeleteTimestep(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.databasecontroller.deletetimestep(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Deletes a time-step from the database and its files from the file
system.
**Parameter:** `timestep` - The time-step to be deleted.


## Method: BoSSS.Foundation.IO.DatabaseController.DeleteTimestep(BoSSS.Foundation.IO.ITimestepInfo,System.Boolean) <a id="bosss.foundation.io.databasecontroller.deletetimestep(bosss.foundation.io.itimestepinfo,system.boolean)"></a>
**Summary:** Deletes a time-step from the database and its files from the file
system.
**Parameter:** `timestep` - The time-step to be deleted.
**Parameter:** `remove` - if true, the timestep is also un-linked from the session


## Method: BoSSS.Foundation.IO.DatabaseController.GetTimestepInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasecontroller.gettimestepinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves information about all time-steps in a session.
**Parameter:** `session` - The session in question.
**Returns:**
All information about the session's time-steps.


### Property: BoSSS.Foundation.IO.DatabaseController.Grids <a id="bosss.foundation.io.databasecontroller.grids"></a>
**Summary:** A list of all grids within this database


## Method: BoSSS.Foundation.IO.DatabaseController.GetGridInfo(System.Guid) <a id="bosss.foundation.io.databasecontroller.getgridinfo(system.guid)"></a>
**Summary:** Retrieves a grid information object by reading the grid file(s)
stored in the specified database
**Parameter:** `gridID` - The Guid of the grid to be read.
**Returns:**
The grid info object for the selected grid.


## Method: BoSSS.Foundation.IO.DatabaseController.AddGridInitializationContext(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.io.databasecontroller.addgridinitializationcontext(bosss.foundation.grid.igriddata)"></a>
**Summary:** Adds an initialization context for a particular grid object, i.e.
such the grid data object and grid-global objects (like a basis)
don't have to be created over and over again.
**Parameter:** `gridData` - 


## Method: BoSSS.Foundation.IO.DatabaseController.GetInitializationContext(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.databasecontroller.getinitializationcontext(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Retrieves the initialization for a particular time-step.
**Parameter:** `ts` - 
**Returns:**



## Method: BoSSS.Foundation.IO.DatabaseController.SaveGridInfo(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.databasecontroller.savegridinfo(bosss.foundation.io.igridinfo)"></a>
**Summary:** Saves a grid info object to the persistent memory.
**Parameter:** `grid` - The grid to be saved.


## Method: BoSSS.Foundation.IO.DatabaseController.GetGridInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasecontroller.getgridinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves a grid information object by reading the grid file(s)
associated with the specified 'session'.
**Parameter:** `session` - The session in question.
The collection of grids associated to


## Method: BoSSS.Foundation.IO.DatabaseController.DeleteGrid(BoSSS.Foundation.IO.IGridInfo,System.Boolean) <a id="bosss.foundation.io.databasecontroller.deletegrid(bosss.foundation.io.igridinfo,system.boolean)"></a>
**Summary:** Deletes a grid from the database,
**Parameter:** `grid` - The grid to be deleted.
**Parameter:** `safelyDelete` - true if should only be deleted if it is not in use by any session;
false if it should be deleted regardless of its usage status.
**Returns:**
true if the deletion was successful, false otherwise


## Method: BoSSS.Foundation.IO.DatabaseController.CopyGrid(BoSSS.Foundation.IO.IGridInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasecontroller.copygrid(bosss.foundation.io.igridinfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies the grid to a new database without overwriting,
i.e. the copy operation is only performed 
if the grid does not yet exist in the target database
**Parameter:** `gridInfo` - The grid to copy
**Parameter:** `dest` - The target database
**Returns:**
An IGridInfo object referring to the grid in the target database


## Method: BoSSS.Foundation.IO.DatabaseController.ClearDatabase <a id="bosss.foundation.io.databasecontroller.cleardatabase"></a>
**Summary:** Clears the entire database, leaving only the basic folder
structure behind.


## Method: BoSSS.Foundation.IO.DatabaseController.CleanDatabase <a id="bosss.foundation.io.databasecontroller.cleandatabase"></a>
**Summary:** Disposes of all unused objects in the database.


## Method: BoSSS.Foundation.IO.DatabaseController.IsDBFolderStructureValid(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasecontroller.isdbfolderstructurevalid(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Checks whether the basic folder structure of a database is existing


## Method: BoSSS.Foundation.IO.DatabaseController.GetGridFiles(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.databasecontroller.getgridfiles(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves all files associated with a grid.
**Parameter:** `grid` - The info object of the grid
**Returns:**
Paths to all files associated with 'grid'


## Method: BoSSS.Foundation.IO.DatabaseController.GetGridFiles(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasecontroller.getgridfiles(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Retrieves all files associated with a grid.
**Parameter:** `gridID` - The grid ID
**Parameter:** `database` - The database where the grid is located
**Returns:**
Paths to all files associated with the grid


## Method: BoSSS.Foundation.IO.DatabaseController.GetTimestepFiles(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasecontroller.gettimestepfiles(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Returns a collection of paths to all files associated with a session's timesteps.

## Class: BoSSS.Foundation.IO.DatabaseDriver <a id="bosss.foundation.io.databasedriver"></a>

**Summary:** The (formerly called) IO-master provides storage access on an
object-level (in comparison, [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)-
implementations provide IO on a stream-level), mainly by using
serialization.


## Method: BoSSS.Foundation.IO.DatabaseDriver.#ctor(BoSSS.Foundation.IO.IFileSystemDriver) <a id="bosss.foundation.io.databasedriver.#ctor(bosss.foundation.io.ifilesystemdriver)"></a>
**Parameter:** `fsDriver` - the IO Driver; can be null;


### Field: BoSSS.Foundation.IO.DatabaseDriver.logger_output <a id="bosss.foundation.io.databasedriver.logger_output"></a>
**Summary:** need to close on dispose


## Method: BoSSS.Foundation.IO.DatabaseDriver.GetNewLogStream(BoSSS.Foundation.IO.SessionInfo,System.String) <a id="bosss.foundation.io.databasedriver.getnewlogstream(bosss.foundation.io.sessioninfo,system.string)"></a>
**Summary:** Returns a write-stream for some new log file.


### Field: BoSSS.Foundation.IO.DatabaseDriver.configAllreadyDone <a id="bosss.foundation.io.databasedriver.configallreadydone"></a>
**Summary:** some fucking fake.


### Property: BoSSS.Foundation.IO.DatabaseDriver.FsDriver <a id="bosss.foundation.io.databasedriver.fsdriver"></a>
**Summary:** the file system driver


## Method: BoSSS.Foundation.IO.DatabaseDriver.InitTraceFile(BoSSS.Foundation.IO.SessionInfo) <a id="bosss.foundation.io.databasedriver.inittracefile(bosss.foundation.io.sessioninfo)"></a>
**Summary:** Tracing setup.


## Method: BoSSS.Foundation.IO.DatabaseDriver.CloseTraceFile <a id="bosss.foundation.io.databasedriver.closetracefile"></a>
**Summary:** Tracing setup.


## Method: BoSSS.Foundation.IO.DatabaseDriver.CreateNewSession(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.createnewsession(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new session;


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveVector``1(System.Collections.Generic.IList{``0}) <a id="bosss.foundation.io.databasedriver.savevector``1(system.collections.generic.ilist{``0})"></a>
**Summary:** Saves a vector to the database, allocating a GUID automatically.
**Parameter:** `vector` - 
**Returns:**
The GUID that was allocated to identify the vector within the storage system.


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveVector``1(System.Collections.Generic.IList{``0},System.Guid) <a id="bosss.foundation.io.databasedriver.savevector``1(system.collections.generic.ilist{``0},system.guid)"></a>
**Summary:** saves a vector to the database, under a specified Guid
**Parameter:** `vector` - the part of the vector which is stored on the local process.
**Parameter:** `id` - the Guid under which the vector should be stored; must be the same
on all MPI processes.


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadVector``1(System.Guid,ilPSP.Partitioning@) <a id="bosss.foundation.io.databasedriver.loadvector``1(system.guid,ilpsp.partitioning@)"></a>
**Summary:** Loads a vector from the database
**Parameter:** `id` - 
**Parameter:** `part` - Optional partition of the vector among MPI processors: if null, a
partition is defined by the loader logic.


## Method: BoSSS.Foundation.IO.DatabaseDriver.GridExists(System.Guid) <a id="bosss.foundation.io.databasedriver.gridexists(system.guid)"></a>
**Summary:** tests whether a grid with GUID 'g' exists in database, or not;


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadGridInfo(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.loadgridinfo(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Loads the grid info object for the given
'gridId' from the given


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadGrid(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.loadgrid(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads the grid identified by 'gridId' from the
given 'database'
**Parameter:** `gridId` - The unique identifier of the grid.
**Parameter:** `database` - The database that is associated with the grid.
**Returns:**
The loaded grid


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadGridData(BoSSS.Foundation.Grid.IGrid) <a id="bosss.foundation.io.databasedriver.loadgriddata(bosss.foundation.grid.igrid)"></a>
**Summary:** Loads the actual grid data for the given 'grid'.
That is, loads the actual cell data.
**Parameter:** `grid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadSession(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.loadsession(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Loads the given 'sessionId' from the given
'database'.
**Parameter:** `sessionId` - 
**Parameter:** `database` - 
**Returns:**



## Method: BoSSS.Foundation.IO.DatabaseDriver.GetSessionDirectory(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasedriver.getsessiondirectory(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves the directory where the files for the selected
'session' are stored.
**Parameter:** `session` - The selected session.
**Remark:**
Should work on any System.


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.databasedriver.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Saves a session info object to a file on the disk.
**Parameter:** `session` - The session to be saved.


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveGridIfUnique(BoSSS.Foundation.Grid.IGrid@,System.Boolean@,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.savegridifunique(bosss.foundation.grid.igrid@,system.boolean@,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database and, if none is found
saves a grid object to the database.
**Parameter:** `grid` - On entry, the grid which should be saved to the database.
On exit, either unchanged, or the equivalent grid.
**Parameter:** `EquivalentGridFound` - Indicates that an equivalent grid was found.
**Parameter:** `database` - 
**Returns:**
the id of the equivalent grid, if found; otherwise, the id of 'grid'


## Method: BoSSS.Foundation.IO.DatabaseDriver.SearchForEquivalentGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.searchforequivalentgrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database.
**Parameter:** `grid` - The grid for which an equivalent one should be searched.
**Parameter:** `database` - 
**Returns:**
the equivalent grid, if found; otherwise, null


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.savegrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Saves the given grid object to the database;
**Parameter:** `grid` - The grid to save.
**Parameter:** `database` - chaos
**Returns:**
the Guid of the [BoSSS.Foundation.Grid.IGrid](#bosss.foundation.grid.igrid)-object that was saved
(equal to the [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id)-property).


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadTimestepInfo(System.Guid,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.loadtimestepinfo(system.guid,bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads a single [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)-object from the database.


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadTimestepInfo``1(System.Guid,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databasedriver.loadtimestepinfo``1(system.guid,bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads a single [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)-object from the database.


## Method: BoSSS.Foundation.IO.DatabaseDriver.GetTimestepGuids(System.Guid) <a id="bosss.foundation.io.databasedriver.gettimestepguids(system.guid)"></a>
**Summary:** Gathers all time-step IDs of a session.
**Parameter:** `sessionGuid` - ID of the session.
**Returns:**
A collection of th session's timestep IDs.


## Method: BoSSS.Foundation.IO.DatabaseDriver.RemoveTimestepGuid(System.Guid,System.Guid) <a id="bosss.foundation.io.databasedriver.removetimestepguid(system.guid,system.guid)"></a>
**Summary:** Removes the given 'timestepGuid' from the
time-step log for the given 'sessionGuid'
**Parameter:** `sessionGuid` - 
**Parameter:** `timestepGuid` - 


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadFieldData(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.io.databasedriver.loadfielddata(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Loads a time-step from the database into previously allocated
DG-fields ('PreAllocatedFields').


## Method: BoSSS.Foundation.IO.DatabaseDriver.LoadFields(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{System.String}) <a id="bosss.foundation.io.databasedriver.loadfields(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{system.string})"></a>
**Summary:** Loads a time-step from the database.
**Remark:**
By using this method, it is ensured that the loaded/returned fields
have the same DG polynomial degree as in the database.


## Method: BoSSS.Foundation.IO.DatabaseDriver.SaveTimestep(BoSSS.Foundation.IO.TimestepInfo) <a id="bosss.foundation.io.databasedriver.savetimestep(bosss.foundation.io.timestepinfo)"></a>
**Summary:** Saves a time-step to the database's persistent memory.
**Parameter:** `_tsi` - Contains Id etc.

## Class: BoSSS.Foundation.IO.GridDatabaseDriver <a id="bosss.foundation.io.griddatabasedriver"></a>


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.GridExists(System.Guid) <a id="bosss.foundation.io.griddatabasedriver.gridexists(system.guid)"></a>
**Summary:** tests whether a grid with GUID 'g' exists in database, or not;


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.SearchForEquivalentGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.griddatabasedriver.searchforequivalentgrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database.
**Parameter:** `grid` - The grid for which an equivalent one should be searched.
**Parameter:** `database` - 
**Returns:**
the equivalent grid, if found; otherwise, null


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.SaveGridIfUnique(BoSSS.Foundation.Grid.IGrid@,System.Boolean@,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.griddatabasedriver.savegridifunique(bosss.foundation.grid.igrid@,system.boolean@,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database and, if none is found
saves a grid object to the database.
**Parameter:** `grid` - On entry, the grid which should be saved to the database.
On exit, either unchanged, or the equivalent grid.
**Parameter:** `EquivalentGridFound` - Indicates that an equivalent grid was found.
**Parameter:** `database` - 
**Returns:**
the id of the equivalent grid, if found; otherwise, the id of 'grid'


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.SaveGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.griddatabasedriver.savegrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Saves the given grid object to the database;
**Parameter:** `grid` - The grid to save.
**Parameter:** `database` - chaos
**Returns:**
the Guid of the [BoSSS.Foundation.Grid.IGrid](#bosss.foundation.grid.igrid)-object that was saved
(equal to the [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id)-property).


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.LoadGrid(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.griddatabasedriver.loadgrid(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads the grid identified by 'uid' from the
given 'database'
**Parameter:** `uid` - The unique identifier of the grid.
**Parameter:** `database` - The database that is associated with the grid.
**Returns:**
The loaded grid


## Method: BoSSS.Foundation.IO.GridDatabaseDriver.LoadGridInfo(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.griddatabasedriver.loadgridinfo(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Loads the grid info object for the given
'gridGuid' from the given
'database'
**Parameter:** `gridGuid` - 
**Parameter:** `database` - 
**Returns:**



## Method: BoSSS.Foundation.IO.GridDatabaseDriver.LoadGridData(BoSSS.Foundation.Grid.IGrid) <a id="bosss.foundation.io.griddatabasedriver.loadgriddata(bosss.foundation.grid.igrid)"></a>
**Summary:** Loads the actual grid data for the given 'grid'.
That is, loads the actual cell data.
**Parameter:** `grid` - 
**Returns:**


## Class: BoSSS.Foundation.IO.MPIProcess <a id="bosss.foundation.io.mpiprocess"></a>


### Property: BoSSS.Foundation.IO.MPIProcess.MyRank <a id="bosss.foundation.io.mpiprocess.myrank"></a>
**Summary:** MPI rank of actual process within the MPI world communicator


### Property: BoSSS.Foundation.IO.MPIProcess.Size <a id="bosss.foundation.io.mpiprocess.size"></a>
**Summary:** Number of MPI processes within the MPI world communicator

## Class: BoSSS.Foundation.IO.Serializer <a id="bosss.foundation.io.serializer"></a>


### Field: BoSSS.Foundation.IO.Serializer.DebugSerialization <a id="bosss.foundation.io.serializer.debugserialization"></a>
**Summary:** Indicates whether the content of the database should be serialized
in a human-readable (debugging) format, or in a significantly
smaller binary format

## Class: BoSSS.Foundation.IO.SerializerVersion0.MySerializationBinder <a id="bosss.foundation.io.serializerversion0.myserializationbinder"></a>

**Summary:** Serialization binder to ensure compatibility with older file versions, where certain classes
were organized in a different namespace.

## Class: BoSSS.Foundation.IO.SessionDatabaseDriver <a id="bosss.foundation.io.sessiondatabasedriver"></a>


## Method: BoSSS.Foundation.IO.SessionDatabaseDriver.CreateNewSession(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessiondatabasedriver.createnewsession(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new session;


## Method: BoSSS.Foundation.IO.SessionDatabaseDriver.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.sessiondatabasedriver.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Saves a session info object to a file on the disk.
**Parameter:** `session` - The session to be saved.


## Method: BoSSS.Foundation.IO.SessionDatabaseDriver.LoadSession(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessiondatabasedriver.loadsession(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Loads the given 'sessionId' from the given
'database'.
**Parameter:** `sessionId` - 
**Parameter:** `database` - 
**Returns:**



## Method: BoSSS.Foundation.IO.SessionDatabaseDriver.GetSessionDirectory(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.sessiondatabasedriver.getsessiondirectory(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves the directory where the files for the selected
'session' are stored.
**Parameter:** `session` - The selected session.
**Remark:**
Should work on any System.

## Class: BoSSS.Foundation.IO.TimeStepDatabaseDriver <a id="bosss.foundation.io.timestepdatabasedriver"></a>


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.LoadTimestepInfo``1(System.Guid,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.timestepdatabasedriver.loadtimestepinfo``1(system.guid,bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads a single [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)-object from the database.


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.SaveTimestep(BoSSS.Foundation.IO.TimestepInfo) <a id="bosss.foundation.io.timestepdatabasedriver.savetimestep(bosss.foundation.io.timestepinfo)"></a>
**Summary:** Saves a time-step to the database's persistent memory.
**Parameter:** `_tsi` - Contains Id etc.


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.LoadTimestepInfo(System.Guid,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.timestepdatabasedriver.loadtimestepinfo(system.guid,bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads a single [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)-object from the database.


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.GetTimestepGuids(System.Guid) <a id="bosss.foundation.io.timestepdatabasedriver.gettimestepguids(system.guid)"></a>
**Summary:** Gathers all time-step IDs of a session.
**Parameter:** `sessionGuid` - ID of the session.
**Returns:**
A collection of th session's timestep IDs.


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.RemoveTimestepGuid(System.Guid,System.Guid) <a id="bosss.foundation.io.timestepdatabasedriver.removetimestepguid(system.guid,system.guid)"></a>
**Summary:** Removes the given 'timestepGuid' from the
time-step log for the given 'sessionGuid'
**Parameter:** `sessionGuid` - 
**Parameter:** `timestepGuid` - 


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.LoadFieldData(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.io.timestepdatabasedriver.loadfielddata(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Loads a time-step from the database into previously allocated
DG-fields ('PreAllocatedFields').


## Method: BoSSS.Foundation.IO.TimeStepDatabaseDriver.LoadFields(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{System.String}) <a id="bosss.foundation.io.timestepdatabasedriver.loadfields(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{system.string})"></a>
**Summary:** Loads a time-step from the database.
**Remark:**
By using this method, it is ensured that the loaded/returned fields
have the same DG polynomial degree as in the database.

## Class: BoSSS.Foundation.IO.VectorDataSerializer.DistributedVectorHeader <a id="bosss.foundation.io.vectordataserializer.distributedvectorheader"></a>

**Summary:** header file for distributed stored vectors


### Field: BoSSS.Foundation.IO.VectorDataSerializer.DistributedVectorHeader.m_Guid <a id="bosss.foundation.io.vectordataserializer.distributedvectorheader.m_guid"></a>
**Summary:** GUID to identify the vector in the storage system.


### Field: BoSSS.Foundation.IO.VectorDataSerializer.DistributedVectorHeader.Partitioning <a id="bosss.foundation.io.vectordataserializer.distributedvectorheader.partitioning"></a>
**Summary:** partition of the vector;
the i-th entry is the first index of the vector that is stored in the i-th part.
the length of this array is equal to the number of parts plus 1, the last entry
is the total length of the vector.


### Field: BoSSS.Foundation.IO.VectorDataSerializer.DistributedVectorHeader.UseGzip <a id="bosss.foundation.io.vectordataserializer.distributedvectorheader.usegzip"></a>
**Summary:** A hack, which indicates that we are using the most modern version.

## Class: BoSSS.Foundation.IO.VectorDataSerializer <a id="bosss.foundation.io.vectordataserializer"></a>


## Method: BoSSS.Foundation.IO.VectorDataSerializer.SaveVector``1(System.Collections.Generic.IList{``0}) <a id="bosss.foundation.io.vectordataserializer.savevector``1(system.collections.generic.ilist{``0})"></a>
**Summary:** Saves a vector to the database, allocating a GUID automatically.
**Parameter:** `vector` - 
**Returns:**
The GUID that was allocated to identify the vector within the storage system.


## Method: BoSSS.Foundation.IO.VectorDataSerializer.GetItemSize``1(System.Collections.Generic.IList{``0}) <a id="bosss.foundation.io.vectordataserializer.getitemsize``1(system.collections.generic.ilist{``0})"></a>
**Summary:** Determines the average size after serialization, in bytes, of items stores in a vector;


## Method: BoSSS.Foundation.IO.VectorDataSerializer.RepartitionVector``1(System.Collections.Generic.IList{``0}) <a id="bosss.foundation.io.vectordataserializer.repartitionvector``1(system.collections.generic.ilist{``0})"></a>
**Summary:** It was noticed that the BSON-de-serializer used in this project crashes for objects
which are, after serialization, larger than about 100 megabyte;
therefore, such vectors will be split up further before saving.


## Method: BoSSS.Foundation.IO.VectorDataSerializer.SaveVector``1(System.Collections.Generic.IList{``0},System.Guid) <a id="bosss.foundation.io.vectordataserializer.savevector``1(system.collections.generic.ilist{``0},system.guid)"></a>
**Summary:** saves a vector to the database, under a specified Guid
**Parameter:** `vector` - the part of the vector which is stored on the local process.
**Parameter:** `id` - the Guid under which the vector should be stored; must be the same
on all MPI processes.


## Method: BoSSS.Foundation.IO.VectorDataSerializer.LoadVector``1(System.Guid,ilPSP.Partitioning@) <a id="bosss.foundation.io.vectordataserializer.loadvector``1(system.guid,ilpsp.partitioning@)"></a>
**Summary:** Loads a vector from the database
**Parameter:** `id` - 
**Parameter:** `part` - Optional partition of the vector among MPI processors: if null, a
partition is defined by the loader logic.

## Class: BoSSS.Foundation.IO.DatabaseInfo <a id="bosss.foundation.io.databaseinfo"></a>

**Summary:** Standard implementation of a database info object.


## Method: BoSSS.Foundation.IO.DatabaseInfo.CreateOrOpen(System.String) <a id="bosss.foundation.io.databaseinfo.createoropen(system.string)"></a>
**Summary:** Tries to open a database if 'path' is existent;
Otherwise, creates a new database and opens it.


## Method: BoSSS.Foundation.IO.DatabaseInfo.Open(System.String) <a id="bosss.foundation.io.databaseinfo.open(system.string)"></a>
**Summary:** Opens an existing


## Method: BoSSS.Foundation.IO.DatabaseInfo.Open(System.ValueTuple{System.String,System.String}[]) <a id="bosss.foundation.io.databaseinfo.open(system.valuetuple{system.string,system.string}[])"></a>
**Summary:** Open the database


## Method: BoSSS.Foundation.IO.DatabaseInfo.Close(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databaseinfo.close(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** One of the stupid hacks that we have to do due to the shitty convoluted design of the database.


## Method: BoSSS.Foundation.IO.DatabaseInfo.Open(System.String,System.ValueTuple{System.String,System.String}[]) <a id="bosss.foundation.io.databaseinfo.open(system.string,system.valuetuple{system.string,system.string}[])"></a>
**Summary:** Open the database


## Method: BoSSS.Foundation.IO.DatabaseInfo.#ctor(System.String) <a id="bosss.foundation.io.databaseinfo.#ctor(system.string)"></a>
**Summary:** Stores the path
**Parameter:** `path` - Path to the database


### Property: BoSSS.Foundation.IO.DatabaseInfo.Path <a id="bosss.foundation.io.databaseinfo.path"></a>
**Summary:** Full path to the base directory of the database.


### Property: BoSSS.Foundation.IO.DatabaseInfo.Controller <a id="bosss.foundation.io.databaseinfo.controller"></a>
**Summary:** Provides functionality to copy/move/delete info objects stored in
the database


## Method: BoSSS.Foundation.IO.DatabaseInfo.ToString <a id="bosss.foundation.io.databaseinfo.tostring"></a>
**Summary:** Returns a string representation of this database.
**Returns:**



## Method: BoSSS.Foundation.IO.DatabaseInfo.PathMatch(System.String) <a id="bosss.foundation.io.databaseinfo.pathmatch(system.string)"></a>
**Summary:** detects if some other path actually also points to this database


### Property: BoSSS.Foundation.IO.DatabaseInfo.Sessions <a id="bosss.foundation.io.databaseinfo.sessions"></a>
**Summary:** The sessions of this database.


### Property: BoSSS.Foundation.IO.DatabaseInfo.Grids <a id="bosss.foundation.io.databaseinfo.grids"></a>
**Summary:** The grids of this database.


### Property: BoSSS.Foundation.IO.DatabaseInfo.Projects <a id="bosss.foundation.io.databaseinfo.projects"></a>
**Summary:** Sessions sorted according to projects, see [BoSSS.Foundation.IO.ISessionInfo.ProjectName](#bosss.foundation.io.isessioninfo.projectname).


## Method: BoSSS.Foundation.IO.DatabaseInfo.Equals(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.databaseinfo.equals(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Reference equality


## Method: BoSSS.Foundation.IO.DatabaseInfo.Equals(System.Object) <a id="bosss.foundation.io.databaseinfo.equals(system.object)"></a>


## Method: BoSSS.Foundation.IO.DatabaseInfo.GetHashCode <a id="bosss.foundation.io.databaseinfo.gethashcode"></a>


### Property: BoSSS.Foundation.IO.DatabaseInfo.AlternateDbPaths <a id="bosss.foundation.io.databaseinfo.alternatedbpaths"></a>
**Summary:** Alternative paths to access the database, if the main path is not present on a given machine.
This allows to use the same control file or object on different machines, where the database is located in a different path.
- 1st entry: path into the local file system
- 2nd entry: optional machine name filter


## Method: BoSSS.Foundation.IO.DatabaseInfo.AddAlternateDbPaths(System.String,System.String,System.String) <a id="bosss.foundation.io.databaseinfo.addalternatedbpaths(system.string,system.string,system.string)"></a>
**Summary:** Adds a new [BoSSS.Foundation.IO.IDatabaseInfo.AlternateDbPaths](#bosss.foundation.io.idatabaseinfo.alternatedbpaths) to the database configuration

## Class: BoSSS.Foundation.IO.DatabaseUtils <a id="bosss.foundation.io.databaseutils"></a>

**Summary:** Creation, Verification and Deletion of databases


## Method: BoSSS.Foundation.IO.DatabaseUtils.CreateDatabase(System.String) <a id="bosss.foundation.io.databaseutils.createdatabase(system.string)"></a>
**Summary:** Create the BoSSS database directory structure in 'dbDir';
The structure is:
- `./data`
- `./timesteps`
- `./grids`
- `./sessions`
**Parameter:** `dbDir` - File system path to database; must be either non existent or an empty directory.


## Method: BoSSS.Foundation.IO.DatabaseUtils.IsValidBoSSSDatabase(System.String) <a id="bosss.foundation.io.databaseutils.isvalidbosssdatabase(system.string)"></a>
**Summary:** Checks if the given directory has the correct directory structure
for a s BoSSS database.


## Method: BoSSS.Foundation.IO.DatabaseUtils.DeleteDatabase(System.String) <a id="bosss.foundation.io.databaseutils.deletedatabase(system.string)"></a>
**Summary:** Deletes a BoSSS database.

## Class: BoSSS.Foundation.IO.GridProxy <a id="bosss.foundation.io.gridproxy"></a>

**Summary:** A proxy for [BoSSS.Foundation.Grid.Classic.GridCommons](#bosss.foundation.grid.classic.gridcommons) objects that allows for lazy
loading


### Field: BoSSS.Foundation.IO.GridProxy.realGrid <a id="bosss.foundation.io.gridproxy.realgrid"></a>
**Summary:** The real grid reflected by this object.


### Field: BoSSS.Foundation.IO.GridProxy.gridDataLoaded <a id="bosss.foundation.io.gridproxy.griddataloaded"></a>
**Summary:** Indicates whether the grid data associated with
[BoSSS.Foundation.IO.GridProxy.realGrid](#bosss.foundation.io.gridproxy.realgrid) has already been loaded. Note that this can
be different from
[BoSSS.Platform.ExpirableLazy`1.IsValueCreated](BoSSS.Platform.md#bosss.platform.expirablelazy`1.isvaluecreated)


## Method: BoSSS.Foundation.IO.GridProxy.#ctor(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.gridproxy.#ctor(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a proxy for the grid with id 'gridGuid'
within the given 'database'
**Parameter:** `gridGuid` - 
**Parameter:** `database` - 


### Property: BoSSS.Foundation.IO.GridProxy.RealGrid <a id="bosss.foundation.io.gridproxy.realgrid"></a>
**Summary:** The real grid reflected by this object.
**Remark:**
Induces a call to [BoSSS.Foundation.IO.GridProxy.EnsureGridDataIsLoaded](#bosss.foundation.io.gridproxy.ensuregriddataisloaded)


## Method: BoSSS.Foundation.IO.GridProxy.ToString <a id="bosss.foundation.io.gridproxy.tostring"></a>
**Returns:**



## Method: BoSSS.Foundation.IO.GridProxy.EnsureGridDataIsLoaded <a id="bosss.foundation.io.gridproxy.ensuregriddataisloaded"></a>
**Summary:** If [BoSSS.Foundation.IO.GridProxy.gridDataLoaded](#bosss.foundation.io.gridproxy.griddataloaded) is false, uses
[BoSSS.Foundation.IO.IDatabaseDriver.LoadGridData(BoSSS.Foundation.Grid.IGrid)](#bosss.foundation.io.idatabasedriver.loadgriddata(bosss.foundation.grid.igrid)) to load the actual cell
data. Note that this is an expensive operation.


### Property: BoSSS.Foundation.IO.GridProxy.NumberOfCells <a id="bosss.foundation.io.gridproxy.numberofcells"></a>
**Summary:** See [BoSSS.Foundation.IO.IGridInfo.NumberOfCells](#bosss.foundation.io.igridinfo.numberofcells)


### Property: BoSSS.Foundation.IO.GridProxy.SpatialDimension <a id="bosss.foundation.io.gridproxy.spatialdimension"></a>
**Summary:** See [BoSSS.Foundation.IO.IGridInfo.SpatialDimension](#bosss.foundation.io.igridinfo.spatialdimension)


### Property: BoSSS.Foundation.IO.GridProxy.ID <a id="bosss.foundation.io.gridproxy.id"></a>
**Summary:** The id of the grid.


### Property: BoSSS.Foundation.IO.GridProxy.CreationTime <a id="bosss.foundation.io.gridproxy.creationtime"></a>
**Summary:** See [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.CreationTime](#bosss.foundation.io.idatabaseentityinfo`1.creationtime)


### Property: BoSSS.Foundation.IO.GridProxy.WriteTime <a id="bosss.foundation.io.gridproxy.writetime"></a>
**Summary:** See [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.WriteTime](#bosss.foundation.io.idatabaseentityinfo`1.writetime).
**Remark:**
Note that writing to this property induces a call to
[BoSSS.Foundation.IO.GridProxy.EnsureGridDataIsLoaded](#bosss.foundation.io.gridproxy.ensuregriddataisloaded), while reading does not.


### Property: BoSSS.Foundation.IO.GridProxy.Name <a id="bosss.foundation.io.gridproxy.name"></a>
**Summary:** See [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Name](#bosss.foundation.io.idatabaseentityinfo`1.name).
**Remark:**
Note that writing to this property induces a call to
[BoSSS.Foundation.IO.GridProxy.EnsureGridDataIsLoaded](#bosss.foundation.io.gridproxy.ensuregriddataisloaded), while reading does not.


### Property: BoSSS.Foundation.IO.GridProxy.Database <a id="bosss.foundation.io.gridproxy.database"></a>
**Summary:** The associated database


### Property: BoSSS.Foundation.IO.GridProxy.AllDataVectorIDs <a id="bosss.foundation.io.gridproxy.alldatavectorids"></a>
**Summary:** %


### Property: BoSSS.Foundation.IO.GridProxy.Description <a id="bosss.foundation.io.gridproxy.description"></a>
**Summary:** Stupid thing about the dumb grid


### Property: BoSSS.Foundation.IO.GridProxy.EdgeTagNames <a id="bosss.foundation.io.gridproxy.edgetagnames"></a>
**Summary:** Mapping between *edge tags* (numbers) and *edge tag names*.


## Method: BoSSS.Foundation.IO.GridProxy.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.gridproxy.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new grid proxy associated to database
'targetDatabase'.
**Parameter:** `targetDatabase` - 
**Returns:**



## Method: BoSSS.Foundation.IO.GridProxy.Equals(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.gridproxy.equals(bosss.foundation.io.igridinfo)"></a>
**Summary:** ~

## Class: BoSSS.Foundation.IO.IDatabaseController <a id="bosss.foundation.io.idatabasecontroller"></a>

**Summary:** Manages operations on higher-level objects of a database,
e.g. session and grid info objects, as opposed to the file-based
operations in [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)


### Property: BoSSS.Foundation.IO.IDatabaseController.Database <a id="bosss.foundation.io.idatabasecontroller.database"></a>
**Summary:** The driver's database


### Property: BoSSS.Foundation.IO.IDatabaseController.DBDriver <a id="bosss.foundation.io.idatabasecontroller.dbdriver"></a>
**Summary:** IO DatabaseDriver for lower-level operations


### Property: BoSSS.Foundation.IO.IDatabaseController.Sessions <a id="bosss.foundation.io.idatabasecontroller.sessions"></a>
**Summary:** The sessions associated with this driver's database


### Property: BoSSS.Foundation.IO.IDatabaseController.Grids <a id="bosss.foundation.io.idatabasecontroller.grids"></a>
**Summary:** The grids associated with this driver's database


## Method: BoSSS.Foundation.IO.IDatabaseController.GetSessionInfo(System.Guid) <a id="bosss.foundation.io.idatabasecontroller.getsessioninfo(system.guid)"></a>
**Summary:** Obtains the session information associated with the given
'sessionID' through deserialization.
**Parameter:** `sessionID` - The id of the requested session
**Returns:**



## Method: BoSSS.Foundation.IO.IDatabaseController.GetSessionInfos(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.idatabasecontroller.getsessioninfos(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves all sessions using a particular 'grid'.
**Parameter:** `grid` - The grid in question.
**Returns:**
A collection of sessions using the grid.


## Method: BoSSS.Foundation.IO.IDatabaseController.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.idatabasecontroller.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Saves a session info object to the persistent memory.
**Parameter:** `session` - The session to be saved.


## Method: BoSSS.Foundation.IO.IDatabaseController.DeleteSession(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.idatabasecontroller.deletesession(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Deletes a session from a database.
**Parameter:** `session` - The session to be deleted.


## Method: BoSSS.Foundation.IO.IDatabaseController.CopySession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasecontroller.copysession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies a session to another database.
**Parameter:** `session` - The session to be copied.
**Parameter:** `dest` - The destination database.
**Returns:**
An info object for the session in the destination database.


## Method: BoSSS.Foundation.IO.IDatabaseController.MoveSession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasecontroller.movesession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Moves a session to another database.
**Parameter:** `session` - The session to be moved.
**Parameter:** `dest` - The destination database.
**Returns:**
An info object for the session in the destination database.


## Method: BoSSS.Foundation.IO.IDatabaseController.DeleteTimestep(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.idatabasecontroller.deletetimestep(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Deletes a time-step from the database and its files from the file
system.
**Parameter:** `timestep` - The time-step to be deleted.


## Method: BoSSS.Foundation.IO.IDatabaseController.GetTimestepInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.idatabasecontroller.gettimestepinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Gets all time step info objects for a given session.
**Parameter:** `session` - The session in question.
**Returns:**
A list of time-steps associated with 'session'.


## Method: BoSSS.Foundation.IO.IDatabaseController.GetGridInfo(System.Guid) <a id="bosss.foundation.io.idatabasecontroller.getgridinfo(system.guid)"></a>
**Summary:** Retrieves the grid with the given 'gridID'.
**Parameter:** `gridID` - The grid id.
**Returns:**
The grid info object for the selected grid.


## Method: BoSSS.Foundation.IO.IDatabaseController.AddGridInitializationContext(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.io.idatabasecontroller.addgridinitializationcontext(bosss.foundation.grid.igriddata)"></a>
**Summary:** Adds an initialization context for a particular grid object, i.e.
such the grid data object and grid-global objects (like a basis)
don't have to be created over and over again.
**Parameter:** `gridData` - 


## Method: BoSSS.Foundation.IO.IDatabaseController.GetInitializationContext(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.idatabasecontroller.getinitializationcontext(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Retrieves the initialization for a particular time-step.
**Parameter:** `ts` - 
**Returns:**



## Method: BoSSS.Foundation.IO.IDatabaseController.SaveGridInfo(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.idatabasecontroller.savegridinfo(bosss.foundation.io.igridinfo)"></a>
**Summary:** Saves a grid info object to the persistent memory.
**Parameter:** `grid` - The grid to be saved.


## Method: BoSSS.Foundation.IO.IDatabaseController.GetGridInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.idatabasecontroller.getgridinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves information about all grids used by a given session.
**Parameter:** `session` - The session in question.
**Returns:**
The collection of grids associated with 'session'.


## Method: BoSSS.Foundation.IO.IDatabaseController.GetGridFiles(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.idatabasecontroller.getgridfiles(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves all files associated with a grid.
**Parameter:** `grid` - The info object of the grid
**Returns:**
Paths to all files associated with 'grid'


## Method: BoSSS.Foundation.IO.IDatabaseController.DeleteGrid(BoSSS.Foundation.IO.IGridInfo,System.Boolean) <a id="bosss.foundation.io.idatabasecontroller.deletegrid(bosss.foundation.io.igridinfo,system.boolean)"></a>
**Summary:** Deletes a grid from the database,
**Parameter:** `grid` - The grid to be deleted.
**Parameter:** `safelyDelete` - true if should only be deleted if it is not in use by any session;
false if it should be deleted regardless of its usage status.
**Returns:**
true if the deletion was successful, false otherwise.


## Method: BoSSS.Foundation.IO.IDatabaseController.CopyGrid(BoSSS.Foundation.IO.IGridInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasecontroller.copygrid(bosss.foundation.io.igridinfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies a grid to the given 'destination'
**Parameter:** `grid` - The grid to be copied
**Parameter:** `destination` - The destination database
**Returns:**
The grid info object for the copy of 'grid'.


## Method: BoSSS.Foundation.IO.IDatabaseController.ClearDatabase <a id="bosss.foundation.io.idatabasecontroller.cleardatabase"></a>
**Summary:** Clears the entire database, leaving only the basic folder
structure behind


## Method: BoSSS.Foundation.IO.IDatabaseController.CleanDatabase <a id="bosss.foundation.io.idatabasecontroller.cleandatabase"></a>
**Summary:** Disposes of all unused objects in the database

## Class: BoSSS.Foundation.IO.IDatabaseDriver <a id="bosss.foundation.io.idatabasedriver"></a>

**Summary:** interface definition of the database driver


### Property: BoSSS.Foundation.IO.IDatabaseDriver.FsDriver <a id="bosss.foundation.io.idatabasedriver.fsdriver"></a>
**Summary:** the file-system driver


### Property: BoSSS.Foundation.IO.IDatabaseDriver.MyRank <a id="bosss.foundation.io.idatabasedriver.myrank"></a>
**Summary:** MPI rank of actual process within the MPI world communicator


### Property: BoSSS.Foundation.IO.IDatabaseDriver.Size <a id="bosss.foundation.io.idatabasedriver.size"></a>
**Summary:** Number of MPI processes within the MPI world communicator


## Method: BoSSS.Foundation.IO.IDatabaseDriver.CreateNewSession(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.createnewsession(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new session;


## Method: BoSSS.Foundation.IO.IDatabaseDriver.InitTraceFile(BoSSS.Foundation.IO.SessionInfo) <a id="bosss.foundation.io.idatabasedriver.inittracefile(bosss.foundation.io.sessioninfo)"></a>
**Summary:** tracing setup


## Method: BoSSS.Foundation.IO.IDatabaseDriver.GetNewLogStream(BoSSS.Foundation.IO.SessionInfo,System.String) <a id="bosss.foundation.io.idatabasedriver.getnewlogstream(bosss.foundation.io.sessioninfo,system.string)"></a>
**Summary:** Returns a write-stream for some new log file.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveVector``1(System.Collections.Generic.IList{``0}) <a id="bosss.foundation.io.idatabasedriver.savevector``1(system.collections.generic.ilist{``0})"></a>
**Summary:** saves a vector to the database, allocating a guid automatically
**Parameter:** `vector` - 
**Returns:**
the guid that was allocated to identify the vector within the storage system


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveVector``1(System.Collections.Generic.IList{``0},System.Guid) <a id="bosss.foundation.io.idatabasedriver.savevector``1(system.collections.generic.ilist{``0},system.guid)"></a>
**Summary:** saves a vector to the database, under a specified Guid
**Parameter:** `vector` - the part of the vector which is stored on the local process.
**Parameter:** `id` - the Guid under which the vector should be stored; must be the same
on all MPI processes.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadVector``1(System.Guid,ilPSP.Partitioning@) <a id="bosss.foundation.io.idatabasedriver.loadvector``1(system.guid,ilpsp.partitioning@)"></a>
**Summary:** Loads a vector from the database
**Parameter:** `id` - 
**Parameter:** `part` - Optional partition of the vector among MPI processors: if null, a partition is defined by the loader logic.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.GridExists(System.Guid) <a id="bosss.foundation.io.idatabasedriver.gridexists(system.guid)"></a>
**Summary:** tests whether a grid with GUID 'g' exists in database, or not;


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadGridInfo(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.loadgridinfo(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates the grid info object for the grid with
'gridId' within the given
'database'.
**Parameter:** `gridId` - 
**Parameter:** `database` - 
**Returns:**



## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadGrid(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.loadgrid(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads the grid identified by 'gridId' from the
given database.
**Parameter:** `gridId` - The unique identifier of the grid.
**Parameter:** `database` - The database that is associated with the grid.
**Returns:**
The loaded grid


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadGridData(BoSSS.Foundation.Grid.IGrid) <a id="bosss.foundation.io.idatabasedriver.loadgriddata(bosss.foundation.grid.igrid)"></a>
**Summary:** Loads the actual grid data for the given 'grid'.
That is, loads the actual cell data.
**Parameter:** `grid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadSession(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.loadsession(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Loads the given 'sessionId' from the given
'database'.
**Parameter:** `sessionId` - 
**Parameter:** `database` - 
**Returns:**



## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.idatabasedriver.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Saves a session info object to a file on the disk.
**Parameter:** `session` - The session to be saved.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SearchForEquivalentGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.searchforequivalentgrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database.
**Parameter:** `grid` - The grid for which an equivalent one should be searched.
**Parameter:** `database` - 
**Returns:**
the equivalent grid, if found; otherwise, null


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveGridIfUnique(BoSSS.Foundation.Grid.IGrid@,System.Boolean@,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.savegridifunique(bosss.foundation.grid.igrid@,system.boolean@,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Searches for an equivalent grid in the database and, if none is found
saves a grid object to the database.
**Parameter:** `grd` - On entry, the grid which should be saved to the database.
On exit, either unchanged, or the equivalent grid.
**Parameter:** `EquivalentGridFound` - Indicates that an equivalent grid was found.
**Parameter:** `database` - 
**Returns:**
the id of the equivalent grid, if found; otherwise, the id of 'grd'


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.savegrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** saves the grid object to the database;
**Parameter:** `grd` - the grid to save
**Parameter:** `database` - 
**Returns:**
the Guid of the grid


## Method: BoSSS.Foundation.IO.IDatabaseDriver.SaveTimestep(BoSSS.Foundation.IO.TimestepInfo) <a id="bosss.foundation.io.idatabasedriver.savetimestep(bosss.foundation.io.timestepinfo)"></a>
**Summary:** Saves a time-step to the database's persistent memory.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadTimestepInfo(System.Guid,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabasedriver.loadtimestepinfo(system.guid,bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** loads a single [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)-object from the database.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.GetTimestepGuids(System.Guid) <a id="bosss.foundation.io.idatabasedriver.gettimestepguids(system.guid)"></a>
**Summary:** Gathers all time-step IDs of a session.
**Parameter:** `sessionGuid` - ID of the session.
**Returns:**
A collection of th session's time-step IDs.


## Method: BoSSS.Foundation.IO.IDatabaseDriver.RemoveTimestepGuid(System.Guid,System.Guid) <a id="bosss.foundation.io.idatabasedriver.removetimestepguid(system.guid,system.guid)"></a>
**Summary:** Removes the given 'timestepGuid' from the
time-step log for the given 'sessionGuid'
**Parameter:** `sessionGuid` - 
**Parameter:** `timestepGuid` - 


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadFieldData(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.io.idatabasedriver.loadfielddata(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Loads a time-step from the database into previously allocated DG-fields ('PreAllocatedFields').


## Method: BoSSS.Foundation.IO.IDatabaseDriver.LoadFields(BoSSS.Foundation.IO.ITimestepInfo,BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{System.String}) <a id="bosss.foundation.io.idatabasedriver.loadfields(bosss.foundation.io.itimestepinfo,bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{system.string})"></a>
**Summary:** Loads a time-step from the database.
**Remark:**
By using this method, it is ensured that the loaded/returned fields have the same DG polynomial degree as in the database.

## Class: BoSSS.Foundation.IO.IDatabaseEntityInfo`1 <a id="bosss.foundation.io.idatabaseentityinfo`1"></a>

**Summary:** Common interface for all entities that can be saved to a database.


### Property: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID <a id="bosss.foundation.io.idatabaseentityinfo`1.id"></a>
**Summary:** Unique identifier of the specific IDatabaseEntityInfo object.


### Property: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.CreationTime <a id="bosss.foundation.io.idatabaseentityinfo`1.creationtime"></a>
**Summary:** The time when the represented entity has been created.


### Property: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.WriteTime <a id="bosss.foundation.io.idatabaseentityinfo`1.writetime"></a>
**Summary:** The time when this object has been written to disc.


### Property: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Name <a id="bosss.foundation.io.idatabaseentityinfo`1.name"></a>
**Summary:** The name of the entity.


### Property: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Database <a id="bosss.foundation.io.idatabaseentityinfo`1.database"></a>
**Summary:** The database where this info object is located.


## Method: BoSSS.Foundation.IO.IDatabaseEntityInfo`1.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.idatabaseentityinfo`1.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies this IDatabaseObjectInfo object for storage in a different
database.
**Parameter:** `targetDatabase` - The target database
**Returns:**
A copy of this IDatabaseObjectInfo object with all the same
information, except for the database field, which will be the one of
the target database

## Class: BoSSS.Foundation.IO.IDatabaseInfo <a id="bosss.foundation.io.idatabaseinfo"></a>

**Summary:** Relevant information of a database object


### Property: BoSSS.Foundation.IO.IDatabaseInfo.Path <a id="bosss.foundation.io.idatabaseinfo.path"></a>
**Summary:** Full path to the base directory of the database.


## Method: BoSSS.Foundation.IO.IDatabaseInfo.PathMatch(System.String) <a id="bosss.foundation.io.idatabaseinfo.pathmatch(system.string)"></a>
**Summary:** detects if some other path actually also points to this database


### Property: BoSSS.Foundation.IO.IDatabaseInfo.AlternateDbPaths <a id="bosss.foundation.io.idatabaseinfo.alternatedbpaths"></a>
**Summary:** Alternative paths to access the database, if [BoSSS.Foundation.IO.IDatabaseInfo.Path](#bosss.foundation.io.idatabaseinfo.path) is not present on a given machine.
This allows to use the same control file or object on different machines, where the database is located in a different path.
- 1st entry: path into the local file system
- 2nd entry: optional machine name filter


### Property: BoSSS.Foundation.IO.IDatabaseInfo.Controller <a id="bosss.foundation.io.idatabaseinfo.controller"></a>
**Summary:** Provides functionality to copy/move/delete info objects stored in
the database


### Property: BoSSS.Foundation.IO.IDatabaseInfo.Sessions <a id="bosss.foundation.io.idatabaseinfo.sessions"></a>
**Summary:** The sessions of this database.


### Property: BoSSS.Foundation.IO.IDatabaseInfo.Grids <a id="bosss.foundation.io.idatabaseinfo.grids"></a>
**Summary:** The grids of this database.


### Property: BoSSS.Foundation.IO.IDatabaseInfo.Projects <a id="bosss.foundation.io.idatabaseinfo.projects"></a>
**Summary:** Sessions sorted according to projects, see [BoSSS.Foundation.IO.ISessionInfo.ProjectName](#bosss.foundation.io.isessioninfo.projectname).

## Class: BoSSS.Foundation.IO.IFileSystemDriver <a id="bosss.foundation.io.ifilesystemdriver"></a>

**Summary:** This interface is used by the IO master ([BoSSS.Foundation.IO.DatabaseDriver](#bosss.foundation.io.databasedriver)) to access some 
storage device which supports streaming.


## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetNewLogStream(System.String,System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.getnewlogstream(system.string,system.guid)"></a>
**Summary:** Returns a stream for logging information within this session;
**Parameter:** `logName` - name for the log file;
this name identifies the log within the session;
**Parameter:** `sessionGuid` - the session in which the log should be created.
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetNewLog(System.String,System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.getnewlog(system.string,system.guid)"></a>
**Summary:** returns a text writer for logging information within this session;
**Parameter:** `logName` - name for the log file;
this name identifies the log within the session;
**Parameter:** `sessionGuid` - the session in which the log should be created.
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetTimestepLogPath(System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.gettimesteplogpath(system.guid)"></a>
**Summary:** Returns the path to the time-step log.
**Parameter:** `sessionGuid` - The ID of the session.
**Returns:**
The path to the session's time-step log.


## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetTimestepLogStream(System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.gettimesteplogstream(system.guid)"></a>
**Summary:** Returns a text reader for reading the time-step log.
**Parameter:** `sessionGuid` - The ID of the session.
**Returns:**
A text reader for the session's time-step log.


## Method: BoSSS.Foundation.IO.IFileSystemDriver.CreateSessionDirectory(System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.createsessiondirectory(system.guid)"></a>
**Summary:** creates a new session directory.


## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetGridStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.getgridstream(system.boolean,system.guid)"></a>
**Summary:** a stream to serialize grid objects (objects/classes derived from [BoSSS.Foundation.Grid.Classic.GridCommons](#bosss.foundation.grid.classic.gridcommons));
**Parameter:** `create` - true for a write stream, false for a read stream
**Parameter:** `gridGuid` - The id of the grid (see [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id));
If 'create' is true, the caller ensures that it is a
newly created Guid. Otherwise, if 'create' is
false and no field-state with specified Guid exists in the
database, some exception should be thrown. The caller (some method
of the IO-DatabaseDriver class [BoSSS.Foundation.IO.DatabaseDriver](#bosss.foundation.io.databasedriver))
ensures that this parameter is equal on all MPI processes;
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetDistVectorDataStream(System.Boolean,System.Guid,System.Int32) <a id="bosss.foundation.io.ifilesystemdriver.getdistvectordatastream(system.boolean,system.guid,system.int32)"></a>
**Parameter:** `create` - true for a write stream, false for a read stream
**Parameter:** `vecGuid` - The caller (some method of the IO-DatabaseDriver class [BoSSS.Foundation.IO.DatabaseDriver](#bosss.foundation.io.databasedriver))
ensures that this parameter is equal on all
MPI processes;
**Parameter:** `part` - 
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetTimestepStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.gettimestepstream(system.boolean,system.guid)"></a>
**Summary:** if no session guid was set (cf. [BoSSS.Foundation.IO.IFileSystemDriver.CreateSessionDirectory(System.Guid)](#bosss.foundation.io.ifilesystemdriver.createsessiondirectory(system.guid))), and
'create' is true, a call to this method should
either return null or throw an exception.
**Parameter:** `create` - true for a write stream, false for a read stream
**Parameter:** `id` - The id of the time step;
If 'create' is true, the caller
([BoSSS.Foundation.IO.DatabaseDriver](#bosss.foundation.io.databasedriver)) ensures that it
is a newly created Guid. Otherwise, if 'create' is
false and no time-step with specified Guid exists in the database,
some exception should be thrown. The caller (some method of the
IO-DatabaseDriver class [BoSSS.Foundation.IO.DatabaseDriver](#bosss.foundation.io.databasedriver)) ensures that
this parameter is equal on all MPI processes;
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetSessionInfoStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.ifilesystemdriver.getsessioninfostream(system.boolean,system.guid)"></a>
**Summary:** returns a stream to save/load "SessionInfo"-objects;
**Parameter:** `create` -
- true for a write stream (also overwriting)
- false for a read stream;
**Parameter:** `sessionGuid` - the guid of the session for which the stream should be acquired;
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetAllGridGUIDs <a id="bosss.foundation.io.ifilesystemdriver.getallgridguids"></a>
**Summary:** a list of all gird guids
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetAllSessionGUIDs <a id="bosss.foundation.io.ifilesystemdriver.getallsessionguids"></a>
**Summary:** A list of the GUIDS of all sessions
**Returns:**



## Method: BoSSS.Foundation.IO.IFileSystemDriver.GetAllDataVectorGUIDs <a id="bosss.foundation.io.ifilesystemdriver.getalldatavectorguids"></a>
**Summary:** a list of all Guid's of all data vectors;
**Returns:**



### Property: BoSSS.Foundation.IO.IFileSystemDriver.BasePath <a id="bosss.foundation.io.ifilesystemdriver.basepath"></a>
**Summary:** Root path of this driver


### Property: BoSSS.Foundation.IO.IFileSystemDriver.IsDisposed <a id="bosss.foundation.io.ifilesystemdriver.isdisposed"></a>
**Summary:** Indicates whether this object has already been disposed

## Class: BoSSS.Foundation.IO.IGridInfo <a id="bosss.foundation.io.igridinfo"></a>

**Summary:** Provides basic information about a grid.
This interface serves as a kind of filter, providing only the information
that is necessary for database-related operations.


### Property: BoSSS.Foundation.IO.IGridInfo.NumberOfCells <a id="bosss.foundation.io.igridinfo.numberofcells"></a>
**Summary:** The number of grid cells.


### Property: BoSSS.Foundation.IO.IGridInfo.Description <a id="bosss.foundation.io.igridinfo.description"></a>
**Summary:** a string to store some user-information about the grid;


### Property: BoSSS.Foundation.IO.IGridInfo.SpatialDimension <a id="bosss.foundation.io.igridinfo.spatialdimension"></a>
**Summary:** The simplex dimension in the sense of measure-theory.


### Property: BoSSS.Foundation.IO.IGridInfo.AllDataVectorIDs <a id="bosss.foundation.io.igridinfo.alldatavectorids"></a>
**Summary:** collection of all (parallel) data vectors used in the grid


### Property: BoSSS.Foundation.IO.IGridInfo.EdgeTagNames <a id="bosss.foundation.io.igridinfo.edgetagnames"></a>
**Summary:** This is a mapping from each used EdgeTag to a string that
provides a name and additional information about the EdgeTag. The
intention for this member is to provide both, a name (e.g.
'Left wall') for different regions of the boundary as well as
boundary condition type info (e.g. 'inlet' or 'wall' or 'outflow' ...).
**Remark:**
The names have no impact on the application on this application
layer (L2-layer of BoSSS). They may be used on a higher application
layer; Usually, this member (as like mostly all other public
variable of this class) should be initialized by grid generator
programs.

## Class: BoSSS.Foundation.IO.IInitializationContext <a id="bosss.foundation.io.iinitializationcontext"></a>

**Summary:** A context for the initialization of objects for IO purposes. Its main
purpose is the caching of objects such that they're not recreated or
deserialized hundreds of times.


### Property: BoSSS.Foundation.IO.IInitializationContext.GridData <a id="bosss.foundation.io.iinitializationcontext.griddata"></a>
**Summary:** Information about the grid.


## Method: BoSSS.Foundation.IO.IInitializationContext.Add``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0) <a id="bosss.foundation.io.iinitializationcontext.add``1(bosss.foundation.io.iinitializer{system.object},``0)"></a>
**Summary:** Adds object 'value' to the cache
**Parameter:** `initializer` - The initializer that has been used to create
'value'.
**Parameter:** `value` - The object to be cached


## Method: BoSSS.Foundation.IO.IInitializationContext.TryGetValue``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0@) <a id="bosss.foundation.io.iinitializationcontext.trygetvalue``1(bosss.foundation.io.iinitializer{system.object},``0@)"></a>
**Summary:** Tries to retrieve a value for the given
'initializer'.
**Parameter:** `initializer` - The initializer that has been used to create
'value'.
**Parameter:** `value` - On exit: If the object has already been created by the given
'initializer', the corresponding cached object.
Otherwise, null is returned.
**Returns:**
True, if the object could be retrieved from the cache; false
otherwise.

## Class: BoSSS.Foundation.IO.GridInitializationContext <a id="bosss.foundation.io.gridinitializationcontext"></a>

**Summary:** A context for the initialization of objects for IO purposes. Its main
purpose is the caching of objects such that they're not recreated or
deserialized hundreds of times. This particular implementation has the
scope of a grid object, i.e. it can be considered as a global cache for
all objects living on the same grid.


### Field: BoSSS.Foundation.IO.GridInitializationContext.objectDirectory <a id="bosss.foundation.io.gridinitializationcontext.objectdirectory"></a>
**Summary:** A directory of objects that have already been deserialized within
this context.
**Remark:**
Now uses the default equality comparer instead of reference
comparisons since it is almost impossible to ensure reference
equality for the initializers after deserialization (i.e., this
whole construct does not have a point anymore since reference
equality never holds).


## Method: BoSSS.Foundation.IO.GridInitializationContext.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.io.gridinitializationcontext.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** Constructs a new context.


### Property: BoSSS.Foundation.IO.GridInitializationContext.GridData <a id="bosss.foundation.io.gridinitializationcontext.griddata"></a>
**Summary:** Information about the grid.


## Method: BoSSS.Foundation.IO.GridInitializationContext.Add``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0) <a id="bosss.foundation.io.gridinitializationcontext.add``1(bosss.foundation.io.iinitializer{system.object},``0)"></a>
**Summary:** See [BoSSS.Foundation.IO.IInitializationContext](#bosss.foundation.io.iinitializationcontext)


## Method: BoSSS.Foundation.IO.GridInitializationContext.TryGetValue``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0@) <a id="bosss.foundation.io.gridinitializationcontext.trygetvalue``1(bosss.foundation.io.iinitializer{system.object},``0@)"></a>
**Summary:** See [BoSSS.Foundation.IO.IInitializationContext](#bosss.foundation.io.iinitializationcontext)

## Class: BoSSS.Foundation.IO.TimestepInitializationContext <a id="bosss.foundation.io.timestepinitializationcontext"></a>

**Summary:** A context for the initialization of objects for IO purposes. Its main
purpose is the caching of objects such that they're not recreated or
deserialized hundreds of times. This particular implementation has the
scope of a grid object, i.e. it can be considered as a global cache for
all objects living on the same grid.


### Field: BoSSS.Foundation.IO.TimestepInitializationContext.parentContext <a id="bosss.foundation.io.timestepinitializationcontext.parentcontext"></a>
**Summary:** Grid-global context for things like basis objects which don't
depend on the actual time step.


### Field: BoSSS.Foundation.IO.TimestepInitializationContext.objectDirectory <a id="bosss.foundation.io.timestepinitializationcontext.objectdirectory"></a>
**Summary:** A directory of objects that have already been deserialized within
this context.
**Remark:**
Now uses the default equality comparer instead of reference
comparisons since it is almost impossible to ensure reference
equality for the initializers after deserialization (i.e., this
whole construct does not have a point anymore since reference
equality never holds).


## Method: BoSSS.Foundation.IO.TimestepInitializationContext.#ctor(BoSSS.Foundation.IO.GridInitializationContext) <a id="bosss.foundation.io.timestepinitializationcontext.#ctor(bosss.foundation.io.gridinitializationcontext)"></a>
**Summary:** Constructor
**Parameter:** `parentContext` - The context of the grid where this time-step context lives.


### Property: BoSSS.Foundation.IO.TimestepInitializationContext.GridData <a id="bosss.foundation.io.timestepinitializationcontext.griddata"></a>
**Summary:** Information about the grid.


## Method: BoSSS.Foundation.IO.TimestepInitializationContext.Add``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0) <a id="bosss.foundation.io.timestepinitializationcontext.add``1(bosss.foundation.io.iinitializer{system.object},``0)"></a>
**Summary:** Adds the given 'value' to the list of cached
objects. Depending , the object will either
go to the local scope or to the grid-global scope (cf.
[BoSSS.Foundation.IO.TimestepInitializationContext.#ctor(BoSSS.Foundation.IO.GridInitializationContext)](#bosss.foundation.io.timestepinitializationcontext.#ctor(bosss.foundation.io.gridinitializationcontext)))
**Parameter:** `initializer` - The initializer that has been used to created
'value'
**Parameter:** `value` - The value to be cached.


## Method: BoSSS.Foundation.IO.TimestepInitializationContext.TryGetValue``1(BoSSS.Foundation.IO.IInitializer{System.Object},``0@) <a id="bosss.foundation.io.timestepinitializationcontext.trygetvalue``1(bosss.foundation.io.iinitializer{system.object},``0@)"></a>
**Summary:** Tries to retrieve a value for the given
'initializer'. If the value is not in the local
scope of this object, it will be tried to retrieve it from the
grid-global scope (cf.
[BoSSS.Foundation.IO.TimestepInitializationContext.#ctor(BoSSS.Foundation.IO.GridInitializationContext)](#bosss.foundation.io.timestepinitializationcontext.#ctor(bosss.foundation.io.gridinitializationcontext)))
**Parameter:** `initializer` - The initializer that has been used to create
'value'.
**Parameter:** `value` - On exit: If the object has already been created by the given
'initializer', the corresponding cached object.
Otherwise, null is returned.
**Returns:**
True, if the object could be retrieved from the cache; false
otherwise.

## Class: BoSSS.Foundation.IO.IInitializer`1 <a id="bosss.foundation.io.iinitializer`1"></a>

**Summary:** Represents a type that is initializable during IO operations.


## Method: BoSSS.Foundation.IO.IInitializer`1.Initialize(BoSSS.Foundation.IO.IInitializationContext) <a id="bosss.foundation.io.iinitializer`1.initialize(bosss.foundation.io.iinitializationcontext)"></a>
**Summary:** Uses the given initialization context 'c' in order
create an object of the given type T.
**Parameter:** `c` - Context containing already initialized objects and information
about the grid
**Returns:**
A properly initialized object instance.

## Class: BoSSS.Foundation.IO.Initializer`1 <a id="bosss.foundation.io.initializer`1"></a>

**Summary:** Base class of all initializers that provides a default behavior for
comparison operations.


## Method: BoSSS.Foundation.IO.Initializer`1.Initialize(BoSSS.Foundation.IO.IInitializationContext) <a id="bosss.foundation.io.initializer`1.initialize(bosss.foundation.io.iinitializationcontext)"></a>
**Summary:** See [BoSSS.Foundation.IO.IInitializer`1.Initialize(BoSSS.Foundation.IO.IInitializationContext)](#bosss.foundation.io.iinitializer`1.initialize(bosss.foundation.io.iinitializationcontext))
**Parameter:** `c` - 
**Returns:**



## Method: BoSSS.Foundation.IO.Initializer`1.Equals(System.Object) <a id="bosss.foundation.io.initializer`1.equals(system.object)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.Initializer`1.Equals(BoSSS.Foundation.IO.Initializer{`0})](#bosss.foundation.io.initializer`1.equals(bosss.foundation.io.initializer{`0})) to check for equality
**Parameter:** `obj` - The object to be compared to
**Returns:**
True, if 'obj' refers to the same instance as this
object.


## Method: BoSSS.Foundation.IO.Initializer`1.GetHashCode <a id="bosss.foundation.io.initializer`1.gethashcode"></a>
**Summary:** See **System.Object.GetHashCode**


## Method: BoSSS.Foundation.IO.Initializer`1.Equals(BoSSS.Foundation.IO.Initializer{`0}) <a id="bosss.foundation.io.initializer`1.equals(bosss.foundation.io.initializer{`0})"></a>
**Summary:** Checks for reference equality. May be overridden in sub-classes to
provide a different notion of equality
**Parameter:** `other` - The object to be compared to
**Returns:**
True, if 'other' refers to the same instance as
this object.

## Class: BoSSS.Foundation.IO.Utils <a id="bosss.foundation.io.utils"></a>

**Summary:** Collection of random utility functions.


### Field: BoSSS.Foundation.IO.Utils.BOSSS_INSTALL <a id="bosss.foundation.io.utils.bosss_install"></a>
**Summary:** BoSSS install directory, e.g. 'C:\Program Files\FDY\BoSSS'.
Within this directory, one would find e.g. the subdirectory 'bin\native\win\amd64'
where native libraries are included.


### Field: BoSSS.Foundation.IO.Utils.BOSSS_NATIVE_OVERRIDE <a id="bosss.foundation.io.utils.bosss_native_override"></a>
**Summary:** Name of environment variable which 
overrides for location of native libraries if defined.


## Method: BoSSS.Foundation.IO.Utils.GetNativeLibraryDir(log4net.ILog) <a id="bosss.foundation.io.utils.getnativelibrarydir(log4net.ilog)"></a>
**Summary:** Returns the installation path of the BoSSS native libraries.
The search priority should be:
1. if defined, the [BoSSS.Foundation.IO.Utils.BOSSS_NATIVE_OVERRIDE](#bosss.foundation.io.utils.bosss_native_override) environment variable
2. if existent, a local 'amd64' subdirectory
3. if [BoSSS.Foundation.IO.Utils.BOSSS_INSTALL](#bosss.foundation.io.utils.bosss_install), the respective subdirectory, e.g. `C:\Program Files\FDY\BoSSS\bin\native\win\amd64`


## Method: BoSSS.Foundation.IO.Utils.GetBoSSSInstallDir(log4net.ILog) <a id="bosss.foundation.io.utils.getbosssinstalldir(log4net.ilog)"></a>
**Summary:** searches for the User- or Machine-environment variable 'BOSSS_INSTALL'
and verifies the existence of this directory.
**Returns:**



## Method: BoSSS.Foundation.IO.Utils.GetBoSSSUserSettingsPath <a id="bosss.foundation.io.utils.getbosssusersettingspath"></a>
**Summary:** Finds the settings directory (%USERPROFILE%/.BoSSS);
If not existent (1st startup), the directory and a dummy config is created.


## Method: BoSSS.Foundation.IO.Utils.GetExportOutputPath <a id="bosss.foundation.io.utils.getexportoutputpath"></a>
**Summary:** If not existent (1st time plot), the directory is created


## Method: BoSSS.Foundation.IO.Utils.GetExportDirectory(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.utils.getexportdirectory(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves the directory where the exports for the selected
'session' are stored.
**Parameter:** `session` - The selected session.
**Remark:**
Should work on any System.


## Method: BoSSS.Foundation.IO.Utils.GetExportDirectory(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.utils.getexportdirectory(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves the directory where the plots for the selected
'grid' are stored.
**Parameter:** `grid` - The selected grid.
**Remark:**
Should work on any System.


## Method: BoSSS.Foundation.IO.Utils.PrettyFormatXMLAsString(System.String) <a id="bosss.foundation.io.utils.prettyformatxmlasstring(system.string)"></a>
**Summary:** Formats an XmlDocment in a pretty manner
**Parameter:** `xmlAsString` - The xml to be formatted
**Returns:**
A pretty version of 'xmlAsString'


## Method: BoSSS.Foundation.IO.Utils.PrettyFormatXMLAsXmlDocument(System.String) <a id="bosss.foundation.io.utils.prettyformatxmlasxmldocument(system.string)"></a>
**Summary:** Formats a XmlDocment in a pretty manner and writes the result into
a document.
**Parameter:** `xmlAsString` - The xml to be formatted
**Returns:**
A document consisting of the pretty xml


## Method: BoSSS.Foundation.IO.Utils.CreateCombinedString(System.String,System.String,System.Int32,System.Int32,System.String) <a id="bosss.foundation.io.utils.createcombinedstring(system.string,system.string,system.int32,system.int32,system.string)"></a>
**Summary:** Concatenate two strings with a combination string in between
**Parameter:** `s1` - First string
**Parameter:** `s2` - Second string
**Parameter:** `maxLength1` - Maximum length of the first string in the output
**Parameter:** `maxLength2` - Maximum length of the second string in the output
**Parameter:** `combineString` - String appearing in the middle between (the cutted)
's1' and 's2'.
**Returns:**
's1' + 'combineString'
+ 's2' with the additional constraint that
's1' and 's2' will be chopped
according to 'maxLength1' and
'maxLength2' respectively.
**Remark:**
'combineString' will be omitted if either of the
strings to be combined is null.


## Method: BoSSS.Foundation.IO.Utils.IsValidPath(System.String) <a id="bosss.foundation.io.utils.isvalidpath(system.string)"></a>
**Summary:** Returns true if the specified path contains only valid characters.
**Parameter:** `path` - Any path. May be null or empty.


## Method: BoSSS.Foundation.IO.Utils.ChopString(System.String,System.Int32) <a id="bosss.foundation.io.utils.chopstring(system.string,system.int32)"></a>
**Summary:** Chops a string after 'maxLength' characters.
**Parameter:** `s` - The string to be chopped
**Parameter:** `maxLength` - The cut-off length
**Returns:**
The chopped string; null, if 's' was null


## Method: BoSSS.Foundation.IO.Utils.GetPathsFromGuids(System.Collections.Generic.IEnumerable{System.Guid},System.String,System.String) <a id="bosss.foundation.io.utils.getpathsfromguids(system.collections.generic.ienumerable{system.guid},system.string,system.string)"></a>
**Summary:** Gathers paths to all files in the specified subdirectory
whose file names match any Guid out of a given set of Guids.
**Parameter:** `uids` - A collection of file Guids
**Parameter:** `dirPath` - The path to the directory containing the files
**Parameter:** `extension` - Optional specification of the file name
extension (without the preceding dot)
**Returns:**
A collection of paths to the files associated with the IDs


## Method: BoSSS.Foundation.IO.Utils.GetPathsFromGuid(System.Guid,System.String,System.String) <a id="bosss.foundation.io.utils.getpathsfromguid(system.guid,system.string,system.string)"></a>
**Summary:** Retrieves the paths to the files in the specified subdirectory
whose file names match a given Guid.
**Parameter:** `uid` - A file Guid
**Parameter:** `dirPath` - The path to the directory containing the file
**Parameter:** `extension` - Optional specification of the file name 
extension (without the preceding dot).
**Returns:**
A path to the file associated with the Guid


## Method: BoSSS.Foundation.IO.Utils.GetSessionFileWriteTime(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.utils.getsessionfilewritetime(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Retrieves the write time of a physical file associated with an
ISessionInfo object.
**Parameter:** `session` - The session in question.
**Returns:**
The last time the file has been written to disk.


## Method: BoSSS.Foundation.IO.Utils.GetGridFileWriteTime(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.utils.getgridfilewritetime(bosss.foundation.io.igridinfo)"></a>
**Summary:** Retrieves the write time of a physical file associated with an
IGridInfo object.
**Parameter:** `grid` - The grid in question.
**Returns:**
The last time the file has been written to disk.


## Method: BoSSS.Foundation.IO.Utils.GetTimestepFileWriteTime(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.utils.gettimestepfilewritetime(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Retrieves the write time of a physical file associated with an
ITimestepInfo object.
**Parameter:** `timestep` - The timestep in question.
**Returns:**
The last time the file has been written to disk.

## Class: BoSSS.Foundation.IO.ISessionInfo <a id="bosss.foundation.io.isessioninfo"></a>

**Summary:** Provides basic information about a session.


### Property: BoSSS.Foundation.IO.ISessionInfo.Description <a id="bosss.foundation.io.isessioninfo.description"></a>
**Summary:** A description of the session. Can be more detailed than the name.


### Property: BoSSS.Foundation.IO.ISessionInfo.ProjectName <a id="bosss.foundation.io.isessioninfo.projectname"></a>
**Summary:** Associates this session with a project


### Property: BoSSS.Foundation.IO.ISessionInfo.Timesteps <a id="bosss.foundation.io.isessioninfo.timesteps"></a>
**Summary:** All the time-steps of this session.


### Property: BoSSS.Foundation.IO.ISessionInfo.RestartedFrom <a id="bosss.foundation.io.isessioninfo.restartedfrom"></a>
**Summary:** The session ID this session has been restarted from.


### Property: BoSSS.Foundation.IO.ISessionInfo.MasterGitCommit <a id="bosss.foundation.io.isessioninfo.mastergitcommit"></a>
**Summary:** the git commit hash of the master branch


### Property: BoSSS.Foundation.IO.ISessionInfo.Tags <a id="bosss.foundation.io.isessioninfo.tags"></a>
**Summary:** A collection of tags for this session.


### Property: BoSSS.Foundation.IO.ISessionInfo.DeployPath <a id="bosss.foundation.io.isessioninfo.deploypath"></a>
**Summary:** path to deploy directory (at the machine at which the session has been computed)


### Property: BoSSS.Foundation.IO.ISessionInfo.ComputeNodeNames <a id="bosss.foundation.io.isessioninfo.computenodenames"></a>
**Summary:** Names of compute nodes on which the session is running; Index: MPI rank index in the
MPI_COMM_WORLD communicator;


### Property: BoSSS.Foundation.IO.ISessionInfo.ThreadPerMPIRank <a id="bosss.foundation.io.isessioninfo.threadpermpirank"></a>
**Summary:** Number of thread per MPI rank in MPI_COMM_WORLD communicator;


### Property: BoSSS.Foundation.IO.ISessionInfo.SuccessfulTermination <a id="bosss.foundation.io.isessioninfo.successfultermination"></a>
**Summary:** If true, the session was successful terminated; if not it is either running, or the simulation may has crashed.


## Method: BoSSS.Foundation.IO.ISessionInfo.GetGrids <a id="bosss.foundation.io.isessioninfo.getgrids"></a>
**Summary:** Returns all the grids used in this session


### Property: BoSSS.Foundation.IO.ISessionInfo.KeysAndQueries <a id="bosss.foundation.io.isessioninfo.keysandqueries"></a>
**Summary:** Keys (DG degree, various settings like timestepping scheme, also the queries) and the corresponding values.

## Class: BoSSS.Foundation.IO.ITimestepInfo <a id="bosss.foundation.io.itimestepinfo"></a>

**Summary:** Information about a single time-step


### Property: BoSSS.Foundation.IO.ITimestepInfo.TimeStepNumber <a id="bosss.foundation.io.itimestepinfo.timestepnumber"></a>
**Summary:** The time-step index/number is represented by the first entry in the
array. In order to handle inner iterations (and possibly inner
iterations of inner iterations, and so on), the subsequent array
elements can be used. E.g. time-step 12 with solver iteration 2323
and sub-iteration 369 would be Indices == [12, 2323, 369].


### Property: BoSSS.Foundation.IO.ITimestepInfo.Grid <a id="bosss.foundation.io.itimestepinfo.grid"></a>
**Summary:** The grid corresponding to this time-step.


### Property: BoSSS.Foundation.IO.ITimestepInfo.Session <a id="bosss.foundation.io.itimestepinfo.session"></a>
**Summary:** The session this time-step belongs to.


### Property: BoSSS.Foundation.IO.ITimestepInfo.GridID <a id="bosss.foundation.io.itimestepinfo.gridid"></a>
**Summary:** Stores information which grid is assigned to this time-step without
having to load the grid.


### Property: BoSSS.Foundation.IO.ITimestepInfo.PhysicalTime <a id="bosss.foundation.io.itimestepinfo.physicaltime"></a>
**Summary:** Physical time in the simulation


### Property: BoSSS.Foundation.IO.ITimestepInfo.StorageID <a id="bosss.foundation.io.itimestepinfo.storageid"></a>
**Summary:** Unique identifier referring to the storage vector


### Property: BoSSS.Foundation.IO.ITimestepInfo.FieldInitializers <a id="bosss.foundation.io.itimestepinfo.fieldinitializers"></a>
**Summary:** Information about the DG fields in this time-step: DG basis, class
type, identification, ...


### Property: BoSSS.Foundation.IO.ITimestepInfo.Fields <a id="bosss.foundation.io.itimestepinfo.fields"></a>
**Summary:** Contains information on the fields of this time-step.

## Class: BoSSS.Foundation.IO.NullDatabaseController <a id="bosss.foundation.io.nulldatabasecontroller"></a>

**Summary:** A null object for [BoSSS.Foundation.IO.IDatabaseController](#bosss.foundation.io.idatabasecontroller)


### Field: BoSSS.Foundation.IO.NullDatabaseController.Instance <a id="bosss.foundation.io.nulldatabasecontroller.instance"></a>
**Summary:** The one and only instance (reference equality)


## Method: BoSSS.Foundation.IO.NullDatabaseController.#ctor <a id="bosss.foundation.io.nulldatabasecontroller.#ctor"></a>
**Summary:** Hides the public default constructor


### Property: BoSSS.Foundation.IO.NullDatabaseController.Database <a id="bosss.foundation.io.nulldatabasecontroller.database"></a>
**Summary:** Not implemented.


### Property: BoSSS.Foundation.IO.NullDatabaseController.DBDriver <a id="bosss.foundation.io.nulldatabasecontroller.dbdriver"></a>
**Summary:** Returns a new driver using a [BoSSS.Foundation.IO.NullFileSystemDriver](#bosss.foundation.io.nullfilesystemdriver)


### Property: BoSSS.Foundation.IO.NullDatabaseController.Sessions <a id="bosss.foundation.io.nulldatabasecontroller.sessions"></a>
**Summary:** An empty list.


### Property: BoSSS.Foundation.IO.NullDatabaseController.Grids <a id="bosss.foundation.io.nulldatabasecontroller.grids"></a>
**Summary:** An empty list.


## Method: BoSSS.Foundation.IO.NullDatabaseController.GetSessionInfo(System.Guid) <a id="bosss.foundation.io.nulldatabasecontroller.getsessioninfo(system.guid)"></a>
**Summary:** Returns null
**Parameter:** `sessionID` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.AddGridInitializationContext(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.io.nulldatabasecontroller.addgridinitializationcontext(bosss.foundation.grid.igriddata)"></a>
**Summary:** Does nothing.
**Parameter:** `gridData` - 


## Method: BoSSS.Foundation.IO.NullDatabaseController.GetInitializationContext(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.nulldatabasecontroller.getinitializationcontext(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Returns null.
**Parameter:** `timestepGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.GetSessionInfos(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.nulldatabasecontroller.getsessioninfos(bosss.foundation.io.igridinfo)"></a>
**Summary:** Returns an empty list
**Parameter:** `grid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.SaveSessionInfo(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.nulldatabasecontroller.savesessioninfo(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Does nothing
**Parameter:** `session` - 


## Method: BoSSS.Foundation.IO.NullDatabaseController.DeleteSession(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.nulldatabasecontroller.deletesession(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Does nothing
**Parameter:** `session` - 


## Method: BoSSS.Foundation.IO.NullDatabaseController.CopySession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.nulldatabasecontroller.copysession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Does nothing
**Parameter:** `session` - 
**Parameter:** `dest` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.MoveSession(BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.nulldatabasecontroller.movesession(bosss.foundation.io.isessioninfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Does nothing
**Parameter:** `session` - 
**Parameter:** `dest` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.DeleteTimestep(BoSSS.Foundation.IO.ITimestepInfo) <a id="bosss.foundation.io.nulldatabasecontroller.deletetimestep(bosss.foundation.io.itimestepinfo)"></a>
**Summary:** Does nothing
**Parameter:** `timestep` - 


## Method: BoSSS.Foundation.IO.NullDatabaseController.GetTimestepInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.nulldatabasecontroller.gettimestepinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Returns an empty list
**Parameter:** `session` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.GetGridInfo(System.Guid) <a id="bosss.foundation.io.nulldatabasecontroller.getgridinfo(system.guid)"></a>
**Summary:** Returns null
**Parameter:** `gridID` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.SaveGridInfo(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.nulldatabasecontroller.savegridinfo(bosss.foundation.io.igridinfo)"></a>
**Summary:** Does nothing.
**Parameter:** `grid` - 


## Method: BoSSS.Foundation.IO.NullDatabaseController.GetGridInfos(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.nulldatabasecontroller.getgridinfos(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Returns an empty list
**Parameter:** `session` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.GetGridFiles(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.nulldatabasecontroller.getgridfiles(bosss.foundation.io.igridinfo)"></a>
**Summary:** Returns an empty list
**Parameter:** `grid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.DeleteGrid(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.io.nulldatabasecontroller.deletegrid(bosss.foundation.io.igridinfo)"></a>
**Summary:** Does nothing.
**Parameter:** `grid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.DeleteGrid(BoSSS.Foundation.IO.IGridInfo,System.Boolean) <a id="bosss.foundation.io.nulldatabasecontroller.deletegrid(bosss.foundation.io.igridinfo,system.boolean)"></a>
**Summary:** Does nothing.
**Parameter:** `grid` - 
**Parameter:** `safelyDelete` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.CopyGrid(BoSSS.Foundation.IO.IGridInfo,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.nulldatabasecontroller.copygrid(bosss.foundation.io.igridinfo,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Does nothing and returns null.
**Parameter:** `grid` - 
**Parameter:** `destination` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullDatabaseController.ClearDatabase <a id="bosss.foundation.io.nulldatabasecontroller.cleardatabase"></a>
**Summary:** Does nothing.


## Method: BoSSS.Foundation.IO.NullDatabaseController.CleanDatabase <a id="bosss.foundation.io.nulldatabasecontroller.cleandatabase"></a>
**Summary:** Does nothing.

## Class: BoSSS.Foundation.IO.NullDatabaseInfo <a id="bosss.foundation.io.nulldatabaseinfo"></a>

**Summary:** Null object for [BoSSS.Foundation.IO.IDatabaseInfo](#bosss.foundation.io.idatabaseinfo)


### Field: BoSSS.Foundation.IO.NullDatabaseInfo.Instance <a id="bosss.foundation.io.nulldatabaseinfo.instance"></a>
**Summary:** The one and only instance (reference equality)


## Method: BoSSS.Foundation.IO.NullDatabaseInfo.#ctor <a id="bosss.foundation.io.nulldatabaseinfo.#ctor"></a>
**Summary:** Hides the public default constructor


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.Path <a id="bosss.foundation.io.nulldatabaseinfo.path"></a>
**Summary:** Returns an empty path


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.Controller <a id="bosss.foundation.io.nulldatabaseinfo.controller"></a>
**Summary:** Returns [BoSSS.Foundation.IO.NullDatabaseController.Instance](#bosss.foundation.io.nulldatabasecontroller.instance)


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.Sessions <a id="bosss.foundation.io.nulldatabaseinfo.sessions"></a>
**Summary:** An empty collection.


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.Grids <a id="bosss.foundation.io.nulldatabaseinfo.grids"></a>
**Summary:** An empty collection.


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.Projects <a id="bosss.foundation.io.nulldatabaseinfo.projects"></a>
**Summary:** An empty dictionary.


### Property: BoSSS.Foundation.IO.NullDatabaseInfo.AlternateDbPaths <a id="bosss.foundation.io.nulldatabaseinfo.alternatedbpaths"></a>
**Summary:** Contains nothing


## Method: BoSSS.Foundation.IO.NullDatabaseInfo.Equals(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.nulldatabaseinfo.equals(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Reference equality


## Method: BoSSS.Foundation.IO.NullDatabaseInfo.Equals(System.Object) <a id="bosss.foundation.io.nulldatabaseinfo.equals(system.object)"></a>


## Method: BoSSS.Foundation.IO.NullDatabaseInfo.GetHashCode <a id="bosss.foundation.io.nulldatabaseinfo.gethashcode"></a>


## Method: BoSSS.Foundation.IO.NullDatabaseInfo.PathMatch(System.String) <a id="bosss.foundation.io.nulldatabaseinfo.pathmatch(system.string)"></a>
**Summary:** Always false

## Class: BoSSS.Foundation.IO.NullFileSystemDriver <a id="bosss.foundation.io.nullfilesystemdriver"></a>

**Summary:** Null object for [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)


### Field: BoSSS.Foundation.IO.NullFileSystemDriver.Instance <a id="bosss.foundation.io.nullfilesystemdriver.instance"></a>
**Summary:** The one and only instance (reference equality)


## Method: BoSSS.Foundation.IO.NullFileSystemDriver.#ctor <a id="bosss.foundation.io.nullfilesystemdriver.#ctor"></a>
**Summary:** Hides the public default constructor


## Method: BoSSS.Foundation.IO.NullFileSystemDriver.IsSessionInUse(System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.issessioninuse(system.guid)"></a>
**Summary:** Returns false.
**Parameter:** `_SessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetNewLogStream(System.String,System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.getnewlogstream(system.string,system.guid)"></a>
**Summary:** Returns the **System.IO.StreamWriter.BaseStream** of
**System.IO.StreamWriter.Null**
**Parameter:** `logName` - 
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetNewLog(System.String,System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.getnewlog(system.string,system.guid)"></a>
**Summary:** Returns **System.IO.TextWriter.Null**
**Parameter:** `logName` - 
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetTimestepLogPath(System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.gettimesteplogpath(system.guid)"></a>
**Summary:** Returns an empty string
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetTimestepLogStream(System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.gettimesteplogstream(system.guid)"></a>
**Summary:** Not implemented.
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.CreateSessionDirectory(System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.createsessiondirectory(system.guid)"></a>
**Summary:** Does nothing
**Parameter:** `_SessionGuid` - 


## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetGridStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.getgridstream(system.boolean,system.guid)"></a>
**Summary:** Not implemented.
**Parameter:** `create` - 
**Parameter:** `gridGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetDistVectorDataStream(System.Boolean,System.Guid,System.Int32) <a id="bosss.foundation.io.nullfilesystemdriver.getdistvectordatastream(system.boolean,system.guid,system.int32)"></a>
**Summary:** Not implemented.
**Parameter:** `create` - 
**Parameter:** `vecGuid` - 
**Parameter:** `part` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetTimestepStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.gettimestepstream(system.boolean,system.guid)"></a>
**Summary:** Not implemented.
**Parameter:** `create` - 
**Parameter:** `id` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetSessionInfoStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.nullfilesystemdriver.getsessioninfostream(system.boolean,system.guid)"></a>
**Summary:** Not implemented.
**Parameter:** `create` - 
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetAllGridGUIDs <a id="bosss.foundation.io.nullfilesystemdriver.getallgridguids"></a>
**Summary:** Returns an empty collection.
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetAllSessionGUIDs <a id="bosss.foundation.io.nullfilesystemdriver.getallsessionguids"></a>
**Summary:** Returns an empty list.
**Returns:**



## Method: BoSSS.Foundation.IO.NullFileSystemDriver.GetAllDataVectorGUIDs <a id="bosss.foundation.io.nullfilesystemdriver.getalldatavectorguids"></a>
**Summary:** Returns an empty list.
**Returns:**



### Property: BoSSS.Foundation.IO.NullFileSystemDriver.BasePath <a id="bosss.foundation.io.nullfilesystemdriver.basepath"></a>
**Summary:** Empty


### Property: BoSSS.Foundation.IO.NullFileSystemDriver.IsDisposed <a id="bosss.foundation.io.nullfilesystemdriver.isdisposed"></a>
**Summary:** Always returns false


## Method: BoSSS.Foundation.IO.NullFileSystemDriver.Dispose <a id="bosss.foundation.io.nullfilesystemdriver.dispose"></a>
**Summary:** Does nothing

## Class: BoSSS.Foundation.IO.PartialGuid <a id="bosss.foundation.io.partialguid"></a>

**Summary:** The first part of a full **System.Guid**. Useful for the selection
of objects without having to specify the full-length
**System.Guid**.


### Field: BoSSS.Foundation.IO.PartialGuid.GUID_LENGTH <a id="bosss.foundation.io.partialguid.guid_length"></a>
**Summary:** The length of a guid by definition


### Field: BoSSS.Foundation.IO.PartialGuid.guid <a id="bosss.foundation.io.partialguid.guid"></a>
**Summary:** Use a full guid as internal storage so that validation routines are
automatically reused


### Field: BoSSS.Foundation.IO.PartialGuid.significantLength <a id="bosss.foundation.io.partialguid.significantlength"></a>
**Summary:** The number of digits of [BoSSS.Foundation.IO.PartialGuid.guid](#bosss.foundation.io.partialguid.guid) that are significant for
this guid (i.e., the length of this partial guid)


## Method: BoSSS.Foundation.IO.PartialGuid.#ctor(System.String) <a id="bosss.foundation.io.partialguid.#ctor(system.string)"></a>
**Summary:** Initializes a new instance of the [BoSSS.Foundation.IO.PartialGuid](#bosss.foundation.io.partialguid) struct.
**Parameter:** `partialGuid` - A portion of a guid, i.e. a substring of a string in a format that
defines a valid **System.Guid**.


## Method: BoSSS.Foundation.IO.PartialGuid.CompareTo(System.Object) <a id="bosss.foundation.io.partialguid.compareto(system.object)"></a>
**Summary:** See [BoSSS.Foundation.IO.PartialGuid.CompareTo(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.compareto(bosss.foundation.io.partialguid))
**Parameter:** `obj` - See [BoSSS.Foundation.IO.PartialGuid.CompareTo(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.compareto(bosss.foundation.io.partialguid))
**Returns:**
See [BoSSS.Foundation.IO.PartialGuid.CompareTo(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.compareto(bosss.foundation.io.partialguid))


## Method: BoSSS.Foundation.IO.PartialGuid.CompareTo(BoSSS.Foundation.IO.PartialGuid) <a id="bosss.foundation.io.partialguid.compareto(bosss.foundation.io.partialguid)"></a>
**Summary:** Compares this guid to the given 'other' by
comparing the respective string representations.
**Parameter:** `other` - The partial guid to be compared to.
**Returns:**
See **System.IComparable`1.CompareTo(`0)**.


## Method: BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid) <a id="bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid)"></a>
**Summary:** Checks of this guid is equal to the given
'guid' by comparing only the respective string
representation up to the length of the shorter guid. As a
result, this is a diffuse equality comparison.
**Parameter:** `guid` - The guid to be compared to.
**Returns:**
True, if both strings are approximately equal.


## Method: BoSSS.Foundation.IO.PartialGuid.ToString <a id="bosss.foundation.io.partialguid.tostring"></a>
**Summary:** Returns a **System.String** that represents this
instance.
**Returns:**
A **System.String** that represents this instance.


## Method: BoSSS.Foundation.IO.PartialGuid.Equals(System.Object) <a id="bosss.foundation.io.partialguid.equals(system.object)"></a>
**Summary:** See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Parameter:** `obj` - See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Returns:**
See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))


## Method: BoSSS.Foundation.IO.PartialGuid.GetHashCode <a id="bosss.foundation.io.partialguid.gethashcode"></a>
**Summary:** Returns a hash code for this instance.
**Returns:**
A hash code for this instance, suitable for use in hashing
algorithms and data structures like a hash table.


## Method: BoSSS.Foundation.IO.PartialGuid.op_Equality(BoSSS.Foundation.IO.PartialGuid,BoSSS.Foundation.IO.PartialGuid) <a id="bosss.foundation.io.partialguid.op_equality(bosss.foundation.io.partialguid,bosss.foundation.io.partialguid)"></a>
**Summary:** See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Parameter:** `a` - See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Parameter:** `b` - See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Returns:**
See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))


## Method: BoSSS.Foundation.IO.PartialGuid.op_Inequality(BoSSS.Foundation.IO.PartialGuid,BoSSS.Foundation.IO.PartialGuid) <a id="bosss.foundation.io.partialguid.op_inequality(bosss.foundation.io.partialguid,bosss.foundation.io.partialguid)"></a>
**Summary:** Negation of [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Parameter:** `a` - See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Parameter:** `b` - See [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))
**Returns:**
Negation of [BoSSS.Foundation.IO.PartialGuid.Equals(BoSSS.Foundation.IO.PartialGuid)](#bosss.foundation.io.partialguid.equals(bosss.foundation.io.partialguid))


## Method: BoSSS.Foundation.IO.PartialGuid.op_Implicit(System.String)~BoSSS.Foundation.IO.PartialGuid <a id="bosss.foundation.io.partialguid.op_implicit(system.string)~bosss.foundation.io.partialguid"></a>
**Summary:** Implicit conversion from a string to a partial guid
**Parameter:** `partialGuid` - A string representing a portion of a **System.Guid**.
**Returns:**
A partial guid.
**Remark:**
In some sense, this operator violates the contract for an implicit
conversion since it may fail if 'partialGuid' is
not in a suitable format. However, the additional benefit when
using a console interface outweigh this disadvantage.


## Method: BoSSS.Foundation.IO.PartialGuid.op_Implicit(System.Guid)~BoSSS.Foundation.IO.PartialGuid <a id="bosss.foundation.io.partialguid.op_implicit(system.guid)~bosss.foundation.io.partialguid"></a>
**Summary:** Implicit conversion from a **System.Guid** to a partial guid.
**Parameter:** `guid` - A string representing a portion of a **System.Guid**.
**Returns:**
A partial guid.

## Class: BoSSS.Foundation.IO.SessionInfo <a id="bosss.foundation.io.sessioninfo"></a>

**Summary:** Stores information about a session.


## Method: BoSSS.Foundation.IO.SessionInfo.#ctor(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessioninfo.#ctor(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new instance of SessionInfo.
**Parameter:** `uid` - The unique identifier of the session.
**Parameter:** `database` - The database where the session is stored.


### Property: BoSSS.Foundation.IO.SessionInfo.Description <a id="bosss.foundation.io.sessioninfo.description"></a>
**Summary:** Description for the session. Changing this value causes an 
immediate IO operation.


### Property: BoSSS.Foundation.IO.SessionInfo.ProjectName <a id="bosss.foundation.io.sessioninfo.projectname"></a>
**Summary:** Associates this session with a project.  Changing this value causes
an  immediate IO operation.


### Field: BoSSS.Foundation.IO.SessionInfo.WorkingDirectory <a id="bosss.foundation.io.sessioninfo.workingdirectory"></a>
**Summary:** Directory in which the solver was executed


### Property: BoSSS.Foundation.IO.SessionInfo.Timesteps <a id="bosss.foundation.io.sessioninfo.timesteps"></a>
**Summary:** All the time-steps of this session.


### Property: BoSSS.Foundation.IO.SessionInfo.KeysAndQueries <a id="bosss.foundation.io.sessioninfo.keysandqueries"></a>
**Summary:** see [BoSSS.Foundation.IO.ISessionInfo.KeysAndQueries](#bosss.foundation.io.isessioninfo.keysandqueries)


### Property: BoSSS.Foundation.IO.SessionInfo.RestartedFrom <a id="bosss.foundation.io.sessioninfo.restartedfrom"></a>
**Summary:** The session ID this session has been restarted from.


### Property: BoSSS.Foundation.IO.SessionInfo.MasterGitCommit <a id="bosss.foundation.io.sessioninfo.mastergitcommit"></a>
**Summary:** the git commit hash of the master branch


### Property: BoSSS.Foundation.IO.SessionInfo.Tags <a id="bosss.foundation.io.sessioninfo.tags"></a>
**Summary:** A collection of tags for this session.


## Method: BoSSS.Foundation.IO.SessionInfo.AddTag(System.String) <a id="bosss.foundation.io.sessioninfo.addtag(system.string)"></a>
**Summary:** Adds a string to [BoSSS.Foundation.IO.SessionInfo.Tags](#bosss.foundation.io.sessioninfo.tags), if not already contained
**Parameter:** `tag` - 
**Returns:**
- true: tag was freshly added
- false: 'tag' is already contained in [BoSSS.Foundation.IO.SessionInfo.Tags](#bosss.foundation.io.sessioninfo.tags)


## Method: BoSSS.Foundation.IO.SessionInfo.GetGrids <a id="bosss.foundation.io.sessioninfo.getgrids"></a>
**Summary:** Returns all the grids used in this session


### Property: BoSSS.Foundation.IO.SessionInfo.ID <a id="bosss.foundation.io.sessioninfo.id"></a>
**Summary:** Unique identifier of the session.


### Property: BoSSS.Foundation.IO.SessionInfo.CreationTime <a id="bosss.foundation.io.sessioninfo.creationtime"></a>
**Summary:** The time when the represented entity has been created.


### Property: BoSSS.Foundation.IO.SessionInfo.WriteTime <a id="bosss.foundation.io.sessioninfo.writetime"></a>
**Summary:** The time when this object has been written to disc.


### Property: BoSSS.Foundation.IO.SessionInfo.Name <a id="bosss.foundation.io.sessioninfo.name"></a>
**Summary:** The name of the session.


### Property: BoSSS.Foundation.IO.SessionInfo.Database <a id="bosss.foundation.io.sessioninfo.database"></a>
**Summary:** The database where this info object is located.


## Method: BoSSS.Foundation.IO.SessionInfo.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessioninfo.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies this IDatabaseObjectInfo object for storage in a different database.
**Parameter:** `targetDatabase` - The target database
**Returns:**
A copy of this IDatabaseObjectInfo object with all the same
information, except for the database field, which will be the one of the 
target database


### Field: BoSSS.Foundation.IO.SessionInfo.NOT_TERMINATED_TAG <a id="bosss.foundation.io.sessioninfo.not_terminated_tag"></a>
**Summary:** Tag to mark crashed **and** currently running sessions in the database.
It (should be) automatically added to each session at startup
and removed if the application terminates correctly, i.e. without exceptions or such stuff, you know.


### Field: BoSSS.Foundation.IO.SessionInfo.SOLVER_ERROR <a id="bosss.foundation.io.sessioninfo.solver_error"></a>
**Summary:** Tag to mark sessions in which


### Property: BoSSS.Foundation.IO.SessionInfo.SuccessfulTermination <a id="bosss.foundation.io.sessioninfo.successfultermination"></a>
**Summary:** If true, the session was successful terminated; if not it is either running, or the simulation may has crashed.


## Method: BoSSS.Foundation.IO.SessionInfo.ToString <a id="bosss.foundation.io.sessioninfo.tostring"></a>
**Summary:** Creates a string representation of this object.
**Returns:**
A string representing the object.


## Method: BoSSS.Foundation.IO.SessionInfo.Equals(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.sessioninfo.equals(bosss.foundation.io.isessioninfo)"></a>
**Summary:** Compares this session to another.
**Parameter:** `other` - The session to compare to.
**Returns:**
true, if the session GUIDs are the same; false otherwise.


### Property: BoSSS.Foundation.IO.SessionInfo.DeployPath <a id="bosss.foundation.io.sessioninfo.deploypath"></a>
**Summary:** path to deploy dir


### Property: BoSSS.Foundation.IO.SessionInfo.ThreadPerMPIRank <a id="bosss.foundation.io.sessioninfo.threadpermpirank"></a>
**Summary:** Number of threads per MPI rank


### Field: BoSSS.Foundation.IO.SessionInfo.m_ThreadPerMPIRank <a id="bosss.foundation.io.sessioninfo.m_threadpermpirank"></a>
**Summary:** [BoSSS.Foundation.IO.SessionInfo.ThreadPerMPIRank](#bosss.foundation.io.sessioninfo.threadpermpirank)


### Property: BoSSS.Foundation.IO.SessionInfo.ComputeNodeNames <a id="bosss.foundation.io.sessioninfo.computenodenames"></a>
**Summary:** Names of compute nodes on which the session is running; Index: MPI
rank index in the MPI_COMM_WORLD communicator;


### Field: BoSSS.Foundation.IO.SessionInfo.m_ComputeNodeNames <a id="bosss.foundation.io.sessioninfo.m_computenodenames"></a>
**Summary:** [BoSSS.Foundation.IO.SessionInfo.ComputeNodeNames](#bosss.foundation.io.sessioninfo.computenodenames)


## Method: BoSSS.Foundation.IO.SessionInfo.RemoveTimestep(System.Guid) <a id="bosss.foundation.io.sessioninfo.removetimestep(system.guid)"></a>
**Summary:** added to support deleting time-steps form a session during computation
(e.g. one wants to save only every 10000th time-step, but still have the latest 3 available for BDF-restart)


## Method: BoSSS.Foundation.IO.SessionInfo.Save <a id="bosss.foundation.io.sessioninfo.save"></a>
**Summary:** Saves the current state of this object to the associated
[BoSSS.Foundation.IO.SessionInfo.Database](#bosss.foundation.io.sessioninfo.database).


## Method: BoSSS.Foundation.IO.SessionInfo.Dispose <a id="bosss.foundation.io.sessioninfo.dispose"></a>
**Summary:** Dispo.

## Class: BoSSS.Foundation.IO.SessionInfo.KeysDict <a id="bosss.foundation.io.sessioninfo.keysdict"></a>

**Summary:** Custom (very-low-performance) dictionary for the [BoSSS.Foundation.IO.SessionInfo.KeysAndQueries](#bosss.foundation.io.sessioninfo.keysandqueries)-property,
triggers the serialization of the session info if something is changed.

## Class: BoSSS.Foundation.IO.SessionProxy <a id="bosss.foundation.io.sessionproxy"></a>

**Summary:** A proxy for [BoSSS.Foundation.IO.SessionInfo](#bosss.foundation.io.sessioninfo) objects that allows for lazy
loading


### Field: BoSSS.Foundation.IO.SessionProxy.realSessionInfo <a id="bosss.foundation.io.sessionproxy.realsessioninfo"></a>
**Summary:** The real session reflected by this object


### Property: BoSSS.Foundation.IO.SessionProxy.RealSessionInfo <a id="bosss.foundation.io.sessionproxy.realsessioninfo"></a>
**Summary:** The real session reflected by this object


## Method: BoSSS.Foundation.IO.SessionProxy.Dispose <a id="bosss.foundation.io.sessionproxy.dispose"></a>
**Summary:** Dissing.


## Method: BoSSS.Foundation.IO.SessionProxy.#ctor(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessionproxy.#ctor(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Constructs a proxy for the session with id
'sessionID' within the given
'database'
**Parameter:** `sessionID` - 
**Parameter:** `database` - 


## Method: BoSSS.Foundation.IO.SessionProxy.ToString <a id="bosss.foundation.io.sessionproxy.tostring"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.ToString](#bosss.foundation.io.sessioninfo.tostring)
**Returns:**



### Property: BoSSS.Foundation.IO.SessionProxy.SuccessfulTermination <a id="bosss.foundation.io.sessionproxy.successfultermination"></a>
**Summary:** see [BoSSS.Foundation.IO.ISessionInfo.SuccessfulTermination](#bosss.foundation.io.isessioninfo.successfultermination)


### Property: BoSSS.Foundation.IO.SessionProxy.Description <a id="bosss.foundation.io.sessionproxy.description"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.Description](#bosss.foundation.io.sessioninfo.description)


### Property: BoSSS.Foundation.IO.SessionProxy.ProjectName <a id="bosss.foundation.io.sessionproxy.projectname"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.ProjectName](#bosss.foundation.io.sessioninfo.projectname)


### Property: BoSSS.Foundation.IO.SessionProxy.Timesteps <a id="bosss.foundation.io.sessionproxy.timesteps"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.Timesteps](#bosss.foundation.io.sessioninfo.timesteps)


### Property: BoSSS.Foundation.IO.SessionProxy.RestartedFrom <a id="bosss.foundation.io.sessionproxy.restartedfrom"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.RestartedFrom](#bosss.foundation.io.sessioninfo.restartedfrom)


### Property: BoSSS.Foundation.IO.SessionProxy.MasterGitCommit <a id="bosss.foundation.io.sessionproxy.mastergitcommit"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.MasterGitCommit](#bosss.foundation.io.sessioninfo.mastergitcommit)


### Property: BoSSS.Foundation.IO.SessionProxy.ThreadPerMPIRank <a id="bosss.foundation.io.sessionproxy.threadpermpirank"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.ThreadPerMPIRank](#bosss.foundation.io.sessioninfo.threadpermpirank)


### Property: BoSSS.Foundation.IO.SessionProxy.Tags <a id="bosss.foundation.io.sessionproxy.tags"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.Tags](#bosss.foundation.io.sessioninfo.tags)


### Property: BoSSS.Foundation.IO.SessionProxy.ComputeNodeNames <a id="bosss.foundation.io.sessionproxy.computenodenames"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.ComputeNodeNames](#bosss.foundation.io.sessioninfo.computenodenames)


### Property: BoSSS.Foundation.IO.SessionProxy.DeployPath <a id="bosss.foundation.io.sessionproxy.deploypath"></a>


## Method: BoSSS.Foundation.IO.SessionProxy.GetGrids <a id="bosss.foundation.io.sessionproxy.getgrids"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.GetGrids](#bosss.foundation.io.sessioninfo.getgrids)


### Property: BoSSS.Foundation.IO.SessionProxy.ID <a id="bosss.foundation.io.sessionproxy.id"></a>
**Summary:** The id of the session


### Property: BoSSS.Foundation.IO.SessionProxy.CreationTime <a id="bosss.foundation.io.sessionproxy.creationtime"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.CreationTime](#bosss.foundation.io.sessioninfo.creationtime)


### Property: BoSSS.Foundation.IO.SessionProxy.WriteTime <a id="bosss.foundation.io.sessionproxy.writetime"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.WriteTime](#bosss.foundation.io.sessioninfo.writetime). Note that reading this
property does not induce deserialization of the reflected
session.


### Property: BoSSS.Foundation.IO.SessionProxy.Name <a id="bosss.foundation.io.sessionproxy.name"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.Name](#bosss.foundation.io.sessioninfo.name)


### Property: BoSSS.Foundation.IO.SessionProxy.Database <a id="bosss.foundation.io.sessionproxy.database"></a>
**Summary:** The associated database


### Property: BoSSS.Foundation.IO.SessionProxy.KeysAndQueries <a id="bosss.foundation.io.sessionproxy.keysandqueries"></a>
**Summary:** see [BoSSS.Foundation.IO.ISessionInfo.KeysAndQueries](#bosss.foundation.io.isessioninfo.keysandqueries)


## Method: BoSSS.Foundation.IO.SessionProxy.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessionproxy.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new session proxy for the given
'targetDatabase'.
**Parameter:** `targetDatabase` - 
**Returns:**



## Method: BoSSS.Foundation.IO.SessionProxy.Equals(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.sessionproxy.equals(bosss.foundation.io.isessioninfo)"></a>
**Summary:** See [BoSSS.Foundation.IO.SessionInfo.Equals(BoSSS.Foundation.IO.ISessionInfo)](#bosss.foundation.io.sessioninfo.equals(bosss.foundation.io.isessioninfo))

## Class: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo <a id="bosss.foundation.io.sessionproxy.nullsessioninfo"></a>

**Summary:** Null object that is used whenever loading a session fails.


### Field: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Instance <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.instance"></a>
**Summary:** The one and only instance of this class.


## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.#ctor <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.#ctor"></a>
**Summary:** Forbid creation


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Description <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.description"></a>
**Summary:** Always empty; writing is a non-operation


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.ProjectName <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.projectname"></a>
**Summary:** Always empty; writing is a non-operation


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Timesteps <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.timesteps"></a>
**Summary:** An empty list


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.RestartedFrom <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.restartedfrom"></a>
**Summary:** An empty guid


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.MasterGitCommit <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.mastergitcommit"></a>
**Summary:** An empty string


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Tags <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.tags"></a>


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.DeployPath <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.deploypath"></a>


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.ThreadPerMPIRank <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.threadpermpirank"></a>
**Summary:** An empty list


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.ComputeNodeNames <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.computenodenames"></a>
**Summary:** An empty list


## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.GetGrids <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.getgrids"></a>
**Summary:** An empty list
**Returns:**



### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.ID <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.id"></a>
**Summary:** An empty guid


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.CreationTime <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.creationtime"></a>
**Summary:** See **System.DateTime.MinValue**


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.WriteTime <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.writetime"></a>
**Summary:** See **System.DateTime.MinValue**


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Name <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.name"></a>
**Summary:** An empty string; writing is a non-operation


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Database <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.database"></a>
**Summary:** See [BoSSS.Foundation.IO.NullDatabaseInfo.Instance](#bosss.foundation.io.nulldatabaseinfo.instance)


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.KeysAndQueries <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.keysandqueries"></a>
**Summary:** Nix


### Property: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.SuccessfulTermination <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.successfultermination"></a>
**Summary:** always false


## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Always throws **System.NotImplementedException**
**Parameter:** `targetDatabase` - 
**Returns:**



## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Equals(BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.equals(bosss.foundation.io.isessioninfo)"></a>
**Summary:** See **System.Object.ReferenceEquals(System.Object,System.Object)**
**Parameter:** `other` - 
**Returns:**



## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.ToString <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.tostring"></a>
**Summary:** Displays an error message
**Returns:**



## Method: BoSSS.Foundation.IO.SessionProxy.NullSessionInfo.Dispose <a id="bosss.foundation.io.sessionproxy.nullsessioninfo.dispose"></a>
**Summary:** Does nothing.

## Class: BoSSS.Foundation.IO.StandardFsDriver <a id="bosss.foundation.io.standardfsdriver"></a>

**Summary:** IO driver for standard file systems;


## Method: BoSSS.Foundation.IO.StandardFsDriver.#ctor(System.String) <a id="bosss.foundation.io.standardfsdriver.#ctor(system.string)"></a>
**Summary:** constructor
**Parameter:** `databasePath` -
- if pointing to a directory, a normal BoSSS database
- if pointing to a file, a ZIP archive of a BoSSS database


### Field: BoSSS.Foundation.IO.StandardFsDriver.UnZippedDirectory <a id="bosss.foundation.io.standardfsdriver.unzippeddirectory"></a>
**Summary:** If database was extracted from zip file, this is the path, and on exit/dispose we have to delete it.


## Method: BoSSS.Foundation.IO.StandardFsDriver.VerifyDirectoryStructure(System.String) <a id="bosss.foundation.io.standardfsdriver.verifydirectorystructure(system.string)"></a>
**Summary:** checks whether a path 'path' is the root
of a valid BoSSS database (i.e. it contains all
necessary subfolders);
If it isn't, a **System.ArgumentException** is thrown;
**Parameter:** `path` - 


### Property: BoSSS.Foundation.IO.StandardFsDriver.SessionsDir <a id="bosss.foundation.io.standardfsdriver.sessionsdir"></a>
**Summary:** base directory of all sessions


### Property: BoSSS.Foundation.IO.StandardFsDriver.GridsDir <a id="bosss.foundation.io.standardfsdriver.gridsdir"></a>
**Summary:** base directory for grids


### Property: BoSSS.Foundation.IO.StandardFsDriver.DistVectorDataDir <a id="bosss.foundation.io.standardfsdriver.distvectordatadir"></a>
**Summary:** relative path to data chunks of distributed vectors


### Property: BoSSS.Foundation.IO.StandardFsDriver.TimestepDir <a id="bosss.foundation.io.standardfsdriver.timestepdir"></a>
**Summary:** relative path to timestep state objects


### Property: BoSSS.Foundation.IO.StandardFsDriver.BasePath <a id="bosss.foundation.io.standardfsdriver.basepath"></a>
**Summary:** Base path to a database


## Method: BoSSS.Foundation.IO.StandardFsDriver.OpenFileCooperatively(System.Boolean,System.String,System.Boolean) <a id="bosss.foundation.io.standardfsdriver.openfilecooperatively(system.boolean,system.string,system.boolean)"></a>
**Summary:** This is intended for files which store log-files: 
Opens some file in the database **cooperatively**, i.e. if it is opened for writing ('create' == true)
this method will allow reading by any other process.
Simultaneous writing, however, should yield to an exception.
**Parameter:** `create` -
- true: creates a new file for writing;
- false: open a file for reading;
**Parameter:** `RelPath` - relative path within the base paths.
**Parameter:** `ForceOverride` -
when opening a stream for writing ('create'=true), this argument
toggles how existing files should be treated:
- false: an exception is thrown if the file already exists;
- true: an existing file would be overwritten
**Returns:**
a file stream


## Method: BoSSS.Foundation.IO.StandardFsDriver.OpenFileExclusiveBlocking(System.Boolean,System.String,System.Boolean) <a id="bosss.foundation.io.standardfsdriver.openfileexclusiveblocking(system.boolean,system.string,system.boolean)"></a>
**Summary:** This is intended for files which store objects: 
Opens some file in the database **exclusively**, i.e. if it is opened for writing ('create' == true)
this method will block on any other process 
for write **and read** operations until the file 
is released by the first process.
Simultaneous reading should be allowed, however.
**Parameter:** `create` -
- true: creates a new file for writing;
- false: open a file for reading;
**Parameter:** `RelPath` - relative path within the base paths.
**Parameter:** `ForceOverride` -
when opening a stream for writing ('create'=true), this argument
toggles how existing files should be treated:
- false: an exception is thrown if the file already exists;
- true: an existing file would be overwritten
**Returns:**
a file stream


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetDistVectorDataStream(System.Boolean,System.Guid,System.Int32) <a id="bosss.foundation.io.standardfsdriver.getdistvectordatastream(system.boolean,system.guid,system.int32)"></a>
**Parameter:** `create` - true: creates a new file for writing, an exception is thrown if the file already exists;
false: open a file for reading;
**Parameter:** `vecGuid` - 
**Parameter:** `part` - 
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.GetTimestepStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.standardfsdriver.gettimestepstream(system.boolean,system.guid)"></a>
**Summary:** See [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)
**Parameter:** `create` - 
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.Dispose <a id="bosss.foundation.io.standardfsdriver.dispose"></a>
**Summary:** closes logfiles, ...


### Property: BoSSS.Foundation.IO.StandardFsDriver.IsDisposed <a id="bosss.foundation.io.standardfsdriver.isdisposed"></a>
**Summary:** true if [BoSSS.Foundation.IO.StandardFsDriver.Dispose](#bosss.foundation.io.standardfsdriver.dispose) has been called


## Method: BoSSS.Foundation.IO.StandardFsDriver.CreateSessionDirectory(System.Guid) <a id="bosss.foundation.io.standardfsdriver.createsessiondirectory(system.guid)"></a>
**Summary:** creates a new session directory.


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetGridStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.standardfsdriver.getgridstream(system.boolean,system.guid)"></a>
**Summary:** [BoSSS.Foundation.IO.IFileSystemDriver.GetGridStream(System.Boolean,System.Guid)](#bosss.foundation.io.ifilesystemdriver.getgridstream(system.boolean,system.guid))


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetSessionInfoStream(System.Boolean,System.Guid) <a id="bosss.foundation.io.standardfsdriver.getsessioninfostream(system.boolean,system.guid)"></a>
**Summary:** See [BoSSS.Foundation.IO.IFileSystemDriver](#bosss.foundation.io.ifilesystemdriver)
**Parameter:** `create` -
- true for a write stream (also overwriting)
- false for a read stream;
**Parameter:** `sessionGuid` - 
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.GetNewLogStream(System.String,System.Guid) <a id="bosss.foundation.io.standardfsdriver.getnewlogstream(system.string,system.guid)"></a>
**Summary:** returns a stream for logging information
**Parameter:** `logName` - name for the logfile;
this name identifies the log within the session;
**Parameter:** `sessionGuid` - the session in which the log should be created.
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.GetNewLog(System.String,System.Guid) <a id="bosss.foundation.io.standardfsdriver.getnewlog(system.string,system.guid)"></a>
**Summary:** returns a text writer for logging information
**Parameter:** `logName` - name for the logfile;
this name identifies the log within the session;
**Parameter:** `sessionGuid` - the session in which the log should be created.
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.GetTimestepLogPath(System.Guid) <a id="bosss.foundation.io.standardfsdriver.gettimesteplogpath(system.guid)"></a>
**Summary:** Returns the path to the time-step log.
**Parameter:** `sessionGuid` - The ID of the session.
**Returns:**
The path to the session's time-step log.


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetTimestepLogStream(System.Guid) <a id="bosss.foundation.io.standardfsdriver.gettimesteplogstream(system.guid)"></a>
**Summary:** Returns a text reader for reading the timestep log.
**Parameter:** `sessionGuid` - The ID of the session.
**Returns:**
A text reader for the session's timestep log.


## Method: BoSSS.Foundation.IO.StandardFsDriver.FileExists(System.String) <a id="bosss.foundation.io.standardfsdriver.fileexists(system.string)"></a>
**Summary:** Tests whether a certain file exists in the database or not.
**Parameter:** `RelPath` - 
**Returns:**
true: if file exists;
false: if file not exists;


## Method: BoSSS.Foundation.IO.StandardFsDriver.ParseDirectory(System.String,System.String,System.Boolean) <a id="bosss.foundation.io.standardfsdriver.parsedirectory(system.string,system.string,system.boolean)"></a>
**Summary:** Gathers the **System.Guid**s from the names of the files and 
subdirectories in the specified 'subdir'.
**Parameter:** `subdir` - The directory to search, relative from the root path of the database.
**Parameter:** `searchpattern` - A filter to search for certain files or directories.
**Parameter:** `searchDirs` - false, to parse file names into GUIDs;
true, to parse subdirectory names.
**Returns:**
A list of unique identifiers from the file or directory names.


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetAllGridGUIDs <a id="bosss.foundation.io.standardfsdriver.getallgridguids"></a>
**Summary:** all Guid's in the 'grids' - subdirectory


## Method: BoSSS.Foundation.IO.StandardFsDriver.GetAllDataVectorGUIDs <a id="bosss.foundation.io.standardfsdriver.getalldatavectorguids"></a>
**Summary:** all guids in the 'data\headers' - subdirectoy
**Returns:**



## Method: BoSSS.Foundation.IO.StandardFsDriver.GetAllSessionGUIDs <a id="bosss.foundation.io.standardfsdriver.getallsessionguids"></a>
**Summary:** A list of the GUIDS of all sessions
**Returns:**


## Class: BoSSS.Foundation.IO.TimestepInfo <a id="bosss.foundation.io.timestepinfo"></a>

**Summary:** Information about a single time-step


## Method: BoSSS.Foundation.IO.TimestepInfo.#ctor <a id="bosss.foundation.io.timestepinfo.#ctor"></a>
**Summary:** empty constructor for serialization


## Method: BoSSS.Foundation.IO.TimestepInfo.#ctor(System.Double,BoSSS.Foundation.IO.ISessionInfo,BoSSS.Foundation.IO.TimestepNumber,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.io.timestepinfo.#ctor(system.double,bosss.foundation.io.isessioninfo,bosss.foundation.io.timestepnumber,system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Constructs information about a time-step with given
'fields'.
**Parameter:** `physTime` - The physical time represented by this object
**Parameter:** `session` - The session this time-step belongs to
**Parameter:** `TimestepNo` - The number of the represented time-step
**Parameter:** `fields` - The fields associated with this time-step.


## Method: BoSSS.Foundation.IO.TimestepInfo.#ctor(System.Guid,BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.timestepinfo.#ctor(system.guid,bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Creates a new instance of [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo)
**Parameter:** `uid` - The unique identifier of this time-step.
**Parameter:** `database` - The database this time-step is associated with.


## Method: BoSSS.Foundation.IO.TimestepInfo.FlattenHierarchy(System.Collections.Generic.List{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.io.timestepinfo.flattenhierarchy(system.collections.generic.list{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** The 'flattening' of the hierarchy is required because XDG fields
depend on Level Sets.


### Property: BoSSS.Foundation.IO.TimestepInfo.FieldInitializers <a id="bosss.foundation.io.timestepinfo.fieldinitializers"></a>
**Summary:** Initializer of the fields associated with this time-step


### Property: BoSSS.Foundation.IO.TimestepInfo.StorageID <a id="bosss.foundation.io.timestepinfo.storageid"></a>
**Summary:** Guid of the vector which contains all the data of the time-step
- empty after construction
- set through [BoSSS.Foundation.IO.DatabaseDriver.SaveTimestep(BoSSS.Foundation.IO.TimestepInfo)](#bosss.foundation.io.databasedriver.savetimestep(bosss.foundation.io.timestepinfo))


### Property: BoSSS.Foundation.IO.TimestepInfo.TimeStepNumber <a id="bosss.foundation.io.timestepinfo.timestepnumber"></a>
**Summary:** See [BoSSS.Foundation.IO.ITimestepInfo](#bosss.foundation.io.itimestepinfo)


### Property: BoSSS.Foundation.IO.TimestepInfo.Grid <a id="bosss.foundation.io.timestepinfo.grid"></a>
**Summary:** The grid associated with this time-step


### Property: BoSSS.Foundation.IO.TimestepInfo.GridID <a id="bosss.foundation.io.timestepinfo.gridid"></a>
**Summary:** ID of the grid associated with this time-step


### Property: BoSSS.Foundation.IO.TimestepInfo.Session <a id="bosss.foundation.io.timestepinfo.session"></a>
**Summary:** The associated session


### Property: BoSSS.Foundation.IO.TimestepInfo.PhysicalTime <a id="bosss.foundation.io.timestepinfo.physicaltime"></a>
**Summary:** Physical time of the time-step


### Property: BoSSS.Foundation.IO.TimestepInfo.Fields <a id="bosss.foundation.io.timestepinfo.fields"></a>
**Summary:** Contains information on the fields of this time-step.


## Method: BoSSS.Foundation.IO.TimestepInfo.Initialize(System.Runtime.Serialization.StreamingContext) <a id="bosss.foundation.io.timestepinfo.initialize(system.runtime.serialization.streamingcontext)"></a>
**Summary:** Initialization method that is used both by the constructors
and by the serialization to initialize non-persistent fields.
**Parameter:** `context` - 


## Method: BoSSS.Foundation.IO.TimestepInfo.GetFields <a id="bosss.foundation.io.timestepinfo.getfields"></a>
**Summary:** Populates the lazy list of fields.
**Returns:**



### Property: BoSSS.Foundation.IO.TimestepInfo.ID <a id="bosss.foundation.io.timestepinfo.id"></a>
**Summary:** Unique identifier of the TimestepInfo object.
- empty after construction
- set through [BoSSS.Foundation.IO.DatabaseDriver.SaveTimestep(BoSSS.Foundation.IO.TimestepInfo)](#bosss.foundation.io.databasedriver.savetimestep(bosss.foundation.io.timestepinfo))


### Property: BoSSS.Foundation.IO.TimestepInfo.CreationTime <a id="bosss.foundation.io.timestepinfo.creationtime"></a>
**Summary:** The time when the represented entity has been created.


### Property: BoSSS.Foundation.IO.TimestepInfo.WriteTime <a id="bosss.foundation.io.timestepinfo.writetime"></a>
**Summary:** The time when this object has been written to disc.


### Property: BoSSS.Foundation.IO.TimestepInfo.Name <a id="bosss.foundation.io.timestepinfo.name"></a>
**Summary:** The name of the entity.


### Property: BoSSS.Foundation.IO.TimestepInfo.Database <a id="bosss.foundation.io.timestepinfo.database"></a>
**Summary:** The database where this info object is located


## Method: BoSSS.Foundation.IO.TimestepInfo.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.timestepinfo.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies this ITimestepInfo object for storage in a different database.
**Parameter:** `targetDatabase` - The target database
**Returns:**
A copy of this ITimestepInfo object with all the same
information, except for the database field, which will be the one of the 
target database


## Method: BoSSS.Foundation.IO.TimestepInfo.ToString <a id="bosss.foundation.io.timestepinfo.tostring"></a>
**Summary:** Reports time-step number and physical time
**Returns:**


## Class: BoSSS.Foundation.IO.TimestepNumber <a id="bosss.foundation.io.timestepnumber"></a>

**Summary:** Represents a time-step number. The classical time-step index/number is
represented by [BoSSS.Foundation.IO.TimestepNumber.MajorNumber](#bosss.foundation.io.timestepnumber.majornumber). In order to handle inner
iterations (and possibly inner iterations of inner iterations, and so
on), an array of numbers can be used. For example, time-step 12 with
solver iteration 2323 and sub-iteration 369 would be time-step number
[12, 2323, 369].


### Field: BoSSS.Foundation.IO.TimestepNumber.numbers <a id="bosss.foundation.io.timestepnumber.numbers"></a>
**Summary:** The time-step numbers


### Property: BoSSS.Foundation.IO.TimestepNumber.Numbers <a id="bosss.foundation.io.timestepnumber.numbers"></a>
**Summary:** returns a clone of the internal indices


## Method: BoSSS.Foundation.IO.TimestepNumber.#ctor(System.Int32[]) <a id="bosss.foundation.io.timestepnumber.#ctor(system.int32[])"></a>
**Summary:** Constructs an immutable time-step number
**Parameter:** `numbers` - An array containing the represented time-step number on each nesting
level, i.e. 'numbers'[0] is the major time-step
number, 'numbers'[1] is one level below, and so on


## Method: BoSSS.Foundation.IO.TimestepNumber.#ctor(System.String) <a id="bosss.foundation.io.timestepnumber.#ctor(system.string)"></a>
**Summary:** Constructs an immutable time-step number from a string consisting
of dot-separated integers.
**Parameter:** `numberString` - A string consisting solely of integers separated by dots.


## Method: BoSSS.Foundation.IO.TimestepNumber.TryParse(System.String,BoSSS.Foundation.IO.TimestepNumber@) <a id="bosss.foundation.io.timestepnumber.tryparse(system.string,bosss.foundation.io.timestepnumber@)"></a>
**Summary:** Converts the given 'numberString' to its
[BoSSS.Foundation.IO.TimestepNumber](#bosss.foundation.io.timestepnumber) equivalent.
**Parameter:** `numberString` - The string, which should be converted.
**Parameter:** `Timestep` - The return value, if the conversion was successful.
**Returns:**
Indicates, whether the conversion was successful.


### Property: BoSSS.Foundation.IO.TimestepNumber.MajorNumber <a id="bosss.foundation.io.timestepnumber.majornumber"></a>
**Summary:** The major/classical time-step number


### Property: BoSSS.Foundation.IO.TimestepNumber.Item(System.Int32) <a id="bosss.foundation.io.timestepnumber.item(system.int32)"></a>
**Summary:** Allows to access the i-th component of the time-step number. The
significance of the number is sorted in decreasing order, i.e. the
significance of this[0] is larger than of this[1] and so on.


### Property: BoSSS.Foundation.IO.TimestepNumber.Length <a id="bosss.foundation.io.timestepnumber.length"></a>
**Summary:** The number of levels of this time-step number.


## Method: BoSSS.Foundation.IO.TimestepNumber.NextNumber(System.UInt32) <a id="bosss.foundation.io.timestepnumber.nextnumber(system.uint32)"></a>
**Summary:** Returns the next number if level 'level' is
advanced
**Parameter:** `level` - The time-step level to be advanced (e.g., 0 for time-step, 1 for
an iteration within a time-step, and 2 for an inner iteration
within an outer iteration within a time-step)
**Returns:**
A new time-step number where the 'level'-th number
in **Item(System.Int32)** is incremented by one.


## Method: BoSSS.Foundation.IO.TimestepNumber.NextTimestep <a id="bosss.foundation.io.timestepnumber.nexttimestep"></a>
**Summary:** Returns the number of the next time-step.
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.NextIteration <a id="bosss.foundation.io.timestepnumber.nextiteration"></a>
**Summary:** Returns the number of the next iteration within the given time-step
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.NextSubIteration <a id="bosss.foundation.io.timestepnumber.nextsubiteration"></a>
**Summary:** Returns the number of the next sub-iteration within the current
(outer) iteration of the current time-step
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.ToString <a id="bosss.foundation.io.timestepnumber.tostring"></a>
**Summary:** Appends the numbers in the order of their significance.
**Returns:**
Given a number [1, 2, 3], returns '1.2.3'


## Method: BoSSS.Foundation.IO.TimestepNumber.GetEnumerator <a id="bosss.foundation.io.timestepnumber.getenumerator"></a>
**Summary:** See **System.Collections.Generic.IEnumerable`1.GetEnumerator**
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.io.timestepnumber.system#collections#ienumerable#getenumerator"></a>
**Summary:** See **int[].GetEnumerator**
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.Equals(System.Object) <a id="bosss.foundation.io.timestepnumber.equals(system.object)"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepNumber.Equals(BoSSS.Foundation.IO.TimestepNumber)](#bosss.foundation.io.timestepnumber.equals(bosss.foundation.io.timestepnumber))
**Parameter:** `obj` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.GetHashCode <a id="bosss.foundation.io.timestepnumber.gethashcode"></a>
**Summary:** See **int[].GetHashCode**
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.Equals(BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.equals(bosss.foundation.io.timestepnumber)"></a>
**Summary:** See **int[].Equals**
**Parameter:** `other` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.CompareTo(BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.compareto(bosss.foundation.io.timestepnumber)"></a>
**Summary:** Compares two time-steps based on each individual number (cf.
[BoSSS.Foundation.IO.TimestepNumber](#bosss.foundation.io.timestepnumber)) in order of their
significance.
**Parameter:** `other` - The time-step to be compared to
**Returns:**
The result of the integer comparison of the sub-number with the
highest significance for which the result is not zero.


## Method: BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32) <a id="bosss.foundation.io.timestepnumber.compareto(system.int32)"></a>
**Summary:** Compares this time-step number to 'other' by
converting 'other' to a
[BoSSS.Foundation.IO.TimestepNumber](#bosss.foundation.io.timestepnumber) and using
[BoSSS.Foundation.IO.TimestepNumber.CompareTo(BoSSS.Foundation.IO.TimestepNumber)](#bosss.foundation.io.timestepnumber.compareto(bosss.foundation.io.timestepnumber))
**Parameter:** `other` - The time-step number to be compared
**Returns:**
See [BoSSS.Foundation.IO.TimestepNumber.CompareTo(BoSSS.Foundation.IO.TimestepNumber)](#bosss.foundation.io.timestepnumber.compareto(bosss.foundation.io.timestepnumber))


## Method: BoSSS.Foundation.IO.TimestepNumber.op_Implicit(System.Int32)~BoSSS.Foundation.IO.TimestepNumber <a id="bosss.foundation.io.timestepnumber.op_implicit(system.int32)~bosss.foundation.io.timestepnumber"></a>
**Summary:** Implicit conversion for time-steps with just a single index.
**Parameter:** `number` - The number of the time-step to be represented
**Returns:**
The number 'number' as
[BoSSS.Foundation.IO.TimestepNumber](#bosss.foundation.io.timestepnumber)


## Method: BoSSS.Foundation.IO.TimestepNumber.op_Implicit(System.String)~BoSSS.Foundation.IO.TimestepNumber <a id="bosss.foundation.io.timestepnumber.op_implicit(system.string)~bosss.foundation.io.timestepnumber"></a>
**Summary:** Implicit conversion time-steps given as strings (integers separated
by dots).
**Parameter:** `numberAsString` - A string following the pattern "1", "1.2", "1.2.3" and the like.
**Returns:**
The parsed time-step number.
**Remark:**
In principle, this shouldn't be an implicit conversion, since it
can fail. However, it greatly simplifies the usage of the command
line which should justify this code smell.


## Method: BoSSS.Foundation.IO.TimestepNumber.op_Equality(BoSSS.Foundation.IO.TimestepNumber,System.Int32) <a id="bosss.foundation.io.timestepnumber.op_equality(bosss.foundation.io.timestepnumber,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for equality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Inequality(BoSSS.Foundation.IO.TimestepNumber,System.Int32) <a id="bosss.foundation.io.timestepnumber.op_inequality(bosss.foundation.io.timestepnumber,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for inequality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Equality(System.Int32,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_equality(system.int32,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for equality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Inequality(System.Int32,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_inequality(system.int32,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for inequality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_LessThan(BoSSS.Foundation.IO.TimestepNumber,System.Int32) <a id="bosss.foundation.io.timestepnumber.op_lessthan(bosss.foundation.io.timestepnumber,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_GreaterThan(BoSSS.Foundation.IO.TimestepNumber,System.Int32) <a id="bosss.foundation.io.timestepnumber.op_greaterthan(bosss.foundation.io.timestepnumber,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_LessThan(System.Int32,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_lessthan(system.int32,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_GreaterThan(System.Int32,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_greaterthan(system.int32,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Equality(BoSSS.Foundation.IO.TimestepNumber,System.String) <a id="bosss.foundation.io.timestepnumber.op_equality(bosss.foundation.io.timestepnumber,system.string)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for equality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Inequality(BoSSS.Foundation.IO.TimestepNumber,System.String) <a id="bosss.foundation.io.timestepnumber.op_inequality(bosss.foundation.io.timestepnumber,system.string)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for inequality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Equality(System.String,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_equality(system.string,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for equality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_Inequality(System.String,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_inequality(system.string,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to check 'x'
and 'y' for inequality
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_LessThan(BoSSS.Foundation.IO.TimestepNumber,System.String) <a id="bosss.foundation.io.timestepnumber.op_lessthan(bosss.foundation.io.timestepnumber,system.string)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_GreaterThan(BoSSS.Foundation.IO.TimestepNumber,System.String) <a id="bosss.foundation.io.timestepnumber.op_greaterthan(bosss.foundation.io.timestepnumber,system.string)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_LessThan(System.String,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_lessthan(system.string,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepNumber.op_GreaterThan(System.String,BoSSS.Foundation.IO.TimestepNumber) <a id="bosss.foundation.io.timestepnumber.op_greaterthan(system.string,bosss.foundation.io.timestepnumber)"></a>
**Summary:** Uses [BoSSS.Foundation.IO.TimestepNumber.CompareTo(System.Int32)](#bosss.foundation.io.timestepnumber.compareto(system.int32)) to compare 'x'
and 'y'.
**Parameter:** `x` - 
**Parameter:** `y` - 
**Returns:**


## Class: BoSSS.Foundation.IO.TimestepProxy <a id="bosss.foundation.io.timestepproxy"></a>

**Summary:** A proxy for [BoSSS.Foundation.IO.TimestepInfo](#bosss.foundation.io.timestepinfo) objects that allows for lazy
loading


### Field: BoSSS.Foundation.IO.TimestepProxy.realTimestepInfo <a id="bosss.foundation.io.timestepproxy.realtimestepinfo"></a>
**Summary:** The real time-step reflected by this object


## Method: BoSSS.Foundation.IO.TimestepProxy.#ctor(System.Guid,BoSSS.Foundation.IO.ISessionInfo) <a id="bosss.foundation.io.timestepproxy.#ctor(system.guid,bosss.foundation.io.isessioninfo)"></a>
**Summary:** Constructs a proxy for the time-step with the given
'timestepGuid' within the given
'session'.
**Parameter:** `timestepGuid` - 
**Parameter:** `session` - 


## Method: BoSSS.Foundation.IO.TimestepProxy.ToString <a id="bosss.foundation.io.timestepproxy.tostring"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.ToString](#bosss.foundation.io.timestepinfo.tostring)
**Returns:**



### Property: BoSSS.Foundation.IO.TimestepProxy.TimeStepNumber <a id="bosss.foundation.io.timestepproxy.timestepnumber"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.TimeStepNumber](#bosss.foundation.io.timestepinfo.timestepnumber)


### Property: BoSSS.Foundation.IO.TimestepProxy.Grid <a id="bosss.foundation.io.timestepproxy.grid"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.Grid](#bosss.foundation.io.timestepinfo.grid)


### Property: BoSSS.Foundation.IO.TimestepProxy.Session <a id="bosss.foundation.io.timestepproxy.session"></a>
**Summary:** The associated session


### Property: BoSSS.Foundation.IO.TimestepProxy.GridID <a id="bosss.foundation.io.timestepproxy.gridid"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.GridID](#bosss.foundation.io.timestepinfo.gridid)


### Property: BoSSS.Foundation.IO.TimestepProxy.PhysicalTime <a id="bosss.foundation.io.timestepproxy.physicaltime"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.PhysicalTime](#bosss.foundation.io.timestepinfo.physicaltime)


### Property: BoSSS.Foundation.IO.TimestepProxy.StorageID <a id="bosss.foundation.io.timestepproxy.storageid"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.StorageID](#bosss.foundation.io.timestepinfo.storageid)


### Property: BoSSS.Foundation.IO.TimestepProxy.FieldInitializers <a id="bosss.foundation.io.timestepproxy.fieldinitializers"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.FieldInitializers](#bosss.foundation.io.timestepinfo.fieldinitializers)


### Property: BoSSS.Foundation.IO.TimestepProxy.Fields <a id="bosss.foundation.io.timestepproxy.fields"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.Fields](#bosss.foundation.io.timestepinfo.fields)


### Property: BoSSS.Foundation.IO.TimestepProxy.ID <a id="bosss.foundation.io.timestepproxy.id"></a>
**Summary:** The unique ID of the time-step


### Property: BoSSS.Foundation.IO.TimestepProxy.CreationTime <a id="bosss.foundation.io.timestepproxy.creationtime"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.CreationTime](#bosss.foundation.io.timestepinfo.creationtime)


### Property: BoSSS.Foundation.IO.TimestepProxy.WriteTime <a id="bosss.foundation.io.timestepproxy.writetime"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.WriteTime](#bosss.foundation.io.timestepinfo.writetime)
**Remark:**
Note that retrieving this value does not cause deserialization of
[BoSSS.Foundation.IO.TimestepProxy.realTimestepInfo](#bosss.foundation.io.timestepproxy.realtimestepinfo), while setting this value obviously
has to do so.


### Property: BoSSS.Foundation.IO.TimestepProxy.Name <a id="bosss.foundation.io.timestepproxy.name"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.Name](#bosss.foundation.io.timestepinfo.name)


### Property: BoSSS.Foundation.IO.TimestepProxy.Database <a id="bosss.foundation.io.timestepproxy.database"></a>
**Summary:** The associated database


## Method: BoSSS.Foundation.IO.TimestepProxy.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.io.timestepproxy.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** See [BoSSS.Foundation.IO.TimestepInfo.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo)](#bosss.foundation.io.timestepinfo.copyfor(bosss.foundation.io.idatabaseinfo))
**Parameter:** `targetDatabase` - 
**Returns:**



## Method: BoSSS.Foundation.IO.TimestepProxy.GetInternal <a id="bosss.foundation.io.timestepproxy.getinternal"></a>
**Summary:** Returns the object behind the proxy

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGrid <a id="bosss.foundation.grid.aggregation.aggregationgrid"></a>

**Summary:** A grid, which is composed through the aggregation of cells in a parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgrid.parentgrid)).


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.#ctor(BoSSS.Foundation.Grid.IGrid,System.Int32[][],System.Int64[]) <a id="bosss.foundation.grid.aggregation.aggregationgrid.#ctor(bosss.foundation.grid.igrid,system.int32[][],system.int64[])"></a>
**Summary:** Constructor.
**Parameter:** `pGrid` - Parent grid.
**Parameter:** `AggregationCells` -
Coarse cells which build up the fine cells.
- 1st index: coarse (i.e. this) grid cell index
- 2nd index: enumeration
- content: local cell index into the parent grid 'pGrid'.
**Parameter:** `AggregationCellGids` - GlobalID's for each of the 'AggregationCells';  
Optional, can be null - in this case, GlobalID's are chosen automatically;
If not null, length must be equal to 1st length of 'AggregationCells'.

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCell <a id="bosss.foundation.grid.aggregation.aggregationgrid.aggcell"></a>

**Summary:** Structure to store one Aggregation cell


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCell.GlobalID <a id="bosss.foundation.grid.aggregation.aggregationgrid.aggcell.globalid"></a>
**Summary:** ID of this cell


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCell.PartGlobalId <a id="bosss.foundation.grid.aggregation.aggregationgrid.aggcell.partglobalid"></a>
**Summary:** ID's of cells in the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgrid.parentgrid)) which make this aggregate cell.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCellStorageGuid <a id="bosss.foundation.grid.aggregation.aggregationgrid.aggcellstorageguid"></a>
**Summary:** returns the Guid of the vector in which
**BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCells** is stored in the database. (see [BoSSS.Foundation.IO.DatabaseDriver.SaveGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo)](#bosss.foundation.io.databasedriver.savegrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)));


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.m_StorageGuid <a id="bosss.foundation.grid.aggregation.aggregationgrid.m_storageguid"></a>
**Summary:** see [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.AggCellStorageGuid](#bosss.foundation.grid.aggregation.aggregationgrid.aggcellstorageguid).


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Description <a id="bosss.foundation.grid.aggregation.aggregationgrid.description"></a>
**Summary:** a string to store some user-information about the grid;


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGrid <a id="bosss.foundation.grid.aggregation.aggregationgrid.parentgrid"></a>
**Summary:** parent grid object


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.RootGrid <a id="bosss.foundation.grid.aggregation.aggregationgrid.rootgrid"></a>
**Summary:** For a sequence of aggregation grids, returns the root.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGridID <a id="bosss.foundation.grid.aggregation.aggregationgrid.parentgridid"></a>
**Summary:** Guid ([BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id) of parent grid [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgrid.parentgrid)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.SpatialDimension <a id="bosss.foundation.grid.aggregation.aggregationgrid.spatialdimension"></a>
**Summary:** Either 1 for 1D, 2 for 2D or 3 for 3D.


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.m_GridGuid <a id="bosss.foundation.grid.aggregation.aggregationgrid.m_gridguid"></a>
**Summary:** see [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ID](#bosss.foundation.grid.aggregation.aggregationgrid.id);


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ID <a id="bosss.foundation.grid.aggregation.aggregationgrid.id"></a>
**Summary:** Guid/Identification of this grid object in the database [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Database](#bosss.foundation.grid.aggregation.aggregationgrid.database)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Name <a id="bosss.foundation.grid.aggregation.aggregationgrid.name"></a>
**Summary:** grid name: implementation of [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Name](#bosss.foundation.io.idatabaseentityinfo`1.name)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.NumberOfCells <a id="bosss.foundation.grid.aggregation.aggregationgrid.numberofcells"></a>
**Summary:** number of cells in the grid: implementation of [BoSSS.Foundation.IO.IGridInfo.NumberOfCells](#bosss.foundation.io.igridinfo.numberofcells)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Database <a id="bosss.foundation.grid.aggregation.aggregationgrid.database"></a>
**Summary:** Database which de-serialized this grid; implementation of [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Database](#bosss.foundation.io.idatabaseentityinfo`1.database)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.iGridData <a id="bosss.foundation.grid.aggregation.aggregationgrid.igriddata"></a>
**Summary:** returns the grid metrics, of type [BoSSS.Foundation.Grid.Aggregation.AggregationGridData](#bosss.foundation.grid.aggregation.aggregationgriddata)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.GridData <a id="bosss.foundation.grid.aggregation.aggregationgrid.griddata"></a>
**Summary:** returns the grid metrics, of type [BoSSS.Foundation.Grid.Aggregation.AggregationGridData](#bosss.foundation.grid.aggregation.aggregationgriddata)


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.InvalidateGridData <a id="bosss.foundation.grid.aggregation.aggregationgrid.invalidategriddata"></a>
**Summary:** Releases the object cached in [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.iGridData](#bosss.foundation.grid.aggregation.aggregationgrid.igriddata); this is necessary if 
the grid object was changed somehow.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.MyRank <a id="bosss.foundation.grid.aggregation.aggregationgrid.myrank"></a>
**Summary:** MPI process rank (within world communicator)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Size <a id="bosss.foundation.grid.aggregation.aggregationgrid.size"></a>
**Summary:** MPI world communicator size


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.CellPartitioning <a id="bosss.foundation.grid.aggregation.aggregationgrid.cellpartitioning"></a>
**Summary:** Gets the partition of cells over the MPI processes;


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.Equals(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.grid.aggregation.aggregationgrid.equals(bosss.foundation.io.igridinfo)"></a>
**Summary:** Equality.


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.CurrentGlobalIdPermutation <a id="bosss.foundation.grid.aggregation.aggregationgrid.currentglobalidpermutation"></a>
**Summary:** Returns the current GlobalID - permutation of this grid,
i.e. a mapping from the global index to the global ID.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.PeriodicTrafo <a id="bosss.foundation.grid.aggregation.aggregationgrid.periodictrafo"></a>
**Summary:** list of transformations which describe how some edges should be
transformed to other edges;
**Remark:**
indices into this list are the
[BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags](#bosss.foundation.grid.igeometricaledgedata.edgetags) minus [BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag)


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ToString <a id="bosss.foundation.grid.aggregation.aggregationgrid.tostring"></a>
**Summary:** Creates a human-readable string representation of the grid info object.
**Returns:**
A string summary of the grid.

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData <a id="bosss.foundation.grid.aggregation.aggregationgriddata"></a>


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid"></a>
**Summary:** The grid from which this was coarsened.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.MpiRank <a id="bosss.foundation.grid.aggregation.aggregationgriddata.mpirank"></a>
**Summary:** MPI process rank (within world communicator)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.MpiSize <a id="bosss.foundation.grid.aggregation.aggregationgriddata.mpisize"></a>
**Summary:** MPI world communicator size


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.AncestorGrid <a id="bosss.foundation.grid.aggregation.aggregationgriddata.ancestorgrid"></a>
**Summary:** The ancestor grid, from which the aggregation sequence was derived.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.MgLevel <a id="bosss.foundation.grid.aggregation.aggregationgriddata.mglevel"></a>
**Summary:** Multi-grid level index.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.SpatialDimension <a id="bosss.foundation.grid.aggregation.aggregationgriddata.spatialdimension"></a>
**Summary:** The spatial dimension, induced from the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid)).


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.CellPartitioning <a id="bosss.foundation.grid.aggregation.aggregationgriddata.cellpartitioning"></a>
**Summary:** Gets the partitioning of cells over the MPI processes.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.CurrentGlobalIdPermutation <a id="bosss.foundation.grid.aggregation.aggregationgriddata.currentglobalidpermutation"></a>
**Summary:** The global ID for each cell


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.#ctor(BoSSS.Foundation.Grid.Aggregation.AggregationGrid,System.Int32[][]) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.#ctor(bosss.foundation.grid.aggregation.aggregationgrid,system.int32[][])"></a>
**Summary:** Constructor.
**Parameter:** `aggregationGrid` - Aggregation grid.
**Parameter:** `AggregationCells` -
Coarse cells which build up the fine cells.
- 1st index: coarse (i.e. this) grid cell index
- 2nd index: enumeration
- content: local cell index into the parent grid [BoSSS.Foundation.Grid.Aggregation.AggregationGrid.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgrid.parentgrid).


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32[][]) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.#ctor(bosss.foundation.grid.igriddata,system.int32[][])"></a>
**Summary:** Constructor.
**Parameter:** `pGrid` - Parent grid.
**Parameter:** `AggregationCells` -
Coarse cells which build up the fine cells.
- 1st index: coarse (i.e. this) grid cell index
- 2nd index: enumeration
- content: local cell index into the parent grid 'pGrid'.

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.EdgeTmp <a id="bosss.foundation.grid.aggregation.aggregationgriddata.edgetmp"></a>

**Summary:** helper data structure


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.jCellCoarse2jCellFine <a id="bosss.foundation.grid.aggregation.aggregationgriddata.jcellcoarse2jcellfine"></a>
**Summary:** Mapping from parent grid cell index to cell index within this aggregation grid.
- index: local cell index within this aggregation grid.
- content: local cell index within the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid))


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.jCellFine2jCellCoarse <a id="bosss.foundation.grid.aggregation.aggregationgriddata.jcellfine2jcellcoarse"></a>
**Summary:** Mapping from parent grid cell index to cell index within this aggregation grid.
- index: local cell index within the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid))
- content: local cell index within this aggregation grid.


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.DefineCellParts <a id="bosss.foundation.grid.aggregation.aggregationgriddata.definecellparts"></a>
**Summary:** Sets up the decomposition of the aggregate cell into elementary parts, which can be mapped to reference elements.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GridID <a id="bosss.foundation.grid.aggregation.aggregationgriddata.gridid"></a>
**Summary:** Identification of the grid in the BoSSS database, 
equal to the [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id).


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Grid <a id="bosss.foundation.grid.aggregation.aggregationgriddata.grid"></a>
**Summary:** The grid for which information is provided


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.MultigridSequence <a id="bosss.foundation.grid.aggregation.aggregationgriddata.multigridsequence"></a>
**Summary:** returns the remaining multigrid hierarchy


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Invalidate <a id="bosss.foundation.grid.aggregation.aggregationgriddata.invalidate"></a>
**Summary:** Clears (lots of) internal references for this object, to make sure that any attempt to use it leads to an exception.


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.IsAlive <a id="bosss.foundation.grid.aggregation.aggregationgriddata.isalive"></a>
**Summary:** indicates that [BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Invalidate](#bosss.foundation.grid.aggregation.aggregationgriddata.invalidate) has been called

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata"></a>


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.Compute_OrthonormalizationTrafo(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata.compute_orthonormalizationtrafo(system.int32,system.int32,system.int32)"></a>
**Parameter:** `j0` - 
**Parameter:** `Len` - 
**Parameter:** `Degree` - 
**Returns:**



### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.Injectors <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata.injectors"></a>
**Summary:** injectors to upper level
- outer array index: aggregation cell index
For each multidimensional array:
- 1st index: enumeration of parts of upper level
- 2nd index: row index
- 3rd index: column index


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.InjectorsBaseReady <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata.injectorsbaseready"></a>
**Summary:** Defines which entries of **BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.InjectorsBase** contain valid values.
- index: correlates with 1st index of **BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.InjectorsBase**


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.BuildInjector_Lv1(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][]) <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata.buildinjector_lv1(bosss.foundation.basis,system.int32,ilpsp.multidimensionalarray,system.boolean[],system.int32,system.int32[][],system.int32[][])"></a>
**Summary:** computes the injector for multigrid level 1


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData._BasisData.BuildInjector_Lv2andup(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][]) <a id="bosss.foundation.grid.aggregation.aggregationgriddata._basisdata.buildinjector_lv2andup(bosss.foundation.basis,system.int32,ilpsp.multidimensionalarray,system.boolean[],system.int32,system.int32[][],system.int32[][])"></a>
**Summary:** computes the injector for multigrid level 2 and higher

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomCellData <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomcelldata"></a>

**Summary:** Just a wrapper/proxy around the geometrical cell data ([BoSSS.Foundation.Grid.IGridData.iGeomCells](#bosss.foundation.grid.igriddata.igeomcells)) 
of the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid)).


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomCellData.IsCellAffineLinear(System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomcelldata.iscellaffinelinear(system.int32)"></a>
**Summary:** Always false for aggregation grids, since they require the orthonormalization ([BoSSS.Foundation.Grid.BasisData.OrthonormalizationTrafo](#bosss.foundation.grid.basisdata.orthonormalizationtrafo)) in each geometrical cell.
**Parameter:** `j` - Geometric cell index
**Returns:**
always false


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomCellData.GetCenter(System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomcelldata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.LogicalCellData <a id="bosss.foundation.grid.aggregation.aggregationgriddata.logicalcelldata"></a>


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.LogicalCellData.GetCenter(System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.logicalcelldata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomEdgeData <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomedgedata"></a>

**Summary:** Just a wrapper/proxy around the geometrical edge data ([BoSSS.Foundation.Grid.IGridData.iGeomEdges](#bosss.foundation.grid.igriddata.igeomedges)) 
of the parent grid ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData.ParentGrid](#bosss.foundation.grid.aggregation.aggregationgriddata.parentgrid)).


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomEdgeData.IsEdgeAffineLinear(System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomedgedata.isedgeaffinelinear(system.int32)"></a>
**Summary:** Always false for aggregation grids, since they require the orthonormalization ([BoSSS.Foundation.Grid.BasisData.OrthonormalizationTrafo](#bosss.foundation.grid.basisdata.orthonormalizationtrafo)) in each geometrical cell.
**Parameter:** `e` - Geometric edge index
**Returns:**
always false


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.GeomEdgeData.GetCenter(System.Int32) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.geomedgedata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity for the edge


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.m_Parallel <a id="bosss.foundation.grid.aggregation.aggregationgriddata.m_parallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization](#bosss.foundation.grid.aggregation.aggregationgriddata.parallelization)


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.iParallel <a id="bosss.foundation.grid.aggregation.aggregationgriddata.iparallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization](#bosss.foundation.grid.aggregation.aggregationgriddata.parallelization)

## Class: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization"></a>

**Summary:** Contains information for MPI parallelization.


### Field: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.m_owner <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.m_owner"></a>
**Summary:** pointer to owner object


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.Global2LocalIdx <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.global2localidx"></a>
**Summary:** Conversion of global cell indices to local cell indices, 
i.e. the inverse of [BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.globalindicesexternalcells). 
- keys: global indices of external/ghost cells 
- values: local indices of external/ghost cells


## Method: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.GetLocalCellIndex(System.Int64) <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.getlocalcellindex(system.int64)"></a>
**Summary:** Conversion of global cell indices to local cell indices
**Parameter:** `globalCellIndex` - 
**Remark:**
The conversion can only be done for cells which are stored on
this MPI process;


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.GlobalIndicesExternalCells <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.globalindicesexternalcells"></a>
**Summary:** Global indices of external cells (local indices j in the range
[BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells) <= j < [BoSSS.Foundation.Grid.ILogicalCellData.Count](#bosss.foundation.grid.ilogicalcelldata.count)); Note that there is an index
offset, so the entry at index 0 is the global index of cell at
local index [BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells);
See also [BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.globalindicesexternalcells);


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.SendCommLists <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.sendcommlists"></a>
**Summary:** local cell indices (only border cells) which must be send to
other processors; for each processor, the communication list is
stored in ascending order.
**Remark:**
- 1st index: target processor; if the 'p'-th entry is null, there
is no communication with processor 'p'
- 2nd index: enumeration;
- content: local cell index


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.RcvCommListsInsertIndex <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.rcvcommlistsinsertindex"></a>
**Summary:** for each process, a local cell index at which items received
from other processes should be inserted;
- index: MPI process rank of process from which data is received;
- content: local cell index, where the received eitems should be inserted.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.RcvCommListsNoOfItems <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.rcvcommlistsnoofitems"></a>
**Summary:** for each process, the number of cells that are received from
this process
index: MPI process rank of process from which data is received;


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.ProcessesToSendTo <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.processestosendto"></a>
**Summary:** List of processes (MPI ranks) which receive data from this process.
index: enumeration.


### Property: BoSSS.Foundation.Grid.Aggregation.AggregationGridData.Parallelization.ProcessesToReceiveFrom <a id="bosss.foundation.grid.aggregation.aggregationgriddata.parallelization.processestoreceivefrom"></a>
**Summary:** List of processes (MPI ranks) which send data to this process.

## Class: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms <a id="bosss.foundation.grid.aggregation.coarseningalgorithms"></a>

**Summary:** Creation of multigrid hierarchies


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.CreateSequence(BoSSS.Foundation.Grid.IGrid,System.Int32) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.createsequence(bosss.foundation.grid.igrid,system.int32)"></a>
**Summary:** Creates a sequence of aggregated grids, suitable for a multigrid algorithm
**Parameter:** `Grid` - original grid
**Parameter:** `MaxDepth` - maximum number of refinements
**Returns:**



## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.CreateSequence(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.createsequence(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Creates a sequence of aggregated grids, suitable for a multigrid algorithm
**Parameter:** `GridDat` - original grid
**Parameter:** `MaxDepth` - maximum number of refinements
**Returns:**



## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.ZeroAggregation(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.zeroaggregation(bosss.foundation.grid.igriddata)"></a>
**Summary:** creates an initial aggregated grid which is in fact equivalent to 'gd'


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.ZeroAggregation(BoSSS.Foundation.Grid.IGrid) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.zeroaggregation(bosss.foundation.grid.igrid)"></a>
**Summary:** creates an initial aggregated grid which is in fact equivalent to 'g'


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.Coarsen(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.coarsen(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** coarsens level 'ag' (aggregation of grid data objects)
**Parameter:** `ag` - input grid, which should be aggregated
**Parameter:** `AggCellCount` - desired number of parts for each aggregate cell


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.Coarsen(BoSSS.Foundation.Grid.IGrid,System.Int32) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.coarsen(bosss.foundation.grid.igrid,system.int32)"></a>
**Summary:** coarsens level 'ag' (aggregation of grid objects)
**Parameter:** `ag` - input grid, which should be aggregated
**Parameter:** `AggCellCount` - desired number of parts for each aggregate cell


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.AggregationKernel(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.aggregationkernel(bosss.foundation.grid.igriddata,system.int32)"></a>
**Parameter:** `ag` - mesh which should be coarsened
**Parameter:** `AggCellCount` - number of cells from the grid 'ag' that should be aggregated in each aggregate cell
**Returns:**
- 1st index: local cell mesh of the aggregate mesh
- 2nd index: enumeration of cell parts


## Method: BoSSS.Foundation.Grid.Aggregation.CoarseningAlgorithms.ColorDGField(BoSSS.Foundation.Grid.Aggregation.AggregationGridData,BoSSS.Foundation.DGField) <a id="bosss.foundation.grid.aggregation.coarseningalgorithms.colordgfield(bosss.foundation.grid.aggregation.aggregationgriddata,bosss.foundation.dgfield)"></a>
**Summary:** assigns the cell index of the aggregated cell j to all (fine) grid cells that 
the aggregated cell j consists of.

## Class: BoSSS.Foundation.Grid.BasisData <a id="bosss.foundation.grid.basisdata"></a>

**Summary:** Common, heavy-weighted data (e.g. evaluation caches, orthonormalization trafo, etc.) for all [BoSSS.Foundation.Basis](#bosss.foundation.basis)-objects.


### Field: BoSSS.Foundation.Grid.BasisData.m_Owner <a id="bosss.foundation.grid.basisdata.m_owner"></a>
**Summary:** reference to owner object


## Method: BoSSS.Foundation.Grid.BasisData.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.basisdata.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.Grid.BasisData.GetNdim(System.Int32,System.Int32,System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.grid.basisdata.getndim(system.int32,system.int32,system.int32,bosss.foundation.nodeset)"></a>
**Summary:** Number of degrees-of-freedom for polynomial degree 'Degree'.
**Parameter:** `j0` - 
**Parameter:** `Len` - 
**Parameter:** `Degree` - 
**Parameter:** `Ns` - 
**Returns:**



### Property: BoSSS.Foundation.Grid.BasisData.Scaling <a id="bosss.foundation.grid.basisdata.scaling"></a>
**Summary:** For a cell Kj, with an affine-linear
transformation to the reference cell, the basis polynomials are
scaled by the factor [BoSSS.Foundation.Grid.BasisData.Scaling](#bosss.foundation.grid.basisdata.scaling)[j]
in order to preserve orthonormality under the transformation.
**Remark:**
index: cell index.


## Method: BoSSS.Foundation.Grid.BasisData.GetOrthonormalPolynomials(System.Int32) <a id="bosss.foundation.grid.basisdata.getorthonormalpolynomials(system.int32)"></a>
**Summary:** Returns the orthonormal approximation polynomials $\phi_n$ up to a specific degree.
**Returns:**
A polynomial list for each involved reference element
- index: reference element, correlates with [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)


## Method: BoSSS.Foundation.Grid.BasisData.GetOrthonormalPolynomials1stDeriv(System.Int32) <a id="bosss.foundation.grid.basisdata.getorthonormalpolynomials1stderiv(system.int32)"></a>
**Summary:** Returns the 1st derivatives of the orthonormal approximation polynomials, 
i.e. $\nabla_{\vec{\xi}} \phi_n$ up to a specific degree.
**Returns:**
- 1st index: reference element, correlates with [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)
- 2nd index: spatial direction of derivative


## Method: BoSSS.Foundation.Grid.BasisData.GetOrthonormalPolynomials2ndDeriv(System.Int32) <a id="bosss.foundation.grid.basisdata.getorthonormalpolynomials2ndderiv(system.int32)"></a>
**Summary:** Returns the 2nd derivatives of the orthonormal approximation polynomials, 
i.e. $\nabla_{\vec{\xi}} \phi_n$ up to a specific degree.
**Returns:**
- 1st index: reference element, correlates with [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)
- 2nd index: spatial direction of first derivative
- 3rd index: spatial direction of second derivative


### Property: BoSSS.Foundation.Grid.BasisData.OrthonormalizationTrafo <a id="bosss.foundation.grid.basisdata.orthonormalizationtrafo"></a>
**Summary:** Change of basis to provide orthonormality in physical coordinates.
The orthonormalization transformation depends on cell and polynomial degree of the basis,
but is independent from the used node set.


## Method: BoSSS.Foundation.Grid.BasisData.Compute_OrthonormalizationTrafo(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.basisdata.compute_orthonormalizationtrafo(system.int32,system.int32,system.int32)"></a>
**Summary:** Returns the required orthonormalization transformation (for reference to physical elements) for each cell


### Property: BoSSS.Foundation.Grid.BasisData.BasisValues <a id="bosss.foundation.grid.basisdata.basisvalues"></a>
**Summary:** Cached evaluation of basis polynomials $\phi_n$ in reference space.


## Method: BoSSS.Foundation.Grid.BasisData.EvaluateBasis(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.grid.basisdata.evaluatebasis(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Used by the [BoSSS.Foundation.Grid.BasisData.BasisValues](#bosss.foundation.grid.basisdata.basisvalues)-cache.


### Property: BoSSS.Foundation.Grid.BasisData.BasisGradientValues <a id="bosss.foundation.grid.basisdata.basisgradientvalues"></a>
**Summary:** Cached evaluation of basis polynomials gradients $\nabla_{\vec{xi}} \phi_n$ in reference space.


## Method: BoSSS.Foundation.Grid.BasisData.EvaluateBasisGradient(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.grid.basisdata.evaluatebasisgradient(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Used by the [BoSSS.Foundation.Grid.BasisData.BasisGradientValues](#bosss.foundation.grid.basisdata.basisgradientvalues)-cache.


### Property: BoSSS.Foundation.Grid.BasisData.BasisHessianValues <a id="bosss.foundation.grid.basisdata.basishessianvalues"></a>
**Summary:** Cached evaluation of basis polynomials Hessian $\partial_{\vec{xi}}^2 \phi_n$ in reference space.


## Method: BoSSS.Foundation.Grid.BasisData.EvaluateBasisHessian(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.grid.basisdata.evaluatebasishessian(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Used by the [BoSSS.Foundation.Grid.BasisData.BasisHessianValues](#bosss.foundation.grid.basisdata.basishessianvalues)-cache.


### Property: BoSSS.Foundation.Grid.BasisData.CellBasisValues <a id="bosss.foundation.grid.basisdata.cellbasisvalues"></a>
**Summary:** Values of polynomials in cells,  $\phi_{j n}$


### Property: BoSSS.Foundation.Grid.BasisData.CellBasisGradientValues <a id="bosss.foundation.grid.basisdata.cellbasisgradientvalues"></a>
**Summary:** Values of polynomials gradients in cells, $\nabla_{\vec{x}} \phi_{j n}$


### Property: BoSSS.Foundation.Grid.BasisData.CellBasisHessianValues <a id="bosss.foundation.grid.basisdata.cellbasishessianvalues"></a>
**Summary:** Values of polynomials gradients in cells, $\partial^2_{\vec{x}} \phi_{j n}$


### Property: BoSSS.Foundation.Grid.BasisData.EdgeEval <a id="bosss.foundation.grid.basisdata.edgeeval"></a>
**Summary:** Evaluation of the reference basis values $\phi_n$ for edges.


### Property: BoSSS.Foundation.Grid.BasisData.EdgeGradientEval <a id="bosss.foundation.grid.basisdata.edgegradienteval"></a>
**Summary:** Evaluation of the reference basis gradient values $\nabla_{\vec{xi}} \phi_n$ for edges.

## Class: BoSSS.Foundation.Grid.Classic.Element <a id="bosss.foundation.grid.classic.element"></a>

**Summary:** Base class for elements for the physical domain.


### Field: BoSSS.Foundation.Grid.Classic.Element.GlobalID <a id="bosss.foundation.grid.classic.element.globalid"></a>
**Summary:** Global identification number of the element,
which remains constant under re-ordering.


### Field: BoSSS.Foundation.Grid.Classic.Element.TransformationParams <a id="bosss.foundation.grid.classic.element.transformationparams"></a>
**Summary:** Parameters for the transformation from reference to physical domain.
**Remark:**
1st index: interpolation node in physical coordinates


2nd index: spatial direction (0 is x, 1 is y, ...)


### Field: BoSSS.Foundation.Grid.Classic.Element.NodeIndices <a id="bosss.foundation.grid.classic.element.nodeindices"></a>
**Summary:** Global Node indices: usually, the connectivity information of cells
is derived from this information. Alternatively, cell connectivity
may be specified by [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags).


### Field: BoSSS.Foundation.Grid.Classic.Element.Type <a id="bosss.foundation.grid.classic.element.type"></a>
**Summary:** Element/Cell type;


## Method: BoSSS.Foundation.Grid.Classic.Element.ToString <a id="bosss.foundation.grid.classic.element.tostring"></a>

## Class: BoSSS.Foundation.Grid.Classic.Cell <a id="bosss.foundation.grid.classic.cell"></a>

**Summary:** Represents one cell in physical domain


### Field: BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags <a id="bosss.foundation.grid.classic.cell.cellfacetags"></a>
**Summary:** Alternative method to describe cell neighborship, can be used
instead of [BoSSS.Foundation.Grid.Classic.Element.NodeIndices](#bosss.foundation.grid.classic.element.nodeindices).
Mandatory
to specify periodic boundary conditions and connection between
cells with hanging nodes. Should be null, or of length 0 if not
used.


## Method: BoSSS.Foundation.Grid.Classic.Cell.Clone <a id="bosss.foundation.grid.classic.cell.clone"></a>
**Summary:** clone


### Field: BoSSS.Foundation.Grid.Classic.Cell.ParentCell <a id="bosss.foundation.grid.classic.cell.parentcell"></a>
**Summary:** If this cell was created by adaptive mesh refinement, 
the parent cell from which this cell was created from. This member is required to be able to coarsen the mesh again.


### Field: BoSSS.Foundation.Grid.Classic.Cell.RefinementLevel <a id="bosss.foundation.grid.classic.cell.refinementlevel"></a>
**Summary:** How often the cell was refined.


### Field: BoSSS.Foundation.Grid.Classic.Cell.CoarseningClusterID <a id="bosss.foundation.grid.classic.cell.coarseningclusterid"></a>
**Summary:** If this cell was created by adaptive mesh refinement, 
the siblings in the coarsening cluster can be identified by this ID/Token.


### Field: BoSSS.Foundation.Grid.Classic.Cell.CoarseningClusterSize <a id="bosss.foundation.grid.classic.cell.coarseningclustersize"></a>
**Summary:** If this cell was created by adaptive mesh refinement, 
the number of siblings in the coarsening cluster.


### Field: BoSSS.Foundation.Grid.Classic.Cell.CoarseningLeafIndex <a id="bosss.foundation.grid.classic.cell.coarseningleafindex"></a>
**Summary:** If this cell was created by adaptive mesh refinement, 
the index within the coarsening cluster.


## Method: BoSSS.Foundation.Grid.Classic.Cell.ToString <a id="bosss.foundation.grid.classic.cell.tostring"></a>

## Class: BoSSS.Foundation.Grid.Classic.BCElement <a id="bosss.foundation.grid.classic.bcelement"></a>

**Summary:** Represents a boundary element of the physical domain (i.e., an element
where boundary conditions are applied).


### Field: BoSSS.Foundation.Grid.Classic.BCElement.EdgeTag <a id="bosss.foundation.grid.classic.bcelement.edgetag"></a>
**Summary:** The tag of this element


### Field: BoSSS.Foundation.Grid.Classic.BCElement.NeighCell_GlobalIDs <a id="bosss.foundation.grid.classic.bcelement.neighcell_globalids"></a>
**Summary:** Global ID's of neighboring cells.


### Field: BoSSS.Foundation.Grid.Classic.BCElement.Conformal <a id="bosss.foundation.grid.classic.bcelement.conformal"></a>
**Summary:** Bool indicating whether this a conformal element.


## Method: BoSSS.Foundation.Grid.Classic.BCElement.Clone <a id="bosss.foundation.grid.classic.bcelement.clone"></a>
**Summary:** clone

## Class: BoSSS.Foundation.Grid.Classic.CellFaceTag <a id="bosss.foundation.grid.classic.cellfacetag"></a>

**Summary:** carries information which is 'tagged' onto the faces of cells


### Property: BoSSS.Foundation.Grid.Classic.CellFaceTag.EdgeTag <a id="bosss.foundation.grid.classic.cellfacetag.edgetag"></a>
**Summary:** Tags (i.e. numbers) which define information for edge (connection
between cells);
**Remark:**
In BoSSS, different regions of the computational boundary (e.g.
inlet, wall, moving wall,...) are identified by numbers (edge tags)
which are assigned to the grid edges on the boundary. These numbers
are small, in the region of 1 (including) to
[BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag);
in total, there are three different ranges of edge tags:


_Internal edges_:
A value 0 indicates an internal edge (this information is
redundant, however);


_Boundaries_:
Values between 1 (including) and
[BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag) (excluding)
are reserved for user defined boundary conditions (by using
border-edge-flux functions);


_Periodic boundaries_:
Values between [BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag)
(including) and 255 (including) are reserved for periodic
boundary conditions (which are, in contrast to user defined
boundary conditions, implemented on a lower level by
[BoSSS.Foundation.Grid.Classic.GridCommons.GetCellNeighbourship(System.Boolean,System.Boolean)](#bosss.foundation.grid.classic.gridcommons.getcellneighbourship(system.boolean,system.boolean)) and the
[BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo](#bosss.foundation.grid.classic.gridcommons.periodictrafo)-transformations. So,
e.g. a tag of
[BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag) + 3 indicates
a periodic boundary condition with transformation
[BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo](#bosss.foundation.grid.classic.gridcommons.periodictrafo)[3].


This entry may be null if the cell has only internal edges, i.e.
all edge tags are 0.


### Property: BoSSS.Foundation.Grid.Classic.CellFaceTag.PeriodicInverse <a id="bosss.foundation.grid.classic.cellfacetag.periodicinverse"></a>
**Summary:** Indicates on which 'side' of the periodic transformation this cell
resides. If false, resides on the side associated with the original
periodic transformation. If true, resides on the side associated
with the inverse of this transformation.


### Property: BoSSS.Foundation.Grid.Classic.CellFaceTag.IsPeriodicNeighbour <a id="bosss.foundation.grid.classic.cellfacetag.isperiodicneighbour"></a>
**Summary:** true, if the neighbor cell is reached by a periodic boundary condition


### Field: BoSSS.Foundation.Grid.Classic.CellFaceTag.FaceIndex <a id="bosss.foundation.grid.classic.cellfacetag.faceindex"></a>
**Summary:** Face index of the owner cell (*not* the cell referenced with [BoSSS.Foundation.Grid.Classic.CellFaceTag.NeighCell_GlobalID](#bosss.foundation.grid.classic.cellfacetag.neighcell_globalid)).


### Field: BoSSS.Foundation.Grid.Classic.CellFaceTag.NeighCell_GlobalID <a id="bosss.foundation.grid.classic.cellfacetag.neighcell_globalid"></a>
**Summary:** Two options, depending on  [BoSSS.Foundation.Grid.Classic.CellFaceTag.EdgeTag](#bosss.foundation.grid.classic.cellfacetag.edgetag):
- internal edges or periodic boundaries: the global identification of the neighbor cell, i.e. this entry is non-negative.
- not used for cell face tags that represent boundary conditions: then, this entry should be negative.


### Field: BoSSS.Foundation.Grid.Classic.CellFaceTag.ConformalNeighborship <a id="bosss.foundation.grid.classic.cellfacetag.conformalneighborship"></a>
**Summary:** True, if the face vertices match 1-to-1 with the face vertices of
some other cell. This information is optional, i.e. if this flag is
set to false, the code will test if the connection to the neighbor
is conformal. However, this causes some performance overhead and
the result depends on certain tolerance thresholds.


## Method: BoSSS.Foundation.Grid.Classic.CellFaceTag.ToString <a id="bosss.foundation.grid.classic.cellfacetag.tostring"></a>

## Class: BoSSS.Foundation.Grid.Classic.GridCommons <a id="bosss.foundation.grid.classic.gridcommons"></a>

**Summary:** Defines basic grid information which are used to create a
[BoSSS.Foundation.Grid.Classic.GridCommons.GridData](#bosss.foundation.grid.classic.gridcommons.griddata) object.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.Cells <a id="bosss.foundation.grid.classic.gridcommons.cells"></a>
**Summary:** Cells of the grid.
**Remark:**
Cannot be implemented as property since NonSerialized only works
for fields.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.BcCells <a id="bosss.foundation.grid.classic.gridcommons.bccells"></a>
**Summary:** Optional elements that mark boundary conditions. Their global indices resp. global Id's 
start after those of the [BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells).


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement[],BoSSS.Foundation.Grid.RefElements.RefElement[]) <a id="bosss.foundation.grid.classic.gridcommons.#ctor(bosss.foundation.grid.refelements.refelement[],bosss.foundation.grid.refelements.refelement[])"></a>
**Summary:** creates a new grid object; no data of this object is set;
A new Guid ([BoSSS.Foundation.Grid.Classic.GridCommons.ID](#bosss.foundation.grid.classic.gridcommons.id)) is created;


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.EdgeTagNames <a id="bosss.foundation.grid.classic.gridcommons.edgetagnames"></a>
**Summary:** This is a mapping from each used EdgeTag to a string that
provides a name and additional information about the EdgeTag. The
intention for this member is to provide both, a name (e.g.
'Left wall') for different regions of the boundary as well as
boundary condition type info (e.g. 'inlet' or 'wall' or 'outflow' ...).
**Remark:**
The names have no impact on the application on this application
layer (L2-layer of BoSSS). They may be used on a higher application
layer; Usually, this member (as like mostly all other public
variable of this class) should be initialized by grid generator
programs (see [BoSSS.Foundation.Grid.IGrid_Extensions.DefineEdgeTags(BoSSS.Foundation.Grid.IGrid,System.Func{System.Double[],System.String})](#bosss.foundation.grid.igrid_extensions.defineedgetags(bosss.foundation.grid.igrid,system.func{system.double[],system.string}))).


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_EdgeTagNames <a id="bosss.foundation.grid.classic.gridcommons.m_edgetagnames"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridCommons.EdgeTagNames](#bosss.foundation.grid.classic.gridcommons.edgetagnames)


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.AddPredefinedPartitioning(System.String,System.Int32[]) <a id="bosss.foundation.grid.classic.gridcommons.addpredefinedpartitioning(system.string,system.int32[])"></a>
**Summary:** adds a predefined partitioning to the grid
**Parameter:** `id` - The unique name of the partitioning
**Parameter:** `cellToRankMap` - For each cell, the MPI rank which should own the cell;


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.AddPredefinedPartitioning(System.String,System.Func{System.Double[],System.Int32}) <a id="bosss.foundation.grid.classic.gridcommons.addpredefinedpartitioning(system.string,system.func{system.double[],system.int32})"></a>
**Summary:** Adds a predefined partitioning to the grid. Here, the partitioning
can be based on geometrical information in the form of cell centers
**Parameter:** `id` - 
**Parameter:** `PartFunc` - A function, which maps the center-of-gravity of each cell to a
MPI-rank

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.GridPartitioningVector <a id="bosss.foundation.grid.classic.gridcommons.gridpartitioningvector"></a>

**Summary:** values of [BoSSS.Foundation.Grid.Classic.GridCommons.m_PredefinedGridPartitioning](#bosss.foundation.grid.classic.gridcommons.m_predefinedgridpartitioning)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.GridPartitioningVector.Guid <a id="bosss.foundation.grid.classic.gridcommons.gridpartitioningvector.guid"></a>
**Summary:** Guid assigned to [BoSSS.Foundation.Grid.Classic.GridCommons.GridPartitioningVector.CellToRankMap](#bosss.foundation.grid.classic.gridcommons.gridpartitioningvector.celltorankmap)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.GridPartitioningVector.CellToRankMap <a id="bosss.foundation.grid.classic.gridcommons.gridpartitioningvector.celltorankmap"></a>
**Summary:** partitioning vector


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_PredefinedGridPartitioning <a id="bosss.foundation.grid.classic.gridcommons.m_predefinedgridpartitioning"></a>
**Summary:** See [BoSSS.Foundation.Grid.Classic.GridCommons.PredefinedGridPartitioning](#bosss.foundation.grid.classic.gridcommons.predefinedgridpartitioning).


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.PredefinedGridPartitioning <a id="bosss.foundation.grid.classic.gridcommons.predefinedgridpartitioning"></a>
**Summary:** - keys: a string 'id' which identifies the partitioning
- entries: Vectors and their Guids that contain the partitioning for 'id'.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_BcCellsStorageGuid <a id="bosss.foundation.grid.classic.gridcommons.m_bccellsstorageguid"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridCommons.BcCellsStorageGuid](#bosss.foundation.grid.classic.gridcommons.bccellsstorageguid).


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.Description <a id="bosss.foundation.grid.classic.gridcommons.description"></a>
**Summary:** a string to store some user-information about the grid;


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.StorageGuid <a id="bosss.foundation.grid.classic.gridcommons.storageguid"></a>
**Summary:** returns the Guid of the vector in which
[BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells) is stored in the database. (see [BoSSS.Foundation.IO.DatabaseDriver.SaveGrid(BoSSS.Foundation.Grid.IGrid,BoSSS.Foundation.IO.IDatabaseInfo)](#bosss.foundation.io.databasedriver.savegrid(bosss.foundation.grid.igrid,bosss.foundation.io.idatabaseinfo)));


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_StorageGuid <a id="bosss.foundation.grid.classic.gridcommons.m_storageguid"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridCommons.StorageGuid](#bosss.foundation.grid.classic.gridcommons.storageguid).


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.BcCellsStorageGuid <a id="bosss.foundation.grid.classic.gridcommons.bccellsstorageguid"></a>
**Summary:** returns the Guid of the vector in which
[BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells) is stored in the database, see also [BoSSS.Foundation.Grid.Classic.GridCommons.AllDataVectorIDs](#bosss.foundation.grid.classic.gridcommons.alldatavectorids)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG <a id="bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag"></a>
**Summary:** encodes the beginning of the edge tag range which is dedicated
to periodic boundary conditions.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.AddPeriodicEdgeTrafo(BoSSS.Platform.LinAlg.AffineTrafo) <a id="bosss.foundation.grid.classic.gridcommons.addperiodicedgetrafo(bosss.platform.linalg.affinetrafo)"></a>
**Summary:** Periodic boundary conditions are treated by connecting an "outlet"
with some "inlet". Beside the cell neighborship relations (see
[BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours](#bosss.foundation.grid.classic.griddata.celldata.cellneighbours)) an linear
transformation must be provided which maps an affine-linear
manifold A (the "outlet") of dimension D-1 (D denotes the spatial
dimension) to another affine-linear manifold B (the "inlet"). (Note
that the terms "outlet" and "inlet" are exchangeable.)
**Parameter:** `periodicTrafo` - Transformation from "inlet" to "outlet" pair
**Returns:**



### Property: BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo <a id="bosss.foundation.grid.classic.gridcommons.periodictrafo"></a>
**Summary:** list of transformations which describe how some edges should be
transformed to other edges;
**Remark:**
indices into this list are the
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeTags](#bosss.foundation.grid.classic.griddata.edgedata.edgetags) minus
[BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_PeriodicTrafo <a id="bosss.foundation.grid.classic.gridcommons.m_periodictrafo"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo](#bosss.foundation.grid.classic.gridcommons.periodictrafo)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.InversePeriodicTrafo <a id="bosss.foundation.grid.classic.gridcommons.inverseperiodictrafo"></a>
**Summary:** inverse mappings to [BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo](#bosss.foundation.grid.classic.gridcommons.periodictrafo);


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_InversePeriodicTrafo <a id="bosss.foundation.grid.classic.gridcommons.m_inverseperiodictrafo"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridCommons.PeriodicTrafo](#bosss.foundation.grid.classic.gridcommons.periodictrafo)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NoOfUpdateCells <a id="bosss.foundation.grid.classic.gridcommons.noofupdatecells"></a>
**Summary:** The number of locally updated (on this MPI process)
cells (i.e. internal and border cells, but not external cells).


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NoOfBcCells <a id="bosss.foundation.grid.classic.gridcommons.noofbccells"></a>
**Summary:** Number of boundary condition cells over all MPI processes.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_ClassNameOfRefElement <a id="bosss.foundation.grid.classic.gridcommons.m_classnameofrefelement"></a>
**Summary:** class type of entry of [BoSSS.Foundation.Grid.Classic.GridCommons.m_RefElements](#bosss.foundation.grid.classic.gridcommons.m_refelements)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_ClassNameOfEdgeRefElement <a id="bosss.foundation.grid.classic.gridcommons.m_classnameofedgerefelement"></a>
**Summary:** class type of entry of [BoSSS.Foundation.Grid.Classic.GridCommons.m_EdgeRefElements](#bosss.foundation.grid.classic.gridcommons.m_edgerefelements)


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_TotalNumberOfCells <a id="bosss.foundation.grid.classic.gridcommons.m_totalnumberofcells"></a>
**Summary:** the total number of cells;
Since this value is required for the loading of the cells (in order
to compute an MPI-partition) this value is actually stored
redundantly during serialization.
a negative value indicates undefined;


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_TotalNumberOfBcCells <a id="bosss.foundation.grid.classic.gridcommons.m_totalnumberofbccells"></a>
**Summary:** The total number of boundary condition;
Since this value is required for the loading of the cells (in order
to compute an MPI-partition) this value is actually stored
redundantly during serialization.
a negative value indicates undefined;


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NumberOfCells_l <a id="bosss.foundation.grid.classic.gridcommons.numberofcells_l"></a>
**Summary:** The total number of cells in all MPI processes.
Required by [BoSSS.Foundation.IO.DatabaseDriver.LoadGridData(BoSSS.Foundation.Grid.IGrid)](#bosss.foundation.io.databasedriver.loadgriddata(bosss.foundation.grid.igrid)) to distribute the cells 
over all given processors;


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NumberOfBcCells <a id="bosss.foundation.grid.classic.gridcommons.numberofbccells"></a>
**Summary:** The total number of boundary-condition cells ([BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells)) in all MPI processes.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.OnSerializing(System.Runtime.Serialization.StreamingContext) <a id="bosss.foundation.grid.classic.gridcommons.onserializing(system.runtime.serialization.streamingcontext)"></a>
**Summary:** This method initializes [BoSSS.Foundation.Grid.Classic.GridCommons.m_ClassNameOfRefElement](#bosss.foundation.grid.classic.gridcommons.m_classnameofrefelement)
from [BoSSS.Foundation.Grid.Classic.GridCommons.m_RefElements](#bosss.foundation.grid.classic.gridcommons.m_refelements).
**Parameter:** `context` - 


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Init_ClassNameOfSimplex <a id="bosss.foundation.grid.classic.gridcommons.init_classnameofsimplex"></a>
**Summary:** this method initializes [BoSSS.Foundation.Grid.Classic.GridCommons.m_ClassNameOfRefElement](#bosss.foundation.grid.classic.gridcommons.m_classnameofrefelement)
from [BoSSS.Foundation.Grid.Classic.GridCommons.m_RefElements](#bosss.foundation.grid.classic.gridcommons.m_refelements).


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.AfterDeserialisation(System.Runtime.Serialization.StreamingContext) <a id="bosss.foundation.grid.classic.gridcommons.afterdeserialisation(system.runtime.serialization.streamingcontext)"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridCommons.OnSerializing(System.Runtime.Serialization.StreamingContext)](#bosss.foundation.grid.classic.gridcommons.onserializing(system.runtime.serialization.streamingcontext));
**Parameter:** `context` - 


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetRefElementType(System.String) <a id="bosss.foundation.grid.classic.gridcommons.getrefelementtype(system.string)"></a>
**Summary:** Workaround to map full qualified type names ('fqn') from the time before 
the December-16-refactoring to the respective types.
This method is necessary to deserialize the old data.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Init_GridSimplices <a id="bosss.foundation.grid.classic.gridcommons.init_gridsimplices"></a>
**Summary:** this method initializes [BoSSS.Foundation.Grid.Classic.GridCommons.m_RefElements](#bosss.foundation.grid.classic.gridcommons.m_refelements)
from [BoSSS.Foundation.Grid.Classic.GridCommons.m_ClassNameOfRefElement](#bosss.foundation.grid.classic.gridcommons.m_classnameofrefelement).


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_RefElements <a id="bosss.foundation.grid.classic.gridcommons.m_refelements"></a>
**Summary:** reference elements for this grid;


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_EdgeRefElements <a id="bosss.foundation.grid.classic.gridcommons.m_edgerefelements"></a>
**Summary:** reference elements for this grid;


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetRefElement(System.Int32) <a id="bosss.foundation.grid.classic.gridcommons.getrefelement(system.int32)"></a>
**Summary:** specific reference element for this grid.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CheckCellTypes <a id="bosss.foundation.grid.classic.gridcommons.checkcelltypes"></a>
**Summary:** Checks that each cell type [BoSSS.Foundation.Grid.Classic.Element.Type](#bosss.foundation.grid.classic.element.type)
of all [BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells) and [BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells) in this grid can be mapped 
to a reference element ([BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)) resp. an edge reference element ([BoSSS.Foundation.Grid.Classic.GridCommons.EdgeRefElements](#bosss.foundation.grid.classic.gridcommons.edgerefelements)) in this grid.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetRefElement(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.classic.gridcommons.getrefelement(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** finds the reference element for a specific cell type.


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.RefElements <a id="bosss.foundation.grid.classic.gridcommons.refelements"></a>
**Summary:** all reference elements in the grid


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.EdgeRefElements <a id="bosss.foundation.grid.classic.gridcommons.edgerefelements"></a>
**Summary:** all reference elements for edges in the grid.


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.SpatialDimension <a id="bosss.foundation.grid.classic.gridcommons.spatialdimension"></a>
**Summary:** the simplex dimension in the sense of measure-theory


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.CellPartitioning <a id="bosss.foundation.grid.classic.gridcommons.cellpartitioning"></a>
**Summary:** Gets the partition of cells over the MPI processes;


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.BcCellPartitioning <a id="bosss.foundation.grid.classic.gridcommons.bccellpartitioning"></a>
**Summary:** Gets the partition of boundary-condition cells over the MPI
processes;


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetGlobalId2CellIndexMap <a id="bosss.foundation.grid.classic.gridcommons.getglobalid2cellindexmap"></a>
**Summary:** Returns a dictionary that maps GlobalId's (on the current MPI
processor) to local cell indices.
**Returns:**
a mapping from the GlobalID's to local cell indices;
Keys of the dictionary: GlobalId of a locally stored cell (also
external cell);
Values of the dictionary: local cell indices;
Contains only internal cells.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetGlobalIDPermutation(System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.getglobalidpermutation(system.boolean)"></a>
**Summary:** Returns the current GlobalID - permutation of this grid,
i.e. a mapping from the global index to the global ID.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetInverseGlobalIDPermutation(System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.getinverseglobalidpermutation(system.boolean)"></a>
**Summary:** The inverse of [BoSSS.Foundation.Grid.Classic.GridCommons.GetGlobalIDPermutation(System.Boolean)](#bosss.foundation.grid.classic.gridcommons.getglobalidpermutation(system.boolean)),
i.e. a mapping from the global ID to global indices.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CheckGridForNANorINF <a id="bosss.foundation.grid.classic.gridcommons.checkgridfornanorinf"></a>
**Summary:** checks [BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells) for the occurrence of NAN or INF values.


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.MyRank <a id="bosss.foundation.grid.classic.gridcommons.myrank"></a>
**Summary:** MPI process rank (within world communicator)
**Remark:**
fk, 02sep22: since this is called quite often (within loops), it is worth caching; this is about 25 times faster.


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.Size <a id="bosss.foundation.grid.classic.gridcommons.size"></a>
**Summary:** MPI world communicator size
**Remark:**
fk, 02sep22: since this is called quite often (within loops), it is worth caching; this is about 25 times faster.


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NodePartitioning <a id="bosss.foundation.grid.classic.gridcommons.nodepartitioning"></a>
**Summary:** the partition of cell nodes among MPI processes


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.iGridData <a id="bosss.foundation.grid.classic.gridcommons.igriddata"></a>
**Summary:** Access to grid metrics


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.GridData <a id="bosss.foundation.grid.classic.gridcommons.griddata"></a>
**Summary:** Typed version of [BoSSS.Foundation.Grid.Classic.GridCommons.iGridData](#bosss.foundation.grid.classic.gridcommons.igriddata)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.AllDataVectorIDs <a id="bosss.foundation.grid.classic.gridcommons.alldatavectorids"></a>


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.InvalidateGridData <a id="bosss.foundation.grid.classic.gridcommons.invalidategriddata"></a>
**Summary:** Releases the object cached in [BoSSS.Foundation.Grid.Classic.GridCommons.iGridData](#bosss.foundation.grid.classic.gridcommons.igriddata); this is necessary if 
the grid object was changed somehow.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CheckMonotonicity(System.Double[]) <a id="bosss.foundation.grid.classic.gridcommons.checkmonotonicity(system.double[])"></a>
**Summary:** Checks whether the given 'nodes' are in
monotonically increasing order.
**Parameter:** `nodes` - 


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Clone <a id="bosss.foundation.grid.classic.gridcommons.clone"></a>
**Summary:** clone


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Transform(BoSSS.Platform.LinAlg.AffineTrafo) <a id="bosss.foundation.grid.classic.gridcommons.transform(bosss.platform.linalg.affinetrafo)"></a>
**Summary:** Helper function, used for debugging: transforms the whole grid by an affine-linear transformation 'T'.
**Parameter:** `T` - some transformation


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CompressIndexRange(System.Int32[][]) <a id="bosss.foundation.grid.classic.gridcommons.compressindexrange(system.int32[][])"></a>
**Summary:** Index compression on a single processor.
**Parameter:** `_IDX` - Input, a collection of numbers, structured into a staggered array.
**Returns:**
A staggered array with equal number of entries as '_IDX'.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CompressGlobalID(System.Collections.Generic.IList{System.Int64}) <a id="bosss.foundation.grid.classic.gridcommons.compressglobalid(system.collections.generic.ilist{system.int64})"></a>
**Summary:** This function ensures that the GlobalID's of cells
([BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells)) and boundary-condition cells
([BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells)) 
start at 0 and 
occupy a continuous region of natural numbers.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CompressNodeIndices <a id="bosss.foundation.grid.classic.gridcommons.compressnodeindices"></a>
**Summary:** This function ensures that the node indices (see [BoSSS.Foundation.Grid.Classic.Element.NodeIndices](#bosss.foundation.grid.classic.element.nodeindices))
start at 0 and 
occupy a continuous region of natural numbers.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.MergeAndCheckNodes <a id="bosss.foundation.grid.classic.gridcommons.mergeandchecknodes"></a>
**Summary:** Merges duplicate nodes and checks that unique nodes are geometrically at the same position.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CheckAndFixJacobianDeterminat <a id="bosss.foundation.grid.classic.gridcommons.checkandfixjacobiandeterminat"></a>
**Summary:** Checks that the Jacobian determinant of all cells is positive.
Elements with purly negative Jacobian determinant are fixed by a mirror operation.
If the Jacobian determinant flips sign in one cell, this is an un-recoverable error.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.MirrorPermutation(BoSSS.Foundation.Grid.RefElements.CellType,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.classic.gridcommons.mirrorpermutation(bosss.foundation.grid.refelements.celltype,system.int32[]@,system.int32[]@)"></a>
**Summary:** For some reference element, this computes the permutation of nodes under a mirror operation.
The purpose of this operation is to fix cells with negative Jacobian determinant by mirroring them,
since the mirror operation flips the sign of the Jacobian determinant.
The reference element must be centered around the origin, so that the mirror operation maps it onto itself.
**Parameter:** `ct` - 
**Parameter:** `NodesPerm` - Permutation of interpolation nodes, see [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes(BoSSS.Foundation.Grid.RefElements.CellType)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes(bosss.foundation.grid.refelements.celltype)).
**Parameter:** `VertxPerm` - Permutation of reference element vertices, see [BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices).


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Equals(BoSSS.Foundation.IO.IGridInfo) <a id="bosss.foundation.grid.classic.gridcommons.equals(bosss.foundation.io.igridinfo)"></a>
**Summary:** Compares this grid to another.
**Parameter:** `other` - The grid to compare to.
**Returns:**
true, if the grid GUIDs are the same; false otherwise.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Equals(System.Object) <a id="bosss.foundation.grid.classic.gridcommons.equals(system.object)"></a>
**Summary:** Equality.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetHashCode <a id="bosss.foundation.grid.classic.gridcommons.gethashcode"></a>
**Summary:** Number of cells if used as hash code.

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.GridBox <a id="bosss.foundation.grid.classic.gridcommons.gridbox"></a>

**Summary:** Needed for a simplified creation of a hanging nodes grid.
Note: stores only a BoundingBox [BoSSS.Platform.Utils.Geom.BoundingBox](BoSSS.Platform.md#bosss.platform.utils.geom.boundingbox) and the 
number of Cells in x and y direction


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.CreationTime <a id="bosss.foundation.grid.classic.gridcommons.creationtime"></a>
**Summary:** creation time of the grid: implements [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.CreationTime](#bosss.foundation.io.idatabaseentityinfo`1.creationtime)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.WriteTime <a id="bosss.foundation.grid.classic.gridcommons.writetime"></a>
**Summary:** The time when this object has been written to disc.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.m_GridGuid <a id="bosss.foundation.grid.classic.gridcommons.m_gridguid"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridCommons.ID](#bosss.foundation.grid.classic.gridcommons.id);


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.ID <a id="bosss.foundation.grid.classic.gridcommons.id"></a>
**Summary:** Guid/Identification of this grid object in the database [BoSSS.Foundation.Grid.Classic.GridCommons.Database](#bosss.foundation.grid.classic.gridcommons.database)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.Name <a id="bosss.foundation.grid.classic.gridcommons.name"></a>
**Summary:** grid name: implementation of [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Name](#bosss.foundation.io.idatabaseentityinfo`1.name)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.NumberOfCells <a id="bosss.foundation.grid.classic.gridcommons.numberofcells"></a>
**Summary:** number of cells in the grid: implementation of [BoSSS.Foundation.IO.IGridInfo.NumberOfCells](#bosss.foundation.io.igridinfo.numberofcells)


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.Database <a id="bosss.foundation.grid.classic.gridcommons.database"></a>
**Summary:** Database which de-serialized this grid; implementation of [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.Database](#bosss.foundation.io.idatabaseentityinfo`1.database)


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.CopyFor(BoSSS.Foundation.IO.IDatabaseInfo) <a id="bosss.foundation.grid.classic.gridcommons.copyfor(bosss.foundation.io.idatabaseinfo)"></a>
**Summary:** Copies this info object for usage in another database.
**Parameter:** `targetDatabase` - The target database.
**Returns:**
A copy of the original info object for usage in the target database.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.ToString <a id="bosss.foundation.grid.classic.gridcommons.tostring"></a>
**Summary:** Creates a human-readable string representation of the grid info object.
**Returns:**
A string summary of the grid.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.MergeLogically(BoSSS.Foundation.Grid.Classic.GridCommons[]) <a id="bosss.foundation.grid.classic.gridcommons.mergelogically(bosss.foundation.grid.classic.gridcommons[])"></a>
**Summary:** Concatenates grids into one data structure an makes use of [BoSSS.Foundation.Grid.Classic.GridCommons.MergeLogically(BoSSS.Foundation.Grid.Classic.GridCommons,BoSSS.Foundation.Grid.Classic.GridCommons)](#bosss.foundation.grid.classic.gridcommons.mergelogically(bosss.foundation.grid.classic.gridcommons,bosss.foundation.grid.classic.gridcommons))
**Parameter:** `grids` - list of different grids


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.MergeLogically(BoSSS.Foundation.Grid.Classic.GridCommons,BoSSS.Foundation.Grid.Classic.GridCommons) <a id="bosss.foundation.grid.classic.gridcommons.mergelogically(bosss.foundation.grid.classic.gridcommons,bosss.foundation.grid.classic.gridcommons)"></a>
**Summary:** Concatenates grids 'A' and 'B' into one data structure.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Seal(BoSSS.Foundation.Grid.Classic.GridCommons,System.Int32) <a id="bosss.foundation.grid.classic.gridcommons.seal(bosss.foundation.grid.classic.gridcommons,system.int32)"></a>
**Summary:** Usually used after [BoSSS.Foundation.Grid.Classic.GridCommons.MergeLogically(BoSSS.Foundation.Grid.Classic.GridCommons,BoSSS.Foundation.Grid.Classic.GridCommons)](#bosss.foundation.grid.classic.gridcommons.mergelogically(bosss.foundation.grid.classic.gridcommons,bosss.foundation.grid.classic.gridcommons)); this method finds element boundaries
which intersect geometrically, but not logically and inserts a [BoSSS.Foundation.Grid.Classic.CellFaceTag](#bosss.foundation.grid.classic.cellfacetag) which connects those cells.
**Parameter:** `g` - 
**Parameter:** `upsampling` - 
**Returns:**


## Class: BoSSS.Foundation.Grid.Classic.GridCommons.Neighbour <a id="bosss.foundation.grid.classic.gridcommons.neighbour"></a>

**Summary:** return values of [BoSSS.Foundation.Grid.Classic.GridCommons.GetCellNeighbourship(System.Boolean,System.Boolean)](#bosss.foundation.grid.classic.gridcommons.getcellneighbourship(system.boolean,system.boolean)).


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.Neighbour.Neighbour_GlobalIndex <a id="bosss.foundation.grid.classic.gridcommons.neighbour.neighbour_globalindex"></a>
**Summary:** global index of neighbor cell.


### Field: BoSSS.Foundation.Grid.Classic.GridCommons.Neighbour.CellFaceTag <a id="bosss.foundation.grid.classic.gridcommons.neighbour.cellfacetag"></a>
**Summary:** if present, a face tag


### Property: BoSSS.Foundation.Grid.Classic.GridCommons.Neighbour.IsPeriodicNeighbour <a id="bosss.foundation.grid.classic.gridcommons.neighbour.isperiodicneighbour"></a>
**Summary:** true, if the neighbor cell is reached by a periodic boundary
condition

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellIndexPair <a id="bosss.foundation.grid.classic.gridcommons.nodecellindexpair"></a>

**Summary:** Helper that wraps a node index with an associated global id of a
cell that uses this particular node.

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellListPair <a id="bosss.foundation.grid.classic.gridcommons.nodecelllistpair"></a>

**Summary:** Helper that wraps a node index with a list of global ids of cells
that share this node

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellIndexPair_ContainerClass <a id="bosss.foundation.grid.classic.gridcommons.nodecellindexpair_containerclass"></a>


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellIndexPair_ContainerClass.Serialize <a id="bosss.foundation.grid.classic.gridcommons.nodecellindexpair_containerclass.serialize"></a>
**Summary:** Optimized serialization;
**Remark:**
Fk, 08sep22: especially in MPI-parallel (64 cores or more) setups, 
the **ilPSP.Utils.SerialisationMessenger** produces memory-usage peaks which sometimes even crash the simulation due to out-of-memory.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellIndexPair_ContainerClass.Deserialize(System.Int64[]) <a id="bosss.foundation.grid.classic.gridcommons.nodecellindexpair_containerclass.deserialize(system.int64[])"></a>
**Summary:** Optimized de-serialization

## Class: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellListPair_ContainerClass <a id="bosss.foundation.grid.classic.gridcommons.nodecelllistpair_containerclass"></a>


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellListPair_ContainerClass.Serialize <a id="bosss.foundation.grid.classic.gridcommons.nodecelllistpair_containerclass.serialize"></a>
**Summary:** Optimized serialization;
**Remark:**
Fk, 08sep22: especially in MPI-parallel (64 cores or more) setups, 
the **ilPSP.Utils.SerialisationMessenger** produces memory-usage peaks which sometimes even crash the simulation due to out-of-memory.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.NodeCellListPair_ContainerClass.Deserialize(System.Int64[]) <a id="bosss.foundation.grid.classic.gridcommons.nodecelllistpair_containerclass.deserialize(system.int64[])"></a>
**Summary:** Optimized de-serialization


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetCellNeighbourship(System.Boolean,System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.getcellneighbourship(system.boolean,system.boolean)"></a>
**Summary:** Computes the neighbor cells globally (i.e. over all MPI processors) for each local cell.
**Parameter:** `IncludeBcCells` - If true, also the boundary condition cells ([BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells)) will be included in the output array.
**Parameter:** `FilterPeriodicDuplicities` -
Relevant in case of periodic boundary conditions with one or two cells in periodic direction;
In such cases, the following can occur:
- for one cell in periodic direction: the cell is its own neighbor
- for two cells in periodic direction: the cell has two edges with the same neigbor, i.e. a normal one and a periodic one
Both cases violate the definition of a undirected graph, i.e. there can only be one or zero edge between to cells (aka. vertexes in the sense of a ) and any edge must be between two cells.

If set to true, these suckers will be taken out.
**Returns:**
Cell-wise neighborship information:
- 1st index: local cell index j, i.e. correlates with [BoSSS.Foundation.Grid.Classic.GridCommons.Cells](#bosss.foundation.grid.classic.gridcommons.cells); if 'IncludeBcCells' is true,
the information for boundary cells is added after the information for cells.
- 2nd index: enumeration; for the index j the set of neighbor cells. If the global index ([BoSSS.Foundation.Grid.Classic.GridCommons.Neighbour.Neighbour_GlobalIndex](#bosss.foundation.grid.classic.gridcommons.neighbour.neighbour_globalindex))
is greater or equal than the global number of cells ([BoSSS.Foundation.Grid.Classic.GridCommons.NumberOfCells](#bosss.foundation.grid.classic.gridcommons.numberofcells)) the neighbor is a boundary condition cell,
([BoSSS.Foundation.Grid.Classic.GridCommons.BcCells](#bosss.foundation.grid.classic.gridcommons.bccells)).


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Intersect(System.Int64[][],System.Int64) <a id="bosss.foundation.grid.classic.gridcommons.intersect(system.int64[][],system.int64)"></a>
**Summary:** Finds conformal cell neighborings;
**Parameter:** `B` -
For each vertex of some cell face, the global indices of all cells
which use that vertex
- 1st index: face vertex index
- 2nd index: enumeration
- content: global cell index
**Parameter:** `j_cell_myself` - global cell index
**Returns:**
Either the global index of a neighbor cell
(this is the set-intersection of all 'B'[i] - sets, excluding 'j_cell_myself' and should have at most 1 element), or a negative number if
there is no neighbor.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.GetFaceTagsNeigbourIndices(System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.getfacetagsneigbourindices(system.boolean)"></a>
**Summary:** converts the GlobalID-based neighborship information (GlobalId's
of the face tags, see[BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags) resp.
[BoSSS.Foundation.Grid.Classic.CellFaceTag.NeighCell_GlobalID](#bosss.foundation.grid.classic.cellfacetag.neighcell_globalid))
into global cell indices
**Returns:**
content: global cell indices;
- 1st index: local cell index
- 2nd index: correlates with the ordering of [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags).


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.Redistribute(BoSSS.Foundation.IO.IDatabaseInfo,BoSSS.Foundation.Grid.GridPartType,System.String) <a id="bosss.foundation.grid.classic.gridcommons.redistribute(bosss.foundation.io.idatabaseinfo,bosss.foundation.grid.gridparttype,system.string)"></a>
**Summary:** Driver method for grid redistribution; this includes 
- computing a new partition (e.g. by [BoSSS.Foundation.Grid.Classic.GridCommons.ComputePartitionMETIS(System.Collections.Generic.IList{System.Int32[]},System.Int32)](#bosss.foundation.grid.classic.gridcommons.computepartitionmetis(system.collections.generic.ilist{system.int32[]},system.int32)), [BoSSS.Foundation.Grid.Classic.GridCommons.ComputePartitionHilbert(System.Collections.Generic.IList{System.Int32[]},System.Int32,System.Boolean)](#bosss.foundation.grid.classic.gridcommons.computepartitionhilbert(system.collections.generic.ilist{system.int32[]},system.int32,system.boolean))) 
*or* loading a predefined partition [BoSSS.Foundation.Grid.Classic.GridCommons.PredefinedGridPartitioning](#bosss.foundation.grid.classic.gridcommons.predefinedgridpartitioning) from the database
- application of this partition to this grid, by a call to [BoSSS.Foundation.Grid.Classic.GridCommons.RedistributeGrid(System.Int32[])](#bosss.foundation.grid.classic.gridcommons.redistributegrid(system.int32[]))


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.ComputePartitionMETIS(System.Collections.Generic.IList{System.Int32[]},System.Int32) <a id="bosss.foundation.grid.classic.gridcommons.computepartitionmetis(system.collections.generic.ilist{system.int32[]},system.int32)"></a>
**Summary:** Computes a grid partitioning (which cell should be on which processor)
using the serial METIS library -- work is only done on MPi rank 0.
**Parameter:** `ListofLocalCellWeights` - If not null, defines the weight associated with each cell on the current process
**Parameter:** `noOfPartitioningsToChooseFrom` - Tells METIS to compute
**Returns:**
- Index: local cell index, 
- content: MPI Processor rank
This is the suggestion
of ParMETIS for the grid partitioning:
For each local cell index, the returned array contains the MPI
process rank where the cell should be placed.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.SortPartitioning(System.Int32[]) <a id="bosss.foundation.grid.classic.gridcommons.sortpartitioning(system.int32[])"></a>
**Summary:** Sort the new partitioning w.r.t. current one to minimize the cost of re-distribution.
Because partitioning algorithms do not take the current partitioning into account
and assigns an arbitrary processor to partitions.
**Parameter:** `part` -
Global list for partitioning
- Index: cell index, 
- content: MPI Processor rank
**Returns:**
Global list for partitioning
For each local cell index, the returned array contains the MPI
process rank where the cell should be placed.
- Index: cell index, 
- content: MPI Processor rank


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.SMPRedistribution <a id="bosss.foundation.grid.classic.gridcommons.smpredistribution"></a>
**Summary:** Not implemented.
**Returns:**
- Index: local cell index
- content: MPI Processor rank;
This is the suggestion
of ParMETIS for the grid partitioning:
For each local cell index, the returned array contains the MPI processor rank
where the cell should be placed.
may be null, if no repartitioning is required at all.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.ComputePartitionParMETIS(System.Collections.Generic.IList{System.Int32[]},System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.computepartitionparmetis(system.collections.generic.ilist{system.int32[]},system.boolean)"></a>
**Summary:** Computes a grid partitioning (which cell should be on which processor)
by calling ParMETIS.
**Parameter:** `cellWeights` - If not null, defines the (list of) weights associated with each
cell on this process. If multiple weights are present per cell,
this implies that there are multiple balance constraints to be
obeyed by ParMETIS
**Parameter:** `refineCurrentPartitioning` - Refines the current partitioning instead of starting from scratch
**Returns:**
Index: local cell index, content: MPI Processor rank;
This is the suggestion
of ParMETIS for the grid partitioning:
For each local cell index, the returned array contains the MPI
process rank where the cell should be placed.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.ComputePartitionHilbert(System.Collections.Generic.IList{System.Int32[]},System.Int32,System.Boolean) <a id="bosss.foundation.grid.classic.gridcommons.computepartitionhilbert(system.collections.generic.ilist{system.int32[]},system.int32,system.boolean)"></a>
**Summary:** Computes a grid partitioning (which cell should be on which processor) based on a Hilbertcurve of maximum order (64 bit>nBit*nDim).
Note: The identification of barycenter only works for rectangular-shaped cells.


## Method: BoSSS.Foundation.Grid.Classic.GridCommons.RedistributeGrid(System.Int32[]) <a id="bosss.foundation.grid.classic.gridcommons.redistributegrid(system.int32[])"></a>
**Summary:** redistributes this grid, i.e. sends cells to different processors
**Parameter:** `part` - MPI processor rank for each cell; index: local cell index;

## Class: BoSSS.Foundation.Grid.Classic.GridCorrelation <a id="bosss.foundation.grid.classic.gridcorrelation"></a>

**Summary:** Mapping of an old to a new grid under adaptive mesh refinement (see [BoSSS.Foundation.Grid.Classic.GridData.Adapt(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32[]},BoSSS.Foundation.Grid.Classic.GridCorrelation@)](#bosss.foundation.grid.classic.griddata.adapt(system.collections.generic.ienumerable{system.int32},system.collections.generic.ienumerable{system.int32[]},bosss.foundation.grid.classic.gridcorrelation@)).


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.OldGlobalId <a id="bosss.foundation.grid.classic.gridcorrelation.oldglobalid"></a>
**Summary:** Mapping from old cell index to old GlobalId.
- index: local cell index into old grid
- content: GlobalId of respective cell


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.DestGlobalId <a id="bosss.foundation.grid.classic.gridcorrelation.destglobalid"></a>
**Summary:** Mapping form old cell index to GlobalId of new cells.
- 1st index: local cell index into old grid
- 2nd index: enumeration; for cells which are refined, this maps to the subdivisions; for coarsened cells, or cells which are not changed, the enumeration contains only one element.
- content: GlobalId of destination cell


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.MappingIndex <a id="bosss.foundation.grid.classic.gridcorrelation.mappingindex"></a>
**Summary:** Affine transformation between old and new cells.
- indexing: correlates with [BoSSS.Foundation.Grid.Classic.GridCorrelation.DestGlobalId](#bosss.foundation.grid.classic.gridcorrelation.destglobalid)
- content: index into [BoSSS.Foundation.Grid.Classic.GridCorrelation.GeometricMapping](#bosss.foundation.grid.classic.gridcorrelation.geometricmapping); if negative, the mapping is the identity.


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.GeometricMapping <a id="bosss.foundation.grid.classic.gridcorrelation.geometricmapping"></a>
**Summary:** Affine transformation from cell-local coordinate system to cell-local coordinate system.
- 1st index: cell reference element, correlates with [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)
- 2nd index: refinement leaf index


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.KrefS_SubdivLeaves <a id="bosss.foundation.grid.classic.gridcorrelation.krefs_subdivleaves"></a>
**Summary:** Subdivision nodes used for refinement.
- 1st index: cell reference element, correlates with [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)
- 2nd index: refinement leaf index


### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.Subdiv_BasisTransform <a id="bosss.foundation.grid.classic.gridcorrelation.subdiv_basistransform"></a>
**Summary:** Cache for [BoSSS.Foundation.Grid.Classic.GridCorrelation.GetSubdivBasisTransform(System.Int32,System.Int32,System.Int32)](#bosss.foundation.grid.classic.gridcorrelation.getsubdivbasistransform(system.int32,system.int32,system.int32)).
- 1st index: reference element
- 2nd index: subdivision node
- Item 1: basis transformation matrix, [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetBasisTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getbasistrafo(system.int32))
- Item 2: Jacobian determinate, [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Root](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2root)


## Method: BoSSS.Foundation.Grid.Classic.GridCorrelation.GetSubdivBasisTransform(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.gridcorrelation.getsubdivbasistransform(system.int32,system.int32,system.int32)"></a>
**Summary:** Transformation matrices, for cell subdivision, as computed by [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetBasisTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getbasistrafo(system.int32)),
are cached by this method.
**Parameter:** `iKref` - Reference element index, correlates with 1st index of [BoSSS.Foundation.Grid.Classic.GridCorrelation.KrefS_SubdivLeaves](#bosss.foundation.grid.classic.gridcorrelation.krefs_subdivleaves).
**Parameter:** `iSubdiv` - Subdivision leaf index, correlates with 2nd index of [BoSSS.Foundation.Grid.Classic.GridCorrelation.KrefS_SubdivLeaves](#bosss.foundation.grid.classic.gridcorrelation.krefs_subdivleaves).
**Parameter:** `p` - Requested polynomial degree.
**Returns:**



### Field: BoSSS.Foundation.Grid.Classic.GridCorrelation.TargetIdx <a id="bosss.foundation.grid.classic.gridcorrelation.targetidx"></a>
**Summary:** Mapping from local cell indices of the old grid to global cell indices of the new grid.
- 1st index: local cell index into old grid
- 2nd index: enumeration; for cells which are refined, this maps to the subdivisions; for coarsened cells, or cells which are not changed, the enumeration contains only one element.
- content: global target index (index into new grid) of respective cell.

## Class: BoSSS.Foundation.Grid.Classic.GridCorrelation.ApplyToVector_Helper`1 <a id="bosss.foundation.grid.classic.gridcorrelation.applytovector_helper`1"></a>

**Summary:** Data structure used in **BoSSS.Foundation.Grid.Classic.GridCorrelation.ApplyToVector``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0[]},ilPSP.IPartitioning)**.


## Method: BoSSS.Foundation.Grid.Classic.GridCorrelation.GetTargetMappingIndex(ilPSP.IPartitioning) <a id="bosss.foundation.grid.classic.gridcorrelation.gettargetmappingindex(ilpsp.ipartitioning)"></a>
**Parameter:** `outputPartitioning` - Partitioning of the new grid, resp the return array.
**Returns:**
- 1st index: cell index in new grid, correlates with 'outputPartitioning'.
- 2nd index: enumeration over cells (in the old grid) which are combined in the new grid. 
For cells with refinement, always one entry, for cells which are coarsened a greater number of entries.
If null, the cell is not changed.
- content: Subdivision leaf index, correlates with 2nd index of [BoSSS.Foundation.Grid.Classic.GridCorrelation.KrefS_SubdivLeaves](#bosss.foundation.grid.classic.gridcorrelation.krefs_subdivleaves), can be used as an input to [BoSSS.Foundation.Grid.Classic.GridCorrelation.GetSubdivBasisTransform(System.Int32,System.Int32,System.Int32)](#bosss.foundation.grid.classic.gridcorrelation.getsubdivbasistransform(system.int32,system.int32,system.int32)).

## Class: BoSSS.Foundation.Grid.Classic.GridCorrelation.GetTargetMapping_Helper <a id="bosss.foundation.grid.classic.gridcorrelation.gettargetmapping_helper"></a>

**Summary:** Data structure used in [BoSSS.Foundation.Grid.Classic.GridCorrelation.GetTargetMappingIndex(ilPSP.IPartitioning)](#bosss.foundation.grid.classic.gridcorrelation.gettargetmappingindex(ilpsp.ipartitioning)).

## Class: BoSSS.Foundation.Grid.Classic.GridData <a id="bosss.foundation.grid.classic.griddata"></a>

**Summary:** Contains extended information about the computational grid 
(stored in [BoSSS.Foundation.Grid.Classic.GridCommons](#bosss.foundation.grid.classic.gridcommons)-objects), which are not stored on
disk but computed at run-time, i.e. load-time. This information is
essential for the Discontinuous Galerkin algorithms.


### Property: BoSSS.Foundation.Grid.Classic.GridData.Grid <a id="bosss.foundation.grid.classic.griddata.grid"></a>
**Summary:** The grid for which information is provided


### Property: BoSSS.Foundation.Grid.Classic.GridData.BoSSS#Foundation#Grid#IGridData#Grid <a id="bosss.foundation.grid.classic.griddata.bosss#foundation#grid#igriddata#grid"></a>
**Summary:** The grid for which information is provided


### Property: BoSSS.Foundation.Grid.Classic.GridData.MultigridSequence <a id="bosss.foundation.grid.classic.griddata.multigridsequence"></a>
**Summary:** an optional (i.e. can be null) multi-grid hierarchy


## Method: BoSSS.Foundation.Grid.Classic.GridData.RegisterMultigridSequence(BoSSS.Foundation.Grid.Aggregation.AggregationGridData[]) <a id="bosss.foundation.grid.classic.griddata.registermultigridsequence(bosss.foundation.grid.aggregation.aggregationgriddata[])"></a>
**Summary:** setup of [BoSSS.Foundation.Grid.Classic.GridData.MultigridSequence](#bosss.foundation.grid.classic.griddata.multigridsequence)


### Property: BoSSS.Foundation.Grid.Classic.GridData.GridID <a id="bosss.foundation.grid.classic.griddata.gridid"></a>
**Summary:** Identification of the grid in the BoSSS database, 
equal to the [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id).


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeTagNames <a id="bosss.foundation.grid.classic.griddata.edgetagnames"></a>
**Summary:** Equal to [BoSSS.Foundation.Grid.Classic.GridCommons.EdgeTagNames](#bosss.foundation.grid.classic.gridcommons.edgetagnames).


### Property: BoSSS.Foundation.Grid.Classic.GridData.MpiRank <a id="bosss.foundation.grid.classic.griddata.mpirank"></a>
**Summary:** MPI process rank (within world communicator)


### Property: BoSSS.Foundation.Grid.Classic.GridData.MpiSize <a id="bosss.foundation.grid.classic.griddata.mpisize"></a>
**Summary:** MPI world communicator size


## Method: BoSSS.Foundation.Grid.Classic.GridData.#ctor(BoSSS.Foundation.Grid.Classic.GridCommons) <a id="bosss.foundation.grid.classic.griddata.#ctor(bosss.foundation.grid.classic.gridcommons)"></a>
**Summary:** constructor


## Method: BoSSS.Foundation.Grid.Classic.GridData.Invalidate <a id="bosss.foundation.grid.classic.griddata.invalidate"></a>
**Summary:** Clears (lots of) internal references for this object, to make sure that any attempt to use it leads to an exception.


## Method: BoSSS.Foundation.Grid.Classic.GridData.IsAlive <a id="bosss.foundation.grid.classic.griddata.isalive"></a>
**Summary:** indicates that [BoSSS.Foundation.Grid.Classic.GridData.Invalidate](#bosss.foundation.grid.classic.griddata.invalidate) has been called


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetLocalNoOfCellsRefElement(BoSSS.Foundation.Grid.RefElements.RefElement,System.Int32@,System.Int32@) <a id="bosss.foundation.grid.classic.griddata.getlocalnoofcellsrefelement(bosss.foundation.grid.refelements.refelement,system.int32@,system.int32@)"></a>
**Summary:** number of cells
of type 'r'
**Parameter:** `Ext` - number of 'r'-type cells in external/ghost cells
**Parameter:** `Loc` - number of 'r'-type cells in locally updated cells
**Parameter:** `r` - cell type


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetLocalNoOfCellsRefElement(System.Int32,System.Int32@,System.Int32@) <a id="bosss.foundation.grid.classic.griddata.getlocalnoofcellsrefelement(system.int32,system.int32@,system.int32@)"></a>
**Summary:** number of cells (including ghost/external cells)
of type [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)['iKref'].
**Parameter:** `Ext` - on exit, number of external/ghost cells of specified type
**Parameter:** `Loc` - on exit, number of locally updated cells of specified type
**Parameter:** `iKref` - reference element index


## Method: BoSSS.Foundation.Grid.Classic.GridData.TransformLocal2Global(ilPSP.MultidimensionalArray,System.Int32,System.Int32,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.classic.griddata.transformlocal2global(ilpsp.multidimensionalarray,system.int32,system.int32,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** transforms vertices from the local coordinate system of cells
'j0' to 'j0'+'Len'-1
to global coordinates;
**Parameter:** `LocalVerticesIn` - Input; vertices in the local coordinate system of a cell;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `GlobalVerticesOut` - Output; the vertices form 'LocalVerticesIn',
transformed to global coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of
'LocalVerticesIn';


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `j0` - local cell index of the first cell to transform
**Parameter:** `Len` - Number of cells to transform
**Parameter:** `OutArrayOffset` - an offset into the first index of 'GlobalVerticesOut';


### Property: BoSSS.Foundation.Grid.Classic.GridData.GlobalNodes <a id="bosss.foundation.grid.classic.griddata.globalnodes"></a>
**Summary:** Cached transformation of node sets to global coordinates.


### Property: BoSSS.Foundation.Grid.Classic.GridData.Jacobian <a id="bosss.foundation.grid.classic.griddata.jacobian"></a>
**Summary:** Jacobian of transformation from reference to physical space, $(\nabla T_j)$.


### Property: BoSSS.Foundation.Grid.Classic.GridData.AdjungateJacobian <a id="bosss.foundation.grid.classic.griddata.adjungatejacobian"></a>
**Summary:** Adjungate of the Jacobian of the reference-to-physical coordinate transformation, 
$\mathrm{Adj}( \nabla T_j ) =  \mathrm{Adj}( { \nabla T_j } ) ( \nabla T_j )^{-1}$.


### Property: BoSSS.Foundation.Grid.Classic.GridData.InverseJacobian <a id="bosss.foundation.grid.classic.griddata.inversejacobian"></a>
**Summary:** Inverse of the Jacobian of the reference-to-physical coordinate transformation, $( \nabla T_j )^{-1}$.


### Property: BoSSS.Foundation.Grid.Classic.GridData.JacobianDeterminat <a id="bosss.foundation.grid.classic.griddata.jacobiandeterminat"></a>
**Summary:** Determinant of the Jacobian of the reference-to-physical coordinate transformation, $\mathrm{Adj}( \nabla T_j )$.


## Method: BoSSS.Foundation.Grid.Classic.GridData.TransformLocal2Global(ilPSP.MultidimensionalArray,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.classic.griddata.transformlocal2global(ilpsp.multidimensionalarray,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms the 'NS'-th node set to global coordinates of
cell 'j0' to 'j0'+'Len'-1
**Parameter:** `j0` - first cell to transform
**Parameter:** `Len` - number of cells to transform
**Parameter:** `NS` - 
**Parameter:** `Nodesglob` - output, global coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of the
local nodes references by 'NS'


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;


## Method: BoSSS.Foundation.Grid.Classic.GridData.TransformGlobal2Local(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.griddata.transformglobal2local(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.int32,system.int32)"></a>
**Summary:** transforms vertices from the global coordinate system
the local coordinate systems 
of cells 'j0' to 'j0'+'Len'-1.
**Parameter:** `GlobalVerticesIn` - Input; vertices in the global coordinate system;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `LocalVerticesOut` - Output; the vertices form 'GlobalVerticesIn',
transformed to local coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of
'GlobalVerticesIn';


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `j0` - local cell index of the first cell to transform
**Parameter:** `Len` - Number of cells to transform
**Parameter:** `OutArrayOffset` - an offset into the first index of 'LocalVerticesOut';


## Method: BoSSS.Foundation.Grid.Classic.GridData.TransformGlobal2Local(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Boolean[]) <a id="bosss.foundation.grid.classic.griddata.transformglobal2local(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.boolean[])"></a>
**Summary:** transforms vertices from the global coordinate system
the local coordinate systems 
of cells
'jCell'.
**Parameter:** `GlobalVerticesIn` - Input; vertices in the global coordinate system;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `LocalVerticesOut` - Output; the vertices form 'GlobalVerticesIn',
transformed to local coordinates;


1st index: vertex index, corresponds with the 1st index of
'GlobalVerticesIn';


2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `jCell` - local cell index of the cell to transform
**Parameter:** `NewtonConvergence` - in the case of curved cells/isoparametric elements, where a Newton algorithm has to be used for the inverse transformation, 
diagnostic information whether the Newton algorithm has converged or not.
The index correlates with the vertex index in 'GlobalVerticesIn'.


## Method: BoSSS.Foundation.Grid.Classic.GridData.ParallelSetup <a id="bosss.foundation.grid.classic.griddata.parallelsetup"></a>
**Summary:** Parallel setup, e.g. send and receive lists.
- 'input data': cell-neighborship information obtained from [BoSSS.Foundation.Grid.Classic.GridCommons.GetCellNeighbourship(System.Boolean,System.Boolean)](#bosss.foundation.grid.classic.gridcommons.getcellneighbourship(system.boolean,system.boolean)).
- 'output data': [BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours_global_tmp](#bosss.foundation.grid.classic.griddata.celldata.cellneighbours_global_tmp), [BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours](#bosss.foundation.grid.classic.griddata.celldata.cellneighbours) and various entries of [BoSSS.Foundation.Grid.Classic.GridData.Parallel](#bosss.foundation.grid.classic.griddata.parallel)


### Field: BoSSS.Foundation.Grid.Classic.GridData.m_BcCells_tmp <a id="bosss.foundation.grid.classic.griddata.m_bccells_tmp"></a>
**Summary:** Temporary boundary condition cells during setup; 
This dictionary (should) contain all boundary-condition cells
which are required on the current MPI process.
- key: global cell index of the boundary-condition cell. 
- value: the boundary-condition cell.

## Class: BoSSS.Foundation.Grid.Classic.GridData.Helper <a id="bosss.foundation.grid.classic.griddata.helper"></a>


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetRefElementSubGrid(System.Int32) <a id="bosss.foundation.grid.classic.griddata.getrefelementsubgrid(system.int32)"></a>
**Summary:** Subgrid of all cells which share the same reference element.
**Parameter:** `iKref` - index into [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements).


### Property: BoSSS.Foundation.Grid.Classic.GridData.AffineLinearCells <a id="bosss.foundation.grid.classic.griddata.affinelinearcells"></a>
**Summary:** subgrid that contains only cells 
for which an affine-linear transformation to the reference element 
can be defined.


### Property: BoSSS.Foundation.Grid.Classic.GridData.NonlinearCells <a id="bosss.foundation.grid.classic.griddata.nonlinearcells"></a>
**Summary:** the complement of [BoSSS.Foundation.Grid.Classic.GridData.AffineLinearCells](#bosss.foundation.grid.classic.griddata.affinelinearcells).


### Property: BoSSS.Foundation.Grid.Classic.GridData.BoundaryEdges <a id="bosss.foundation.grid.classic.griddata.boundaryedges"></a>
**Summary:** a quadrature execution mask, for edges, which contains all
boundary edges, i.e. edges that bound only to one cell.


### Property: BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells <a id="bosss.foundation.grid.classic.griddata.boundarycells"></a>
**Summary:** subgrid that contains only cells which lie on the boundary


### Property: BoSSS.Foundation.Grid.Classic.GridData.InnerCells <a id="bosss.foundation.grid.classic.griddata.innercells"></a>
**Summary:** the complementary subgrid to [BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells)


### Property: BoSSS.Foundation.Grid.Classic.GridData.Subgrid4RefElement <a id="bosss.foundation.grid.classic.griddata.subgrid4refelement"></a>
**Summary:** for each cell type, the associated subgrid.
**Remark:**
In contrast to [BoSSS.Foundation.Grid.SubGrid](#bosss.foundation.grid.subgrid)-objects, [BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask)-objects have almost no 
MPI-collective operations (with some exceptions).


## Method: BoSSS.Foundation.Grid.Classic.GridData.DefineBoundaryMasks <a id="bosss.foundation.grid.classic.griddata.defineboundarymasks"></a>
**Summary:** initializes **BoSSS.Foundation.Grid.Classic.GridData.m_BoundaryCells**, **BoSSS.Foundation.Grid.Classic.GridData.m_BoundaryEdges**;


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellPartitioning <a id="bosss.foundation.grid.classic.griddata.cellpartitioning"></a>
**Summary:** Gets the partitioning of cells over the MPI processes;


## Method: BoSSS.Foundation.Grid.Classic.GridData.Initialize_LocalCellIndexToEdges <a id="bosss.foundation.grid.classic.griddata.initialize_localcellindextoedges"></a>


### Property: BoSSS.Foundation.Grid.Classic.GridData.SpatialDimension <a id="bosss.foundation.grid.classic.griddata.spatialdimension"></a>
**Summary:** The spatial dimension of the grid (usually 1, 2 or 3).


### Property: BoSSS.Foundation.Grid.Classic.GridData.CurrentGlobalIdPermutation <a id="bosss.foundation.grid.classic.griddata.currentglobalidpermutation"></a>
**Summary:** the current GlobalID-permutation;
Equal to [BoSSS.Foundation.Grid.Classic.GridCommons.GetGlobalIDPermutation(System.Boolean)](#bosss.foundation.grid.classic.gridcommons.getglobalidpermutation(system.boolean));


## Method: BoSSS.Foundation.Grid.Classic.GridData.CheckEdgeTagNames <a id="bosss.foundation.grid.classic.griddata.checkedgetagnames"></a>
**Summary:** checks edge tag names ([BoSSS.Foundation.Grid.Classic.GridCommons.EdgeTagNames](#bosss.foundation.grid.classic.gridcommons.edgetagnames)) for uniqueness


### Property: BoSSS.Foundation.Grid.Classic.GridData.LocalBoundingBox <a id="bosss.foundation.grid.classic.griddata.localboundingbox"></a>
**Summary:** The bounding box of this part of the grid, which is stored on the local MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.GlobalBoundingBox <a id="bosss.foundation.grid.classic.griddata.globalboundingbox"></a>
**Summary:** the bounding box of the entire grid.


## Method: BoSSS.Foundation.Grid.Classic.GridData._SetForeignPointer(System.IntPtr) <a id="bosss.foundation.grid.classic.griddata._setforeignpointer(system.intptr)"></a>
**Summary:** %


## Method: BoSSS.Foundation.Grid.Classic.GridData._GetForeignPointer <a id="bosss.foundation.grid.classic.griddata._getforeignpointer"></a>
**Summary:** %


## Method: BoSSS.Foundation.Grid.Classic.GridData.CopyWithNewBasis <a id="bosss.foundation.grid.classic.griddata.copywithnewbasis"></a>
**Summary:** Makes a shallow copy of the GridData object, except for the Chefbasis! 
This allows to use the same GridData for different basis functions.
**Returns:**



### Property: BoSSS.Foundation.Grid.Classic.GridData.ChefBasis <a id="bosss.foundation.grid.classic.griddata.chefbasis"></a>
**Summary:** see [BoSSS.Foundation.Grid.BasisData](#bosss.foundation.grid.basisdata)

## Class: BoSSS.Foundation.Grid.Classic.GridData._BasisData <a id="bosss.foundation.grid.classic.griddata._basisdata"></a>

**Summary:** common, heavy-weighted data for all [BoSSS.Foundation.Basis](#bosss.foundation.basis)-objects.


## Method: BoSSS.Foundation.Grid.Classic.GridData._BasisData.#ctor(BoSSS.Foundation.Grid.Classic.GridData) <a id="bosss.foundation.grid.classic.griddata._basisdata.#ctor(bosss.foundation.grid.classic.griddata)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.Grid.Classic.GridData._BasisData.Compute_OrthonormalizationTrafo(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.griddata._basisdata.compute_orthonormalizationtrafo(system.int32,system.int32,system.int32)"></a>
**Summary:** Orthonormalization for curved elements


### Field: BoSSS.Foundation.Grid.Classic.GridData.m_Cells <a id="bosss.foundation.grid.classic.griddata.m_cells"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridData.Cells](#bosss.foundation.grid.classic.griddata.cells)


### Property: BoSSS.Foundation.Grid.Classic.GridData.Cells <a id="bosss.foundation.grid.classic.griddata.cells"></a>
**Summary:** metrics and operations which are associated to one cell

## Class: BoSSS.Foundation.Grid.Classic.GridData.CellData <a id="bosss.foundation.grid.classic.griddata.celldata"></a>

**Summary:** all metrics which are associated to one cell


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.RefElements <a id="bosss.foundation.grid.classic.griddata.celldata.refelements"></a>
**Summary:** All reference elements for cells, see [BoSSS.Foundation.Grid.Classic.GridData.CellData.GetRefElementIndex(System.Int32)](#bosss.foundation.grid.classic.griddata.celldata.getrefelementindex(system.int32)) resp. [BoSSS.Foundation.Grid.Classic.GridData.CellData.GetRefElement(System.Int32)](#bosss.foundation.grid.classic.griddata.celldata.getrefelement(system.int32)).


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCells4Refelement(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getcells4refelement(system.int32)"></a>
**Summary:** Cell-Mask of all cells which share the same reference element.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCells4Refelement(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.classic.griddata.celldata.getcells4refelement(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Cell-Mask of all cells which share the same reference element.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.#ctor(BoSSS.Foundation.Grid.Classic.GridData) <a id="bosss.foundation.grid.classic.griddata.celldata.#ctor(bosss.foundation.grid.classic.griddata)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.ContainsNonlinearCell <a id="bosss.foundation.grid.classic.griddata.celldata.containsnonlinearcell"></a>
**Summary:** true, if there is any nonlinear cell on the current MPI process
**Returns:**



### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.m_owner <a id="bosss.foundation.grid.classic.griddata.celldata.m_owner"></a>
**Summary:** pointer to owner object


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours <a id="bosss.foundation.grid.classic.griddata.celldata.cellneighbours"></a>
**Summary:** local indices of neighbor cells;
- 1st index: local cell index;
- 2nd index: enumeration


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours_global_tmp <a id="bosss.foundation.grid.classic.griddata.celldata.cellneighbours_global_tmp"></a>
**Summary:** global indices of cell neighbors;


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.IsInCell(System.Double[],System.Int32,System.Double[]) <a id="bosss.foundation.grid.classic.griddata.celldata.isincell(system.double[],system.int32,system.double[])"></a>
**Summary:** true if point 'pt' is inside cell 'j'


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.AllocHelper(System.Double[]@,System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.allochelper(system.double[]@,system.int32)"></a>
**Summary:** Helper for safely allocating a wrapped double array.
**Parameter:** `pt_Loc` - 
**Parameter:** `D` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.ClosestPointInCell(System.Double[],System.Int32,System.Double[],System.Double[],System.Double[]) <a id="bosss.foundation.grid.classic.griddata.celldata.closestpointincell(system.double[],system.int32,system.double[],system.double[],system.double[])"></a>
**Summary:** Computes, for point 'pt', the closest point on
the boundary of cell 'j'.
**Parameter:** `j` - local cell index
**Parameter:** `pt` - input; some point in global coordinates.
**Parameter:** `pt_Loc` - output, if unequal null: 'pt' in local
coordinates of cell 'j'.
**Parameter:** `closestPoint_global` - output, if unequal null: within the boundary of cell
'j', the closest point to
'pt'.
**Parameter:** `closestPoint_local` - output, if unequal null: 'closestPoint_global'
in global coordinates.
**Returns:**
the distance.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetRefElementIndex(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getrefelementindex(system.int32)"></a>
**Summary:** returns the cell type index (index into [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)).
**Parameter:** `j` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetRefElement(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getrefelement(system.int32)"></a>
**Summary:** returns the reference element for cell 'j'


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetInterpolationDegree(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getinterpolationdegree(system.int32)"></a>
**Summary:** polynomial interpolation degree of the Reference-to-Global coordinate transformation.
**Parameter:** `jCell` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.Init <a id="bosss.foundation.grid.classic.griddata.celldata.init"></a>
**Summary:** another init ....


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.InfoFlags <a id="bosss.foundation.grid.classic.griddata.celldata.infoflags"></a>
**Summary:** see [BoSSS.Foundation.Grid.CellInfo](#bosss.foundation.grid.cellinfo)


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetNoOfSimilarConsecutiveCells(BoSSS.Foundation.Grid.CellInfo,System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getnoofsimilarconsecutivecells(bosss.foundation.grid.cellinfo,system.int32,system.int32)"></a>
**Summary:** Aids the vectorization of various code parts.
**Parameter:** `mask` - masks which properties of the cell information (see
[BoSSS.Foundation.Grid.Classic.GridData.CellData.InfoFlags](#bosss.foundation.grid.classic.griddata.celldata.infoflags)) should be considered.
**Parameter:** `j0` - start index.
**Parameter:** `Lmax` - upper limit for the return value of this function
**Returns:**
the number of consecutive cells after cell
'j0', which share the same information flags,
or 'Lmax', whichever is lower.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.IsCellAffineLinear(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.iscellaffinelinear(system.int32)"></a>
**Summary:** true if cell 'j' is affine-linear.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.JacobiDet <a id="bosss.foundation.grid.classic.griddata.celldata.jacobidet"></a>
**Summary:** For affine-linear cells,
the absolute value of the (Jacobi) determinant of the 
transformation from local cell coordinate system to global
coordinate system.
(see **BoSSS.Foundation.Grid.Classic.GridData.EvaluateJacobian(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)**
1st index: local cell index;


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.h_min <a id="bosss.foundation.grid.classic.griddata.celldata.h_min"></a>
**Summary:** The minimal Euclidean distance between two vertices for each cell;
(Can be used to compute the CFL number);
1st index: local cell index;


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.m_h_minGlobal <a id="bosss.foundation.grid.classic.griddata.celldata.m_h_minglobal"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_minGlobal](#bosss.foundation.grid.classic.griddata.celldata.h_minglobal)


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.h_minGlobal <a id="bosss.foundation.grid.classic.griddata.celldata.h_minglobal"></a>
**Summary:** Minimum over all entries in [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_min](#bosss.foundation.grid.classic.griddata.celldata.h_min), over all MPI processes.
processes


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.m_h_maxGlobal <a id="bosss.foundation.grid.classic.griddata.celldata.m_h_maxglobal"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_minGlobal](#bosss.foundation.grid.classic.griddata.celldata.h_minglobal)


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.h_maxGlobal <a id="bosss.foundation.grid.classic.griddata.celldata.h_maxglobal"></a>
**Summary:** Maximum over all entries in [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_max](#bosss.foundation.grid.classic.griddata.celldata.h_max), over all MPI processes.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.h_max <a id="bosss.foundation.grid.classic.griddata.celldata.h_max"></a>
**Summary:** The maximal Euclidean distance between two vertices for each cell;
(Can be used to compute the CFL number);
1st index: local cell index;


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellSurfaceArea <a id="bosss.foundation.grid.classic.griddata.celldata.cellsurfacearea"></a>
**Summary:** the ([BoSSS.Foundation.Grid.Classic.GridData.SpatialDimension](#bosss.foundation.grid.classic.griddata.spatialdimension)-1) - dimensional measure of
the cell boundary;
- index: local cell index;


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.cj <a id="bosss.foundation.grid.classic.griddata.celldata.cj"></a>
**Summary:** An inverse length scale (dimension is one-over-length, resp. area over volume)
for each cell j this is
\[
c_j = \frac{\textrm{Area}
(\partial K_j \setminus \partial \Omega) \cdot 0.5 + \textrm{Area
}
(\partial K_j \cap \partial \Omega)} {\textrm{ Volume} (K_j)}
\]
where $K_j$ is the cell an
$\Omega$ is the whole computational
domain.
**Remark:**
Needed for Interior Penalty method, for the Poisson equation  
penalty parameter according to:
An explicit expression for the penalty parameter of the
interior penalty method,
K. Shahbazi, J. of Comp. Phys. 205 (2004) 401-407,
look at formula (7).


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellLengthScale <a id="bosss.foundation.grid.classic.griddata.celldata.celllengthscale"></a>
**Summary:** the inverse (one-over) of [BoSSS.Foundation.Grid.Classic.GridData.CellData.cj](#bosss.foundation.grid.classic.griddata.celldata.cj);


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.PenaltyLengthScales <a id="bosss.foundation.grid.classic.griddata.celldata.penaltylengthscales"></a>
**Summary:** Alias for cj


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCellVolume(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getcellvolume(system.int32)"></a>
**Summary:** Returns the volume (to be more exact: the
[BoSSS.Foundation.Grid.Classic.GridData.SpatialDimension](#bosss.foundation.grid.classic.griddata.spatialdimension) - dimensional measure) of the
cell 'j';
**Parameter:** `j` - local cell index
**Returns:**



### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellVertices <a id="bosss.foundation.grid.classic.griddata.celldata.cellvertices"></a>
**Summary:** Mapping from cells to vertices/nodes of the grid (stored in
[BoSSS.Foundation.Grid.IVertexData.Coordinates](#bosss.foundation.grid.ivertexdata.coordinates)) 
- content: indices into [BoSSS.Foundation.Grid.IVertexData.Coordinates](#bosss.foundation.grid.ivertexdata.coordinates) 
- 1st index: local cell index (externals included) 
- 2nd index: cell vertex index


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCellBoundingBox(System.Int32,BoSSS.Platform.Utils.Geom.BoundingBox) <a id="bosss.foundation.grid.classic.griddata.celldata.getcellboundingbox(system.int32,bosss.platform.utils.geom.boundingbox)"></a>
**Summary:** Computes the bounding box of cell 'j'.
**Parameter:** `j` - local cell index.
**Parameter:** `bb` - on exit, the bounding box of cell j.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.Transformation <a id="bosss.foundation.grid.classic.griddata.celldata.transformation"></a>
**Summary:** For all affine-linear cells, the 
linear part of the affine-linear transformation
from the local coordinate 
system of some cell to
the global coordinate system, or Jacobi-matrix.
**Remark:**
Indices are defined as follows:

1st index: local cell index (locally updated and external cells);
2nd index: matrix row index;
3rd index: matrix column index;


### Field: BoSSS.Foundation.Grid.Classic.GridData.CellData.CellCenter <a id="bosss.foundation.grid.classic.griddata.celldata.cellcenter"></a>
**Summary:** For all affine-linear cells, the 
affine part of the affine-linear transformation
from the local coordinate 
system of some cell to
the global coordinate system, or the cell-center.
**Remark:**
Indices are defined as follows:

1st index: local cell index (locally updated and external cells);
2nd index: spatial dimension


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.InverseTransformation <a id="bosss.foundation.grid.classic.griddata.celldata.inversetransformation"></a>
**Summary:** inverse matrices to [BoSSS.Foundation.Grid.Classic.GridData.CellData.Transformation](#bosss.foundation.grid.classic.griddata.celldata.transformation)
**Remark:**
Indices are defined as follows:

1st index: local cell index (locally updated and external cells);
2nd index: matrix row index;
3rd index: matrix column index;


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.InitializeCk <a id="bosss.foundation.grid.classic.griddata.celldata.initializeck"></a>
**Summary:** initializes [BoSSS.Foundation.Grid.Classic.GridData.CellData.cj](#bosss.foundation.grid.classic.griddata.celldata.cj)


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.InitializeCellSurfaceArea <a id="bosss.foundation.grid.classic.griddata.celldata.initializecellsurfacearea"></a>
**Summary:** initializes [BoSSS.Foundation.Grid.Classic.GridData.CellData.CellSurfaceArea](#bosss.foundation.grid.classic.griddata.celldata.cellsurfacearea)


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfLocalUpdatedCells <a id="bosss.foundation.grid.classic.griddata.celldata.nooflocalupdatedcells"></a>
**Summary:** Number of locally updated cells - the cells which are computed on
this processor (in contrast, see [BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfExternalCells](#bosss.foundation.grid.classic.griddata.celldata.noofexternalcells));


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfExternalCells <a id="bosss.foundation.grid.classic.griddata.celldata.noofexternalcells"></a>
**Summary:** Number of locally stored external cells - no computations are carried out for
that cells, but their values are needed.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.Count <a id="bosss.foundation.grid.classic.griddata.celldata.count"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfExternalCells](#bosss.foundation.grid.classic.griddata.celldata.noofexternalcells) plus [BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.classic.griddata.celldata.nooflocalupdatedcells);


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCell(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getcell(system.int32)"></a>
**Summary:** returns the [BoSSS.Foundation.Grid.Classic.Cell](#bosss.foundation.grid.classic.cell)-object for a cell index 'j',
**Parameter:** `j` - local cell index, (can also be in the range of external/ghost cells)


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCellType(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getcelltype(system.int32)"></a>
**Summary:** Cell type for cell 'j'.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.Initialize_h <a id="bosss.foundation.grid.classic.griddata.celldata.initialize_h"></a>
**Summary:** fills [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_min](#bosss.foundation.grid.classic.griddata.celldata.h_min), [BoSSS.Foundation.Grid.Classic.GridData.CellData.h_max](#bosss.foundation.grid.classic.griddata.celldata.h_max);


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetGlobalID(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getglobalid(system.int32)"></a>
**Summary:** As defined by **BoSSS.Foundation.Grid.Classic.GridData.iLogicalCells**, the Global Id for the 'j'-th cell.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CellData.GetCenter(System.Int32) <a id="bosss.foundation.grid.classic.griddata.celldata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.Cells2Edges <a id="bosss.foundation.grid.classic.griddata.celldata.cells2edges"></a>
**Summary:** Which edges (see [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices)) bound to
which cells? 
- 1st index: local cell index j, only local updated
- 2nd index: collection, order is arbitrary;
- content e: 
If e is positive, then cell j is the first
(IN) cell of edge e - 1. Otherwise, if e is
negative, then cell j is the second (OUT) cell of edge
-e - 1.
**Remark:**
Note: the second index does NOT correlate with the face index
of the cell. This is because, in the case of hanging nodes, the
number of edges that bound to one cell is not equal to the
number of faces, i.e., more than one edge is associated with
one face.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.AggregateCellToParts <a id="bosss.foundation.grid.classic.griddata.celldata.aggregatecelltoparts"></a>
**Summary:** Since each cell is already elementary (i.e. it maps to one reference element)
this is not required and therefore, equal to null.


### Property: BoSSS.Foundation.Grid.Classic.GridData.CellData.GeomCell2LogicalCell <a id="bosss.foundation.grid.classic.griddata.celldata.geomcell2logicalcell"></a>
**Summary:** null for the classical grid


### Field: BoSSS.Foundation.Grid.Classic.GridData.m_Edges <a id="bosss.foundation.grid.classic.griddata.m_edges"></a>
**Summary:** See [BoSSS.Foundation.Grid.Classic.GridData.Edges](#bosss.foundation.grid.classic.griddata.edges)


### Property: BoSSS.Foundation.Grid.Classic.GridData.Edges <a id="bosss.foundation.grid.classic.griddata.edges"></a>
**Summary:** metrics and operations which are associated to edges


### Property: BoSSS.Foundation.Grid.Classic.GridData.iGeomEdges <a id="bosss.foundation.grid.classic.griddata.igeomedges"></a>
**Summary:** metrics and operations which are associated to edges


### Property: BoSSS.Foundation.Grid.Classic.GridData.iLogicalEdges <a id="bosss.foundation.grid.classic.griddata.ilogicaledges"></a>
**Summary:** metrics and operations which are associated to edges

## Class: BoSSS.Foundation.Grid.Classic.GridData.EdgeData <a id="bosss.foundation.grid.classic.griddata.edgedata"></a>

**Summary:** metrics and operations which are associated to edges


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.#ctor(BoSSS.Foundation.Grid.Classic.GridData) <a id="bosss.foundation.grid.classic.griddata.edgedata.#ctor(bosss.foundation.grid.classic.griddata)"></a>
**Summary:** ctor


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_Edges4RefElement <a id="bosss.foundation.grid.classic.griddata.edgedata.m_edges4refelement"></a>
**Summary:** See [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetEdges4RefElement(BoSSS.Foundation.Grid.RefElements.RefElement)](#bosss.foundation.grid.classic.griddata.edgedata.getedges4refelement(bosss.foundation.grid.refelements.refelement))


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetEdges4RefElement(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.classic.griddata.edgedata.getedges4refelement(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** For each (edge) reference element, this method provides a
mask containing all cells which are mapped from the specific
reference element.
**Parameter:** `Kref` - Reference element for edges.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeRefElements <a id="bosss.foundation.grid.classic.griddata.edgedata.edgerefelements"></a>
**Summary:** Reference elements for edges.


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_owner <a id="bosss.foundation.grid.classic.griddata.edgedata.m_owner"></a>
**Summary:** pointer to owner object


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.h_min_Edge <a id="bosss.foundation.grid.classic.griddata.edgedata.h_min_edge"></a>
**Summary:** the minimal Euclidean distance between two vertices for each
edge; (Can be used to compute the CFL number);
1st index: local edge index;


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.h_max_Edge <a id="bosss.foundation.grid.classic.griddata.edgedata.h_max_edge"></a>
**Summary:** the maximal Euclidean distance between two vertices for each edge;
(Can be used to compute the CFL number);
1st index: local edge index;


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.SqrtGramian <a id="bosss.foundation.grid.classic.griddata.edgedata.sqrtgramian"></a>
**Summary:** For each edge that is affine-linear (i.e. [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Info](#bosss.foundation.grid.classic.griddata.edgedata.info)[e]
& [BoSSS.Foundation.Grid.EdgeInfo.EdgeIsAffineLinear](#bosss.foundation.grid.edgeinfo.edgeisaffinelinear) != 0), the
square root of the Gram determinant; NaN for nonlinear edges.
1st index: local edge index;
**Remark:**
Let be 
\f[ 
\mathbb{R}^{D-1} 
\ni \vec{\xi} 
\mapsto
\gamma(\vec{\xi}) \in
\mathbb{R}^{D-1}
\f]
the mapping from the edge coordinate system to the physical coordinate system.
Then the integral of $f$  over the edge 
$\gamma(K_\textrm{ref})$ 
is given as 
\f[ 
\int_{\vec{x} \in \gamma(K_\textrm{ref})} f(\vec{x}) \ \textrm{dS}
=
\int_{\xi \in K_\textrm{ref}} f(\gamma(\xi)) g(\vec{\xi}) \ \textrm{d} \vec{\xi}
\f]
with the square-root of the Gram determinant
\f[ 
g(\vec{xi}) = \sqrt{ 
\textrm{det} ( (\partial \gamma)^T \cdot (\partial \gamma) )  
}.
\f]
If the transformation 
$\gamma$
of the edge to the global coordinate system 
is affine-linear, the Jacobian 
$\partial \gamma$
is constant and 
$g$
can be precomputed.
(see Analysis 2, Knigsberger, Springer-Verlag 2000, pp. 343)


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.IsEdgeAffineLinear(System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.isedgeaffinelinear(system.int32)"></a>
**Summary:** true, if edge 'e' is affine-linear, false if
not


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetEdgeArea(System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.getedgearea(system.int32)"></a>
**Summary:** returns the area (to be more exact: the (D-1) - dimensional
measure) of the edge 'e';
**Parameter:** `e` - local edge index
**Returns:**



## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetCenter(System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity for the edge


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_NoOfBoundaryEdges <a id="bosss.foundation.grid.classic.griddata.edgedata.m_noofboundaryedges"></a>
**Summary:** [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfBoundaryEdges](#bosss.foundation.grid.classic.griddata.edgedata.noofboundaryedges);


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfBoundaryEdges <a id="bosss.foundation.grid.classic.griddata.edgedata.noofboundaryedges"></a>
**Summary:** Number of edges which lie on the boundary of the physical
domain i.e. edges which bound to only one cell. This are all
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices) from index 0 to this value -1.
All edges at higher indices bound to two cells.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfInternalEdges <a id="bosss.foundation.grid.classic.griddata.edgedata.noofinternaledges"></a>
**Summary:** internal edges are all edges which do not lie on an external
cell; All [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices) from index 0 to this value
are internal, edges at higher indices lie on the inter-process
border.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Count <a id="bosss.foundation.grid.classic.griddata.edgedata.count"></a>
**Summary:** total number of all edges handled on this processor;

## Class: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.ComputeEdgesHelper <a id="bosss.foundation.grid.classic.griddata.edgedata.computeedgeshelper"></a>

**Summary:** helper structure used in [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CollectEdges](#bosss.foundation.grid.classic.griddata.edgedata.collectedges);


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetRefElementIndex(System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.getrefelementindex(system.int32)"></a>
**Summary:** For edge number 'e', the index into
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeRefElements](#bosss.foundation.grid.classic.griddata.edgedata.edgerefelements).


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetRefElement(System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.getrefelement(system.int32)"></a>
**Summary:** For edge number 'e', the respective reference element.


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_EdgesTmp <a id="bosss.foundation.grid.classic.griddata.edgedata.m_edgestmp"></a>
**Summary:** Temporary edge data structure during assembly process.


### Field: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_CellsToEdgesTmp <a id="bosss.foundation.grid.classic.griddata.edgedata.m_cellstoedgestmp"></a>
**Summary:** temporary data structure during assembly process;
1st index: local cell index j;
2nd index: collection
content: CellsToEdges[j,0] to CellsToEdges[j,N] are the N+1
edges that bound to cell j.


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CollectEdges <a id="bosss.foundation.grid.classic.griddata.edgedata.collectedges"></a>
**Summary:** this method initializes the [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices),
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FaceIndices](#bosss.foundation.grid.classic.griddata.edgedata.faceindices), [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NormalsForAffine](#bosss.foundation.grid.classic.griddata.edgedata.normalsforaffine) and
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeTags](#bosss.foundation.grid.classic.griddata.edgedata.edgetags) arrays (from simpler/more
straightforward data structures).


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.e2C_offet <a id="bosss.foundation.grid.classic.griddata.edgedata.e2c_offet"></a>
**Summary:** Some hack, used by [BoSSS.Foundation.NodeSet.GetVolumeNodeSet(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Boolean)](#bosss.foundation.nodeset.getvolumenodeset(bosss.foundation.grid.igriddata,system.int32,system.boolean)); 
only effective (un-equal 0), if more than one grid is used in the application.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos <a id="bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos"></a>
**Summary:** Transformations from edge coordinate system to local cell
coordinate systems.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos_SqrtGramian <a id="bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos_sqrtgramian"></a>
**Summary:** Square-root of the Gramian determinat for each transformation in [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos](#bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos), i.e.
if $\myMatrix{M}$ 
is the matrix of the transformation, this number is 
$\sqrt{ \operatorname{det} ( \myMatrix{M}^T \cdot \myMatrix{M} ) }$.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafosRefElementIndices <a id="bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafosrefelementindices"></a>
**Summary:** For each edge-to-cell transformation, see [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos](#bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos),
the index of the cell reference element, i.e. an index into [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeRefElements](#bosss.foundation.grid.classic.griddata.edgedata.edgerefelements).


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FaceIntersect(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,BoSSS.Platform.LinAlg.AffineTrafo,BoSSS.Platform.LinAlg.AffineTrafo,ilPSP.MultidimensionalArray[],System.Boolean@,System.Boolean@,BoSSS.Platform.LinAlg.AffineTrafo@,System.Int32@) <a id="bosss.foundation.grid.classic.griddata.edgedata.faceintersect(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,bosss.platform.linalg.affinetrafo,bosss.platform.linalg.affinetrafo,ilpsp.multidimensionalarray[],system.boolean@,system.boolean@,bosss.platform.linalg.affinetrafo@,system.int32@)"></a>
**Summary:** Geometric intersection of non-conformal edges.
**Parameter:** `VtxFace1` - vertices of one face of the first cell (face 1)
**Parameter:** `VtxFace2` - vertices of one face of the second cell (face 2)
**Parameter:** `TrafoEdge` - transformation from face 1 to the reference coordinate system
of cell 1
**Parameter:** `InvTrafoEdge` - inverse of 'TrafoEdge'
**Parameter:** `conformal1` - true, if face 1 is fully enclosed by face  2
**Parameter:** `conformal2` - true, if face 2 is fully enclosed by face 1
**Parameter:** `NewTrafo` - transformation from the intersection of both faces to the 
reference coordinate system (in which
'VtxFace1' and 'VtxFace2'
are defined).
**Parameter:** `EdgeRefElementIndex` - on exit, the index of the reference element for the edge,
i.e. index into [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeRefElements](#bosss.foundation.grid.classic.griddata.edgedata.edgerefelements).
**Parameter:** `VerticesFor_KrefEdge` - How many vertices the i-th edge element have?
**Returns:**
true, if the intersection of face 1 and 2 is non-empty.


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.PolygonalIntersect(System.Collections.Generic.List{ilPSP.Vector},System.Collections.Generic.List{ilPSP.Vector}) <a id="bosss.foundation.grid.classic.griddata.edgedata.polygonalintersect(system.collections.generic.list{ilpsp.vector},system.collections.generic.list{ilpsp.vector})"></a>
**Summary:** intersection of two polygons
**Parameter:** `first_polygon` - 
**Parameter:** `second_polygon` - 
**Returns:**
- the intersection 
- a boolean which indicates if the intersection is identical to the 'second_polygon'


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.SpanArea(System.Collections.Generic.List{ilPSP.Vector},System.String) <a id="bosss.foundation.grid.classic.griddata.edgedata.spanarea(system.collections.generic.list{ilpsp.vector},system.string)"></a>
**Summary:** Area of the parallelogram spanned by a polygons first and last edge


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CheckFace(ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.classic.griddata.edgedata.checkface(ilpsp.multidimensionalarray)"></a>
**Summary:** Ensures that that in the 3D case -- i.e. when faces are 2D objects -- that vertices of an edge are in counter-clockwise sequence.  (or maybe clock-wise?)


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.SetEdgeTags <a id="bosss.foundation.grid.classic.griddata.edgedata.setedgetags"></a>
**Summary:** sets, for each entry in [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.m_EdgesTmp](#bosss.foundation.grid.classic.griddata.edgedata.m_edgestmp), it sets
**BoSSS.Foundation.Grid.Classic.GridData.EdgeData.ComputeEdgesHelper.EdgeTag**;


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CollectBoundaryEdges <a id="bosss.foundation.grid.classic.griddata.edgedata.collectboundaryedges"></a>
**Summary:** finds all boundary edges


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NegogiateNeighbourship <a id="bosss.foundation.grid.classic.griddata.edgedata.negogiateneighbourship"></a>
**Summary:** sharing of edges between processors;
mainly required for the spectral element framework (continuous Galerkin) where an owner for each edge must be assigned


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfPurelyLocal <a id="bosss.foundation.grid.classic.griddata.edgedata.noofpurelylocal"></a>
**Summary:** Number of edges which are used only by locally updated cells
and do not bound to any cell which is exchanged over MPI;


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfRelayed <a id="bosss.foundation.grid.classic.griddata.edgedata.noofrelayed"></a>
**Summary:** Number of shared edges (between by locally updated cells and
external cells) which are 'owned' by the current MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfOwned <a id="bosss.foundation.grid.classic.griddata.edgedata.noofowned"></a>
**Summary:** Number of edges 
which are 'owned' by the current MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NoOfBorrowed <a id="bosss.foundation.grid.classic.griddata.edgedata.noofborrowed"></a>
**Summary:** Number of shared edges (between by locally updated cells and
external cells) which are 'owned' by other MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeSendLists <a id="bosss.foundation.grid.classic.griddata.edgedata.edgesendlists"></a>
**Summary:** content: which of the shared/foreign edges must be send to
other processors
- 1st index: MPI rank of target processor 'R' 
- 2nd index: enumeration


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeInsertLists <a id="bosss.foundation.grid.classic.griddata.edgedata.edgeinsertlists"></a>
**Summary:** content: where the shared/foreign edges received by other
processors must be inserted 
1st index: MPI rank of target processor 'R' 
2nd index: enumeration


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FinalizeAssembly <a id="bosss.foundation.grid.classic.griddata.edgedata.finalizeassembly"></a>
**Summary:** converts temporary data structures in permanent ones


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.InitCells2Edges <a id="bosss.foundation.grid.classic.griddata.edgedata.initcells2edges"></a>
**Summary:** initializes [BoSSS.Foundation.Grid.Classic.GridData.CellData.Cells2Edges](#bosss.foundation.grid.classic.griddata.celldata.cells2edges);


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NormalsForAffine <a id="bosss.foundation.grid.classic.griddata.edgedata.normalsforaffine"></a>
**Summary:** Normals for all affine-linear edges
- 1st index: edge index
- 2nd index: spatial direction


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NormalsCache <a id="bosss.foundation.grid.classic.griddata.edgedata.normalscache"></a>
**Summary:** Cached normals at nodes.


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetNormalsForCell(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.classic.griddata.edgedata.getnormalsforcell(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** Computes the normals on face 'iFace' in the
volume coordinate system of a given cell
'jCell' at the given 'Nodes'
and writes the result into 'NormalsOut'
**Parameter:** `jCell` - Cell index
**Parameter:** `iFace` - Face index
**Parameter:** `Nodes` - Evaluation nodes

1st index: Node index
2nd index: Spatial dimension
**Parameter:** `NormalsOut` -
1st index: cell index
2nd index: Node index
3rd index: Spatial dimension
**Parameter:** `QuadMetric` - A by-product: the integral transformation metric.
**Parameter:** `Offset` - An offset into the first entry of 'NormalsOut' and 'QuadMetric'.


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.ComputeSqrtGramian <a id="bosss.foundation.grid.classic.griddata.edgedata.computesqrtgramian"></a>
**Summary:** computes [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.SqrtGramian](#bosss.foundation.grid.classic.griddata.edgedata.sqrtgramian)


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafoIndex <a id="bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafoindex"></a>
**Summary:** Edge-to-Cell - transformation index, i.e. index into [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos](#bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos);
- 1st index: local edge index;
- 2nd index: 0,1 first and second neighbor;


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices <a id="bosss.foundation.grid.classic.griddata.edgedata.cellindices"></a>
**Summary:** local cell indices of cells that belong to an edge;
- 1st index: local edge index
- 2nd index: 0,1 first and second neighbor;
**Remark:**
Example: Let be [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices)[i,0] = 123 and
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices)[i,1] = 321; Then edge i is located
on the intersection of (the closure of) cell 123 and cell 321;
A negative cell index indicates that an edge is only subset of
one cell (cells on the border of an domain). The negative cell
index is always stored at the 2nd entry.


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.LogicalCellIndices <a id="bosss.foundation.grid.classic.griddata.edgedata.logicalcellindices"></a>
**Summary:** Equal to [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices).


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FaceIndices <a id="bosss.foundation.grid.classic.griddata.edgedata.faceindices"></a>
**Summary:** Face index, where the numbering of faces is defined by the reference element, see e.g. [BoSSS.Foundation.Grid.RefElements.RefElement.FaceToVertexIndices](#bosss.foundation.grid.refelements.refelement.facetovertexindices).
- 1st index: local edge index; 
- 2nd index: 0 and 1 for first and second neighbor;
**Remark:**
Example: let be [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FaceIndices](#bosss.foundation.grid.classic.griddata.edgedata.faceindices)[i,0] = 1 and
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.FaceIndices](#bosss.foundation.grid.classic.griddata.edgedata.faceindices)[i,1] = 1 and
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices)[i,0] = 123 and
[BoSSS.Foundation.Grid.Classic.GridData.EdgeData.CellIndices](#bosss.foundation.grid.classic.griddata.edgedata.cellindices)[i,1] = 321; Then edge i is on the 1st
face of cell 123 and also on the 1st edge of cell 321; If edge
i lies on a border entry [i,1] is negative;


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeTags <a id="bosss.foundation.grid.classic.griddata.edgedata.edgetags"></a>
**Summary:** Edge Tags
index: local edge index;


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Info <a id="bosss.foundation.grid.classic.griddata.edgedata.info"></a>
**Summary:** additional edge information


### Property: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.EdgeToParts <a id="bosss.foundation.grid.classic.griddata.edgedata.edgetoparts"></a>
**Summary:** Not required for the classic grid; therefore, null.


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Initialize_h_Edge <a id="bosss.foundation.grid.classic.griddata.edgedata.initialize_h_edge"></a>
**Summary:** fills [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.h_min_Edge](#bosss.foundation.grid.classic.griddata.edgedata.h_min_edge);


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.InitNormals <a id="bosss.foundation.grid.classic.griddata.edgedata.initnormals"></a>
**Summary:** sets [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.NormalsForAffine](#bosss.foundation.grid.classic.griddata.edgedata.normalsforaffine).


## Method: BoSSS.Foundation.Grid.Classic.GridData.EdgeData.GetPeriodicTrafo(System.Int32,System.Boolean) <a id="bosss.foundation.grid.classic.griddata.edgedata.getperiodictrafo(system.int32,system.boolean)"></a>
**Summary:** Returns the periodic transformation for edge 'iEdge'.
**Parameter:** `iEdge` - 
**Parameter:** `InToOut` - If true, the transformation from the in- to the out-cell, if false the other way around.
**Returns:**



### Field: BoSSS.Foundation.Grid.Classic.GridData.m_Parallel <a id="bosss.foundation.grid.classic.griddata.m_parallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridData.Parallelization](#bosss.foundation.grid.classic.griddata.parallelization)


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallel <a id="bosss.foundation.grid.classic.griddata.parallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridData.Parallelization](#bosss.foundation.grid.classic.griddata.parallelization)


### Property: BoSSS.Foundation.Grid.Classic.GridData.iParallel <a id="bosss.foundation.grid.classic.griddata.iparallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.Classic.GridData.Parallelization](#bosss.foundation.grid.classic.griddata.parallelization)

## Class: BoSSS.Foundation.Grid.Classic.GridData.Parallelization <a id="bosss.foundation.grid.classic.griddata.parallelization"></a>

**Summary:** Contains information for MPI parallelization.


## Method: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.classic.griddata.parallelization.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** ctor


### Field: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.m_owner <a id="bosss.foundation.grid.classic.griddata.parallelization.m_owner"></a>
**Summary:** pointer to owner object


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.Global2LocalIdx <a id="bosss.foundation.grid.classic.griddata.parallelization.global2localidx"></a>
**Summary:** Conversion of global cell indices to local cell indices, 
i.e. the inverse of [BoSSS.Foundation.Grid.Classic.GridData.Parallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.classic.griddata.parallelization.globalindicesexternalcells). 
- keys: global indices of external/ghost cells 
- values: local indices of external/ghost cells


## Method: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.GetLocalCellIndex(System.Int64) <a id="bosss.foundation.grid.classic.griddata.parallelization.getlocalcellindex(system.int64)"></a>
**Summary:** Conversion of global cell indices to local cell indices
**Parameter:** `globalCellIndex` - 
**Remark:**
The conversion can only be done for cells which are stored on
this MPI process;


## Method: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.GetGlobalCellIndex(System.Int32) <a id="bosss.foundation.grid.classic.griddata.parallelization.getglobalcellindex(system.int32)"></a>
**Summary:** conversion of local cell indices to global ones
**Parameter:** `jCellLocal` - A local cell index; the valid range includes external/ghost
cells, i.e. the highest admissible number is
[BoSSS.Foundation.Grid.Classic.GridData.CellData.Count](#bosss.foundation.grid.classic.griddata.celldata.count)-1.
**Returns:**



### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.GlobalIndicesExternalCells <a id="bosss.foundation.grid.classic.griddata.parallelization.globalindicesexternalcells"></a>
**Summary:** Global indices of external cells (local indices j in the range
[BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.classic.griddata.celldata.nooflocalupdatedcells) <= j <
[BoSSS.Foundation.Grid.Classic.GridData.CellData.Count](#bosss.foundation.grid.classic.griddata.celldata.count)); Note that there is an index
offset, so the entry at index 0 is the global index of cell at
local index [BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.classic.griddata.celldata.nooflocalupdatedcells);
See also [BoSSS.Foundation.Grid.Classic.GridData.Parallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.classic.griddata.parallelization.globalindicesexternalcells);


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.SendCommLists <a id="bosss.foundation.grid.classic.griddata.parallelization.sendcommlists"></a>
**Summary:** local cell indices (only border cells) which must be send to
other processors; for each processor, the communication list is
stored in ascending order.
**Remark:**
- 1st index: target processor; if the 'p'-th entry is null, there
is no communication with processor 'p'
- 2nd index: enumeration, no special interpretation;


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.RcvCommListsInsertIndex <a id="bosss.foundation.grid.classic.griddata.parallelization.rcvcommlistsinsertindex"></a>
**Summary:** for each process, a local cell index at which items received
from other processes should be inserted;
index: MPI process rank of process from which data is received;


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.RcvCommListsNoOfItems <a id="bosss.foundation.grid.classic.griddata.parallelization.rcvcommlistsnoofitems"></a>
**Summary:** for each process, the number of cells that are received from
this process
index: MPI process rank of process from which data is received;


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.ProcessesToSendTo <a id="bosss.foundation.grid.classic.griddata.parallelization.processestosendto"></a>
**Summary:** list of processes (MPI ranks) which receive data from this process
- index: enumeration
- content: MPI process rank


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.ProcessesToReceiveFrom <a id="bosss.foundation.grid.classic.griddata.parallelization.processestoreceivefrom"></a>
**Summary:** List of processes (MPI ranks) which send data to this process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.Parallelization.ExternalCells <a id="bosss.foundation.grid.classic.griddata.parallelization.externalcells"></a>
**Summary:** data of external cells


## Method: BoSSS.Foundation.Grid.Classic.GridData.Adapt(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32[]},BoSSS.Foundation.Grid.Classic.GridCorrelation@) <a id="bosss.foundation.grid.classic.griddata.adapt(system.collections.generic.ienumerable{system.int32},system.collections.generic.ienumerable{system.int32[]},bosss.foundation.grid.classic.gridcorrelation@)"></a>
**Summary:** Creates a new grid, which is an adaptive refinement (cell by cell) of this grid.
**Parameter:** `cellsToRefine` - All cells to be refined (local indices)
**Parameter:** `cellsToCoarse` - All coarsening clusters with their related cells;
**Parameter:** `Old2New` - The correlation between the old and the new grid.


## Method: BoSSS.Foundation.Grid.Classic.GridData.CheckForDoubleEntryInEnumeration(System.Collections.Generic.IEnumerable{System.Int32}) <a id="bosss.foundation.grid.classic.griddata.checkfordoubleentryinenumeration(system.collections.generic.ienumerable{system.int32})"></a>
**Parameter:** `enumeration` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetLocalAndExternalNeighbourCells(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.BitArray@) <a id="bosss.foundation.grid.classic.griddata.getlocalandexternalneighbourcells(system.collections.generic.ienumerable{system.int32},system.collections.bitarray@)"></a>
**Parameter:** `cellsToRefine` - 
**Parameter:** `AdaptNeighborsBitmask` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetLocalAndExternalNeighbourCells(System.Collections.Generic.IEnumerable{System.Int32[]},System.Collections.BitArray@) <a id="bosss.foundation.grid.classic.griddata.getlocalandexternalneighbourcells(system.collections.generic.ienumerable{system.int32[]},system.collections.bitarray@)"></a>
**Parameter:** `coarseningClusters` - 
**Parameter:** `AdaptNeighborsBitmask` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.IsPartOfLocalCells(System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.griddata.ispartoflocalcells(system.int32,system.int32)"></a>
**Summary:** Checks whether a certain cell is part of the local cells
**Parameter:** `noOfLocalCells` - 
**Parameter:** `currentCellIndex` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetAndExchangeExternalNeighbours(System.Collections.Generic.List{System.Int64}[],System.Collections.BitArray@) <a id="bosss.foundation.grid.classic.griddata.getandexchangeexternalneighbours(system.collections.generic.list{system.int64}[],system.collections.bitarray@)"></a>
**Summary:** Exchange method of the process boundary cells.
**Parameter:** `exchangeNeighbours` - 
**Parameter:** `AdaptNeighborsBitmask` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetCellBitMask(System.Collections.Generic.IEnumerable{System.Int32[]}) <a id="bosss.foundation.grid.classic.griddata.getcellbitmask(system.collections.generic.ienumerable{system.int32[]})"></a>
**Summary:** Creates a bit mask from the coarsening clusters
**Parameter:** `cellsToCoarsen` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetNewCoarseningClusterID(System.Collections.Generic.IEnumerable{System.Int32},BoSSS.Foundation.Grid.Classic.GridCommons) <a id="bosss.foundation.grid.classic.griddata.getnewcoarseningclusterid(system.collections.generic.ienumerable{system.int32},bosss.foundation.grid.classic.gridcommons)"></a>
**Summary:** Gets the new coarsening cluster id
**Parameter:** `cellsToRefine` - 
**Parameter:** `oldGrid` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.CheckForDoubleEntries(BoSSS.Foundation.Grid.Classic.GridCorrelation,BoSSS.Foundation.Grid.Classic.Cell[][],System.Int32) <a id="bosss.foundation.grid.classic.griddata.checkfordoubleentries(bosss.foundation.grid.classic.gridcorrelation,bosss.foundation.grid.classic.cell[][],system.int32)"></a>
**Summary:** Checks whether a cell was already refined
**Parameter:** `Old2New` - 
**Parameter:** `adaptedCells` -
- 1st index: cell index of current mesh
- 2nd index: enumeration of subdivisions
**Parameter:** `j` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.CreateRefinedCell(System.Int64@,System.Int64,System.Int32,BoSSS.Foundation.Grid.Classic.Cell,BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode[],System.Int32) <a id="bosss.foundation.grid.classic.griddata.createrefinedcell(system.int64@,system.int64,system.int32,bosss.foundation.grid.classic.cell,bosss.foundation.grid.refelements.refelement.subdivisiontreenode[],system.int32)"></a>
**Summary:** Creates a new refined cell
**Parameter:** `GlobalIdCounter` - 
**Parameter:** `globalIDOffset` - 
**Parameter:** `NewCoarseningClusterId` - 
**Parameter:** `oldCell` - 
**Parameter:** `Leaves` - 
**Parameter:** `iSubDiv` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetNewNodesOfRefinedCells(System.Int32,BoSSS.Foundation.NodeSet,BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode[],System.Int32,BoSSS.Foundation.Grid.Classic.Cell) <a id="bosss.foundation.grid.classic.griddata.getnewnodesofrefinedcells(system.int32,bosss.foundation.nodeset,bosss.foundation.grid.refelements.refelement.subdivisiontreenode[],system.int32,bosss.foundation.grid.classic.cell)"></a>
**Summary:** Gets the nodes of the refined cell.
**Parameter:** `j` - 
**Parameter:** `RefNodes` - 
**Parameter:** `Leaves` - 
**Parameter:** `iSubDiv` - 
**Parameter:** `newCell` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetNodeIndicesOfRefinedCells(System.Int64,System.Int32,BoSSS.Foundation.Grid.Classic.Cell) <a id="bosss.foundation.grid.classic.griddata.getnodeindicesofrefinedcells(system.int64,system.int32,bosss.foundation.grid.classic.cell)"></a>
**Summary:** Gives the new cell the correct node indices's
**Parameter:** `newVertexCounter` - 
**Parameter:** `noOfVertices` - 
**Parameter:** `newCell` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetOldToNewCorrelation(BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode[]) <a id="bosss.foundation.grid.classic.griddata.getoldtonewcorrelation(bosss.foundation.grid.refelements.refelement.subdivisiontreenode[])"></a>
**Summary:** Correlates the new cells to the old.
**Parameter:** `Leaves` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.AdaptNeighbourshipWithinOldCell(System.Int32,System.Int32,System.ValueTuple{System.Int32,System.Int32}[0:,0:],BoSSS.Foundation.Grid.Classic.Cell[]) <a id="bosss.foundation.grid.classic.griddata.adaptneighbourshipwithinoldcell(system.int32,system.int32,system.valuetuple{system.int32,system.int32}[0:,0:],bosss.foundation.grid.classic.cell[])"></a>
**Summary:** Updates the neighbourship info between all new cells within a single old cell
**Parameter:** `noOfFaces` - 
**Parameter:** `noOfLeaves` - 
**Parameter:** `Connections` - 
**Parameter:** `refinedCells` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.CheckCoarseningCluster(System.Collections.Generic.IEnumerable{System.Int32[]},System.Collections.BitArray,System.Collections.BitArray,BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode[][]) <a id="bosss.foundation.grid.classic.griddata.checkcoarseningcluster(system.collections.generic.ienumerable{system.int32[]},system.collections.bitarray,system.collections.bitarray,bosss.foundation.grid.refelements.refelement.subdivisiontreenode[][])"></a>
**Summary:** Error check of the coaresening cluster.
**Parameter:** `CellsToCoarsen` - 
**Parameter:** `CellsToRefineBitmask` - 
**Parameter:** `CellsToCoarseBitmask` - 
**Parameter:** `KrefS_SubdivLeaves` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.CoarseCells(BoSSS.Foundation.Grid.Classic.GridCorrelation,System.Collections.Generic.List{BoSSS.Foundation.Grid.Classic.Cell},BoSSS.Foundation.Grid.Classic.Cell[][],System.Int32[]) <a id="bosss.foundation.grid.classic.griddata.coarsecells(bosss.foundation.grid.classic.gridcorrelation,system.collections.generic.list{bosss.foundation.grid.classic.cell},bosss.foundation.grid.classic.cell[][],system.int32[])"></a>
**Summary:** Restores the coarsed cell from the finer cells in the coarsening cluster.


## Method: BoSSS.Foundation.Grid.Classic.GridData.SerialExchangeCellData(BoSSS.Foundation.Grid.Classic.Cell[][]) <a id="bosss.foundation.grid.classic.griddata.serialexchangecelldata(bosss.foundation.grid.classic.cell[][])"></a>
**Summary:** Gets the cell data for all process boundary cells on the neighboring process of the current process.
**Parameter:** `Cells` - All adapted cells, i.e. every cell which was either refined or coarsened.
**Returns:**
A collection of refinements/aggregations of cells in the current mesh.
- global index: with respect to current grid, the global index (external range) of the original cell which is refined/coarsened
- cell cluster: refined, resp. coarsened cells in respective cluster (Refinement: multiple entries, Coarsening: a single entry)
**Remark:**
Copies the entire cell data to the neighboring process in order to update neighboring information between cells at the process boundary.

- 1st index: cell index of current mesh
- 2nd index: enumeration of subdivisions


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetBoundaryCellsAndProcessToSend(BoSSS.Foundation.Grid.Classic.Cell[][]) <a id="bosss.foundation.grid.classic.griddata.getboundarycellsandprocesstosend(bosss.foundation.grid.classic.cell[][])"></a>
**Summary:** Creates a dict. where the first entry is the process to be send to and the second entry is a tuple with the global cell index and the cell data of all process boundary cells of the current process.
**Parameter:** `Cells` - 
**Returns:**
- key: MPI processor rank (destination)
- value: a set of pairs, containing the global index and the respective cell data


## Method: BoSSS.Foundation.Grid.Classic.GridData.GetExternalCellProcess(System.Int32) <a id="bosss.foundation.grid.classic.griddata.getexternalcellprocess(system.int32)"></a>
**Summary:** Gets the process of an external cell.
**Parameter:** `externalCellIndex` - 


## Method: BoSSS.Foundation.Grid.Classic.GridData.FindCellOnNeighbourProcess(System.Collections.Generic.List{System.ValueTuple{System.Int64,BoSSS.Foundation.Grid.Classic.Cell[]}},System.Int32,System.Int32,System.Int32@) <a id="bosss.foundation.grid.classic.griddata.findcellonneighbourprocess(system.collections.generic.list{system.valuetuple{system.int64,bosss.foundation.grid.classic.cell[]}},system.int32,system.int32,system.int32@)"></a>
**Summary:** Searches for a cell on the neighbour process and creates a temporary cell to create the neighbourship info.
**Parameter:** `cellsOnNeighbourProcess` - 
**Parameter:** `localCellIndex` - 
**Parameter:** `leavesLength` - No of cell subdivisions
**Parameter:** `neighbourProcess` - MPI rank of respective cell cells


## Method: BoSSS.Foundation.Grid.Classic.GridData.AdaptBoundaryCellFaces(BoSSS.Foundation.Grid.Classic.Cell[][],System.Byte[0:,0:],System.Int32,System.Int32) <a id="bosss.foundation.grid.classic.griddata.adaptboundarycellfaces(bosss.foundation.grid.classic.cell[][],system.byte[0:,0:],system.int32,system.int32)"></a>
**Summary:** Recreates the boundary info on adapted cell faces


## Method: BoSSS.Foundation.Grid.Classic.GridData.CheckIfCellIsMissing(System.Int32,BoSSS.Foundation.Grid.Classic.Cell[],System.Int64) <a id="bosss.foundation.grid.classic.griddata.checkifcellismissing(system.int32,bosss.foundation.grid.classic.cell[],system.int64)"></a>
**Summary:** Error check for missing cell.


### Field: BoSSS.Foundation.Grid.Classic.GridData.m_VerticeData <a id="bosss.foundation.grid.classic.griddata.m_verticedata"></a>
**Summary:** See [BoSSS.Foundation.Grid.Classic.GridData.Vertices](#bosss.foundation.grid.classic.griddata.vertices)


### Property: BoSSS.Foundation.Grid.Classic.GridData.Vertices <a id="bosss.foundation.grid.classic.griddata.vertices"></a>
**Summary:** Information about the vertices of the grid elements, see
[BoSSS.Foundation.Grid.Classic.GridData.VertexData](#bosss.foundation.grid.classic.griddata.vertexdata)


### Property: BoSSS.Foundation.Grid.Classic.GridData.iVertices <a id="bosss.foundation.grid.classic.griddata.ivertices"></a>
**Summary:** Information about the vertices of the grid elements, see
[BoSSS.Foundation.Grid.IVertexData](#bosss.foundation.grid.ivertexdata).

## Class: BoSSS.Foundation.Grid.Classic.GridData.VertexData <a id="bosss.foundation.grid.classic.griddata.vertexdata"></a>

**Summary:** Data about the vertices


## Method: BoSSS.Foundation.Grid.Classic.GridData.VertexData.#ctor(BoSSS.Foundation.Grid.Classic.GridData) <a id="bosss.foundation.grid.classic.griddata.vertexdata.#ctor(bosss.foundation.grid.classic.griddata)"></a>
**Summary:** ctor


### Field: BoSSS.Foundation.Grid.Classic.GridData.VertexData.m_owner <a id="bosss.foundation.grid.classic.griddata.vertexdata.m_owner"></a>
**Summary:** pointer to owner object


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.Coordinates <a id="bosss.foundation.grid.classic.griddata.vertexdata.coordinates"></a>
**Summary:** all vertices/nodes of the gird;
**Remark:**
1st index: vertex index
2nd index: spatial dimension

The vertices are sorted in a specific order:


First, all pure local vertices, see
[BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfPurelyLocal](#bosss.foundation.grid.classic.griddata.vertexdata.noofpurelylocal)


Second, all shared vertices owned by this MPI process,
see [BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfRelayed](#bosss.foundation.grid.classic.griddata.vertexdata.noofrelayed)


Third, all shared vertices owned by other MPI processes,
see [BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfBorrowed](#bosss.foundation.grid.classic.griddata.vertexdata.noofborrowed)


Fourth, all external vertices, see
[BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfExternal](#bosss.foundation.grid.classic.griddata.vertexdata.noofexternal)


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.Count <a id="bosss.foundation.grid.classic.griddata.vertexdata.count"></a>
**Summary:** Number of Vertices on local MPI process


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfPurelyLocal <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofpurelylocal"></a>
**Summary:** Number of vertices which are used only by locally updated cells;


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfRelayed <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofrelayed"></a>
**Summary:** Number of shared vertices (used by locally updated cells AND
external cells) which are 'owned' by the current MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfOwned <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofowned"></a>
**Summary:** Number of vertices which are 'owned' by the current MPI process


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfBorrowed <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofborrowed"></a>
**Summary:** Number of shared vertices (used by locally updated cells AND
external cells) which are 'owned' by other MPI process.


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfExternal <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofexternal"></a>
**Summary:** Number of Vertices which are used only by external cells;


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfPeriodicElim <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofperiodicelim"></a>
**Summary:** Number of nodes which are identical to others via the peridicity relations of the grid.


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NoOfNodes4LocallyUpdatedCells <a id="bosss.foundation.grid.classic.griddata.vertexdata.noofnodes4locallyupdatedcells"></a>
**Summary:** Number of nodes that are used by locally updated cells.


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NodePartitioning <a id="bosss.foundation.grid.classic.griddata.vertexdata.nodepartitioning"></a>
**Summary:** partitioning of nodes across MPI processes


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.VertexSendLists <a id="bosss.foundation.grid.classic.griddata.vertexdata.vertexsendlists"></a>
**Summary:** content: which of the relayed vertices must be send to
other processors
- 1st index: MPI rank of target processor 'R' 
- 2nd index: enumeration


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.VertexInsertLists <a id="bosss.foundation.grid.classic.griddata.vertexdata.vertexinsertlists"></a>
**Summary:** content: where the borrowed vertices received by other
processors must be inserted 
- 1st index: MPI rank of target processor 'R' 
- 2nd index: enumeration


## Method: BoSSS.Foundation.Grid.Classic.GridData.VertexData.CollectVertices(BoSSS.Foundation.Grid.Classic.GridData,System.Int32[][]@,ilPSP.MultidimensionalArray@,System.Double[],System.Boolean) <a id="bosss.foundation.grid.classic.griddata.vertexdata.collectvertices(bosss.foundation.grid.classic.griddata,system.int32[][]@,ilpsp.multidimensionalarray@,system.double[],system.boolean)"></a>
**Summary:** Computes a unique list of all nodes/vertices of all cells.
**Parameter:** `vertice` - output: the merged vertices, i.e. each vertex from the
**Parameter:** `cellVertices` - output: indices into the 'vertice'-array.
1st index: cell index;
2nd index: vertex index within cell;
**Parameter:** `grdDat` - 
**Parameter:** `h` - cell measure
**Parameter:** `IncludeExt` - true, if also external cells should be considered


### Property: BoSSS.Foundation.Grid.Classic.GridData.VertexData.VerticeToCell <a id="bosss.foundation.grid.classic.griddata.vertexdata.verticetocell"></a>
**Summary:** For each vertex, the local indices of the adjacent cells;
- 1st index: local vertex index
- 2nd index: collection


## Method: BoSSS.Foundation.Grid.Classic.GridData.VertexData.Init_VerticeToCell <a id="bosss.foundation.grid.classic.griddata.vertexdata.init_verticetocell"></a>
**Summary:** init code for [BoSSS.Foundation.Grid.Classic.GridData.VertexData.VerticeToCell](#bosss.foundation.grid.classic.griddata.vertexdata.verticetocell).


## Method: BoSSS.Foundation.Grid.Classic.GridData.VertexData.NodeCorrespondence(ilPSP.MultidimensionalArray,BoSSS.Platform.LinAlg.AffineTrafo,ilPSP.MultidimensionalArray,System.Double) <a id="bosss.foundation.grid.classic.griddata.vertexdata.nodecorrespondence(ilpsp.multidimensionalarray,bosss.platform.linalg.affinetrafo,ilpsp.multidimensionalarray,system.double)"></a>
**Summary:** Geometrical matching of nodes.
**Parameter:** `NodesIn` - First set of nodes.
**Parameter:** `ict` - 
**Parameter:** `NodesOut` - second set of nodes.
**Parameter:** `Tol` - Some tolerance
**Returns:**
A permutation R, so that for all valid indices k, 
'NodesOut'[R[k]] == 'ict'('NodesIn'[k]).

## Class: BoSSS.Foundation.Grid.Classic.GridData.VertexData.VertexSharingData <a id="bosss.foundation.grid.classic.griddata.vertexdata.vertexsharingdata"></a>

**Summary:** Work-around for a bug in Mono that has problems
(de)serializing staggered arrays


### Field: BoSSS.Foundation.Grid.Classic.GridData.VertexData.VertexSharingData.Data <a id="bosss.foundation.grid.classic.griddata.vertexdata.vertexsharingdata.data"></a>
**Summary:** - 1st index: cell
- 2nd index: cell vertex
- 3rd index: collection


## Method: BoSSS.Foundation.Grid.Classic.GridData.NegotiateOwnership(MPI.Wrappers.MPI_Comm,System.ValueTuple{System.Int32,System.Int32}[][],System.Int32[]@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32[][]@,System.Int32[][]@,System.Tuple{System.Int32,System.Int32}[]@) <a id="bosss.foundation.grid.classic.griddata.negotiateownership(mpi.wrappers.mpi_comm,system.valuetuple{system.int32,system.int32}[][],system.int32[]@,system.int32@,system.int32@,system.int32@,system.int32@,system.int32@,system.int32[][]@,system.int32[][]@,system.tuple{system.int32,system.int32}[]@)"></a>
**Summary:** Negotiation of MPI-Ownership for 'items' (e.g. vertices or edges).

## Class: BoSSS.Foundation.Grid.CellInfo <a id="bosss.foundation.grid.cellinfo"></a>

**Summary:** Flags giving additional information on cells.


### Field: BoSSS.Foundation.Grid.CellInfo.Undefined <a id="bosss.foundation.grid.cellinfo.undefined"></a>
**Summary:** initial value


### Field: BoSSS.Foundation.Grid.CellInfo.RefElementIndex_Mask <a id="bosss.foundation.grid.cellinfo.refelementindex_mask"></a>
**Summary:** Marks the region of the info in which the reference element index 
(index into [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)) is encoded.


### Field: BoSSS.Foundation.Grid.CellInfo.CellIsAffineLinear <a id="bosss.foundation.grid.cellinfo.cellisaffinelinear"></a>
**Summary:** marks affine-linear cells


### Field: BoSSS.Foundation.Grid.CellInfo.IsAggregate <a id="bosss.foundation.grid.cellinfo.isaggregate"></a>
**Summary:** Marks cells which are aggregated from smaller parts.


### Field: BoSSS.Foundation.Grid.CellInfo.CellType_Mask <a id="bosss.foundation.grid.cellinfo.celltype_mask"></a>
**Summary:** Marks the region of the info in which the cell type (see [BoSSS.Foundation.Grid.RefElements.CellType](#bosss.foundation.grid.refelements.celltype))
is encoded.


### Field: BoSSS.Foundation.Grid.CellInfo.AllOn <a id="bosss.foundation.grid.cellinfo.allon"></a>
**Summary:** All flags on, implementing this ensures that the enum 
is compiled using 32 bits.

## Class: BoSSS.Foundation.Grid.CellMask <a id="bosss.foundation.grid.cellmask"></a>

**Summary:** masks some cells in a [BoSSS.Foundation.Grid.IGridData](#bosss.foundation.grid.igriddata)-object


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** ctor
**Parameter:** `grddat` - 
**Parameter:** `mask` -
a "true" entry for all cells in grid 'grddat' that
should be in the mask; 
The length of this array must not exceed
- [BoSSS.Foundation.Grid.Classic.GridData.CellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.classic.griddata.celldata.nooflocalupdatedcells)/[BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells) in the case of a logical mask, i.e. 'mt' is [BoSSS.Foundation.Grid.MaskType.Logical](#bosss.foundation.grid.masktype.logical)
- [BoSSS.Foundation.Grid.IGeometricalCellsData.NoOfLocalUpdatedCells](#bosss.foundation.grid.igeometricalcellsdata.nooflocalupdatedcells) in the case of a geometrical mask, i.e. 'mt' is [BoSSS.Foundation.Grid.MaskType.Geometrical](#bosss.foundation.grid.masktype.geometrical)
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Func{System.Int32,System.Boolean},BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,system.func{system.int32,system.boolean},bosss.foundation.grid.masktype)"></a>
**Summary:** ctor
**Parameter:** `grddat` - 
**Parameter:** `mask` - a "true" entry for all cells (local index) in grid 'grddat' that should be in the mask;
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32[],BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,system.int32[],bosss.foundation.grid.masktype)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.Grid.CellMask.Complement <a id="bosss.foundation.grid.cellmask.complement"></a>
**Summary:** complement of this mask (all cells that are NOT in this mask);


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk[]) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk[])"></a>
**Summary:** compiles a cell mask from a set of chunks
**Parameter:** `parts` - a list of chunks, which may overlap
**Parameter:** `grddat` - the grid that this mask will be associated with;


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk[],BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk[],bosss.foundation.grid.masktype)"></a>
**Summary:** compiles a cell mask from a set of chunks
**Parameter:** `parts` - a list of chunks, which may overlap
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `mt` - 


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk,bosss.foundation.grid.masktype)"></a>
**Summary:** compiles a cell mask from a chunk
**Parameter:** `part` - a single, continuous range of cells (chunk)
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `mt` - 


## Method: BoSSS.Foundation.Grid.CellMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Chunk},BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.#ctor(bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.grid.chunk},bosss.foundation.grid.masktype)"></a>
**Summary:** compiles an quadrature execution mask from a set of chunks
**Parameter:** `Parts` - a list of chunks, which may overlap
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.CellMask.GetEmptyMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.getemptymask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)"></a>
**Summary:** Retrieves an empty cell mask;
**Parameter:** `grdDat` - grid that the returned mask will be assigned to
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.CellMask.GetFullMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.getfullmask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)"></a>
**Summary:** Retrieves a mask containing all cells (i.e. returns the
complement of [BoSSS.Foundation.Grid.CellMask.GetEmptyMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType)](#bosss.foundation.grid.cellmask.getemptymask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)))
**Parameter:** `gridDat` - Grid data that the returned mask will be assigned with
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)
**Returns:**
A full mask


## Method: BoSSS.Foundation.Grid.CellMask.GetCellMask(BoSSS.Foundation.Grid.IGridData,System.Func{ilPSP.Vector,System.Boolean}) <a id="bosss.foundation.grid.cellmask.getcellmask(bosss.foundation.grid.igriddata,system.func{ilpsp.vector,system.boolean})"></a>
**Summary:** Selects all cells according to their cell centers, where 'SelectionFunction' is true
**Parameter:** `gridData` - 
**Parameter:** `SelectionFunction` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.CellMask.GetCellMask(BoSSS.Foundation.Grid.IGridData,System.Func{System.Int32,ilPSP.Vector,System.Boolean}) <a id="bosss.foundation.grid.cellmask.getcellmask(bosss.foundation.grid.igriddata,system.func{system.int32,ilpsp.vector,system.boolean})"></a>
**Summary:** Selects all cells according to their cell centers, where 'SelectionFunction' is true
**Parameter:** `gridData` - 
**Parameter:** `SelectionFunction` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.CellMask.CreateInstance(System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.cellmask.createinstance(system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** like the ctor.


## Method: BoSSS.Foundation.Grid.CellMask.GetUpperIndexBound(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.cellmask.getupperindexbound(bosss.foundation.grid.igriddata)"></a>
**Summary:** see [BoSSS.Foundation.Grid.ExecutionMask.GetUpperIndexBound(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.grid.executionmask.getupperindexbound(bosss.foundation.grid.igriddata))


## Method: BoSSS.Foundation.Grid.CellMask.GetBitMaskWithExternal <a id="bosss.foundation.grid.cellmask.getbitmaskwithexternal"></a>
**Summary:** returns a bitmask that contains also information about external/ghost cells.


### Property: BoSSS.Foundation.Grid.CellMask.NoOfItemsLocally_WithExternal <a id="bosss.foundation.grid.cellmask.noofitemslocally_withexternal"></a>
**Summary:** local number of cells, including external ones


## Method: BoSSS.Foundation.Grid.CellMask.GetEnumerableWithExternal <a id="bosss.foundation.grid.cellmask.getenumerablewithexternal"></a>
**Summary:** returns an enumerable structure that also contains external/ghost cells.


## Method: BoSSS.Foundation.Grid.CellMask.SaveToTextFile(System.String,System.Boolean,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo[]) <a id="bosss.foundation.grid.cellmask.savetotextfile(system.string,system.boolean,bosss.foundation.grid.executionmask.iteminfo[])"></a>
**Summary:** writes the center coordinates of all cells in this mask to some text file


## Method: BoSSS.Foundation.Grid.CellMask.Equals(System.Object) <a id="bosss.foundation.grid.cellmask.equals(system.object)"></a>
**Summary:** %


## Method: BoSSS.Foundation.Grid.CellMask.GetHashCode <a id="bosss.foundation.grid.cellmask.gethashcode"></a>
**Summary:** %


## Method: BoSSS.Foundation.Grid.CellMask.AllEdges <a id="bosss.foundation.grid.cellmask.alledges"></a>
**Summary:** Returns all connected Edges


## Method: BoSSS.Foundation.Grid.CellMask.AllNeighbourCells <a id="bosss.foundation.grid.cellmask.allneighbourcells"></a>
**Summary:** All cells that share at least an edge with a cell in this mask.


## Method: BoSSS.Foundation.Grid.CellMask.ToGeometicalMask <a id="bosss.foundation.grid.cellmask.togeometicalmask"></a>
**Summary:** Converts this  
from a logical ([BoSSS.Foundation.Grid.IGridData.iLogicalCells](#bosss.foundation.grid.igriddata.ilogicalcells)) mask
to a geometrical ([BoSSS.Foundation.Grid.IGridData.iGeomCells](#bosss.foundation.grid.igriddata.igeomcells)) mask.
**Returns:**



## Method: BoSSS.Foundation.Grid.CellMask.ToLogicalMask <a id="bosss.foundation.grid.cellmask.tologicalmask"></a>
**Summary:** Converts this  
from a geometrical ([BoSSS.Foundation.Grid.IGridData.iGeomCells](#bosss.foundation.grid.igriddata.igeomcells)) mask
to a  logical ([BoSSS.Foundation.Grid.IGridData.iLogicalCells](#bosss.foundation.grid.igriddata.ilogicalcells)) mask.
**Returns:**



## Method: BoSSS.Foundation.Grid.CellMask.GetAllLocalEdgesMask <a id="bosss.foundation.grid.cellmask.getalllocaledgesmask"></a>
**Summary:** Obtain all edges adjacent to cells within this mask;
This is a non-collective alternative to [BoSSS.Foundation.Grid.SubGrid.AllEdgesMask](#bosss.foundation.grid.subgrid.alledgesmask)
**Returns:**



## Method: BoSSS.Foundation.Grid.CellMask.GetAllInnerEdgesMask <a id="bosss.foundation.grid.cellmask.getallinneredgesmask"></a>
**Summary:** Obtain all edges adjacent to cells within this mask, on both sides of the edge.
This is a non-collective alternative to [BoSSS.Foundation.Grid.SubGrid.InnerEdgesMask](#bosss.foundation.grid.subgrid.inneredgesmask)

## Class: BoSSS.Foundation.Grid.RefElements.CellType <a id="bosss.foundation.grid.refelements.celltype"></a>

**Summary:** Encoding of elementary cell types.


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_Linear <a id="bosss.foundation.grid.refelements.celltype.square_linear"></a>
**Summary:** Linear quad (3 points)


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_3 <a id="bosss.foundation.grid.refelements.celltype.triangle_3"></a>
**Summary:** linear triangle


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_Linear <a id="bosss.foundation.grid.refelements.celltype.cube_linear"></a>
**Summary:** linear cube (4 points)


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Tetra_Linear <a id="bosss.foundation.grid.refelements.celltype.tetra_linear"></a>
**Summary:** linear (4-point) tetra


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Tetra_10 <a id="bosss.foundation.grid.refelements.celltype.tetra_10"></a>
**Summary:** Quadratic tetra


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Tetra_20 <a id="bosss.foundation.grid.refelements.celltype.tetra_20"></a>
**Summary:** Cubic tetra


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Tetra_35 <a id="bosss.foundation.grid.refelements.celltype.tetra_35"></a>
**Summary:** Quartic tetra


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Tetra_56 <a id="bosss.foundation.grid.refelements.celltype.tetra_56"></a>
**Summary:** Qunitic tetra


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_4 <a id="bosss.foundation.grid.refelements.celltype.square_4"></a>
**Summary:** Bi-linear square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_8 <a id="bosss.foundation.grid.refelements.celltype.square_8"></a>
**Summary:** Quadratic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_9 <a id="bosss.foundation.grid.refelements.celltype.square_9"></a>
**Summary:** Bi-quadratic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_12 <a id="bosss.foundation.grid.refelements.celltype.square_12"></a>
**Summary:** Cubic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_16 <a id="bosss.foundation.grid.refelements.celltype.square_16"></a>
**Summary:** Bi-cubic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_25 <a id="bosss.foundation.grid.refelements.celltype.square_25"></a>
**Summary:** Bi-quartic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_36 <a id="bosss.foundation.grid.refelements.celltype.square_36"></a>
**Summary:** Bi-quintic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_49 <a id="bosss.foundation.grid.refelements.celltype.square_49"></a>
**Summary:** Bi-sextic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_64 <a id="bosss.foundation.grid.refelements.celltype.square_64"></a>
**Summary:** Bi-septic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_81 <a id="bosss.foundation.grid.refelements.celltype.square_81"></a>
**Summary:** Bi-octic square


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Square_100 <a id="bosss.foundation.grid.refelements.celltype.square_100"></a>
**Summary:** Bi-nonic square (if such a thing exists...)


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_9 <a id="bosss.foundation.grid.refelements.celltype.triangle_9"></a>
**Summary:** Cubic triangle


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_6 <a id="bosss.foundation.grid.refelements.celltype.triangle_6"></a>
**Summary:** Quadratic triangle


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_21 <a id="bosss.foundation.grid.refelements.celltype.triangle_21"></a>
**Summary:** ?


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_15 <a id="bosss.foundation.grid.refelements.celltype.triangle_15"></a>
**Summary:** ?


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_152 <a id="bosss.foundation.grid.refelements.celltype.triangle_152"></a>
**Summary:** What the hell?


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_12 <a id="bosss.foundation.grid.refelements.celltype.triangle_12"></a>
**Summary:** ?


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Triangle_10 <a id="bosss.foundation.grid.refelements.celltype.triangle_10"></a>
**Summary:** ?


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_8 <a id="bosss.foundation.grid.refelements.celltype.cube_8"></a>
**Summary:** Tri-linear cube


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_20 <a id="bosss.foundation.grid.refelements.celltype.cube_20"></a>
**Summary:** Cubic cube (lol)


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_27 <a id="bosss.foundation.grid.refelements.celltype.cube_27"></a>
**Summary:** Tri-cubic cube (lol again)


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_64 <a id="bosss.foundation.grid.refelements.celltype.cube_64"></a>
**Summary:** Tri-quartic cube


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_125 <a id="bosss.foundation.grid.refelements.celltype.cube_125"></a>
**Summary:** Tri-quintic cube


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Cube_216 <a id="bosss.foundation.grid.refelements.celltype.cube_216"></a>
**Summary:** Tri-sextic cube


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Line_2 <a id="bosss.foundation.grid.refelements.celltype.line_2"></a>
**Summary:** Linear line element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Line_3 <a id="bosss.foundation.grid.refelements.celltype.line_3"></a>
**Summary:** Quadratic line element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Line_4 <a id="bosss.foundation.grid.refelements.celltype.line_4"></a>
**Summary:** Cubic line element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Line_5 <a id="bosss.foundation.grid.refelements.celltype.line_5"></a>
**Summary:** Quartic line element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Line_6 <a id="bosss.foundation.grid.refelements.celltype.line_6"></a>
**Summary:** Quintic line element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.Point <a id="bosss.foundation.grid.refelements.celltype.point"></a>
**Summary:** Zero-dimensional element


### Field: BoSSS.Foundation.Grid.RefElements.CellType.AllOn <a id="bosss.foundation.grid.refelements.celltype.allon"></a>
**Summary:** All flags on, implementing this ensures that the enum 
is compiled using 32 bits.

## Class: BoSSS.Foundation.Grid.RefElements.CellTypeExtensions <a id="bosss.foundation.grid.refelements.celltypeextensions"></a>

**Summary:** Extension methods


## Method: BoSSS.Foundation.Grid.RefElements.CellTypeExtensions.IsLinear(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.celltypeextensions.islinear(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** True, if 'type' represents an element with a
linear transformation to physical space.


## Method: BoSSS.Foundation.Grid.RefElements.CellTypeExtensions.GetRefElement(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.celltypeextensions.getrefelement(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** Returns the reference element which corresponds to [BoSSS.Foundation.Grid.RefElements.CellType](#bosss.foundation.grid.refelements.celltype)

## Class: BoSSS.Foundation.Grid.RefElements.Cube <a id="bosss.foundation.grid.refelements.cube"></a>

**Summary:** The cubic reference element, i.e. $K^{\textrm{cube} } = ( -1,1 )^3$.

## Class: BoSSS.Foundation.Grid.RefElements.Cube.Faces <a id="bosss.foundation.grid.refelements.cube.faces"></a>

**Summary:** The encoding to identify all six faces of the cube.


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Left <a id="bosss.foundation.grid.refelements.cube.faces.left"></a>
**Summary:** edge between this cell the neighbour cell with $x$--coordinates closer to negative infinity.


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Right <a id="bosss.foundation.grid.refelements.cube.faces.right"></a>
**Summary:** edge between this cell the neighbour cell with $x$--coordinates closer to positive infinity.


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Top <a id="bosss.foundation.grid.refelements.cube.faces.top"></a>
**Summary:** edge between this cell the neighbour cell with $y$--coordinates closer to positive infinity.


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Bottom <a id="bosss.foundation.grid.refelements.cube.faces.bottom"></a>
**Summary:** edge between this cell the neighbour cell with $y$--coordinates closer to negative infinity.


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Front <a id="bosss.foundation.grid.refelements.cube.faces.front"></a>
**Summary:** edge between this cell the neighbour cell with $z$--coordinates closer to positive infinity


### Field: BoSSS.Foundation.Grid.RefElements.Cube.Faces.Back <a id="bosss.foundation.grid.refelements.cube.faces.back"></a>
**Summary:** edge between this cell the neighbour cell with $z$--coordinates closer to negative infinity


### Property: BoSSS.Foundation.Grid.RefElements.Cube.Instance <a id="bosss.foundation.grid.refelements.cube.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Cube.#ctor <a id="bosss.foundation.grid.refelements.cube.#ctor"></a>
**Summary:** standard constructor


## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetQuadratureRule(System.Int32) <a id="bosss.foundation.grid.refelements.cube.getquadraturerule(system.int32)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32))
**Remark:**
The 3D-Rules occupy a significant amount of memory (about 200 MB, particularly bad when running with lots of MPI cores:
E.g., 100 Processors, 20 GB of memory just for quadrature rules), so we only create those that we need on the fly.


### Property: BoSSS.Foundation.Grid.RefElements.Cube.HighestKnownOrder <a id="bosss.foundation.grid.refelements.cube.highestknownorder"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.HighestKnownOrder](#bosss.foundation.grid.refelements.refelement.highestknownorder)


## Method: BoSSS.Foundation.Grid.RefElements.Cube.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.cube.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms some vertices ('FaceVertices') from the local 2D-coordinate system of either
the top, bottom, left, right, front or back edge (see [BoSSS.Foundation.Grid.RefElements.Cube.Faces](#bosss.foundation.grid.refelements.cube.faces)) to the local 
coordinate system of the cube;
**Parameter:** `FaceIndex` - 0, 1, 2, 3, 4 or 5; [BoSSS.Foundation.Grid.RefElements.Cube.Faces](#bosss.foundation.grid.refelements.cube.faces)
**Parameter:** `FaceVertices` - input;
**Parameter:** `VolumeVertices` - output;


## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetSubdivision <a id="bosss.foundation.grid.refelements.cube.getsubdivision"></a>
**Summary:** partitions this cube into 8 sub-cubes of equal size;
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Cube.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.cube.iswithin(system.double[],system.double)"></a>
**Summary:** tests whether 'pt' is within the convex hull of
vertices or not;
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.cube.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.cube.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats) <a id="bosss.foundation.grid.refelements.cube.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats)](#bosss.foundation.grid.refelements.refelement.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Cube.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.cube.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Parameter:** `ForeignName` - 
**Parameter:** `ForeignTypeConstant` - 

## Class: BoSSS.Foundation.Grid.RefElements.Line <a id="bosss.foundation.grid.refelements.line"></a>

**Summary:** The line reference element, i.e. $K^{\textrm{line}} = ( -1,1 )$.

## Class: BoSSS.Foundation.Grid.RefElements.Line.Edge <a id="bosss.foundation.grid.refelements.line.edge"></a>

**Summary:** Indicates the "faces" -1 and 1 .


### Field: BoSSS.Foundation.Grid.RefElements.Line.Edge.Left <a id="bosss.foundation.grid.refelements.line.edge.left"></a>
**Summary:** -1


### Field: BoSSS.Foundation.Grid.RefElements.Line.Edge.Right <a id="bosss.foundation.grid.refelements.line.edge.right"></a>
**Summary:** 1


### Property: BoSSS.Foundation.Grid.RefElements.Line.Instance <a id="bosss.foundation.grid.refelements.line.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Line.#ctor <a id="bosss.foundation.grid.refelements.line.#ctor"></a>
**Summary:** default constructor


## Method: BoSSS.Foundation.Grid.RefElements.Line.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.line.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms some vertices from local edge coordinates to the local coorinate system of this
simplex
**Parameter:** `EdgeIndex` - specifyes the edge; [BoSSS.Foundation.Grid.RefElements.Line.Edge](#bosss.foundation.grid.refelements.line.edge)
**Parameter:** `EdgeVertices` - Input; Vertices in the local coordinate system of the edge;
1st index: vertex index; 2nd index: spatial coordinate index, the only valid index is 0;
**Parameter:** `VolumeVertices` - On exit, the 'EdgeVertices' transformed to the local coordinate system of this simplex;


## Method: BoSSS.Foundation.Grid.RefElements.Line.GetSubdivision <a id="bosss.foundation.grid.refelements.line.getsubdivision"></a>
**Summary:** splits the line element int two sub-lines
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Line.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.line.iswithin(system.double[],system.double)"></a>
**Summary:** Tests whether 'pt' is within the convex hull of
vertices or not;
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Line.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.line.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Line.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.line.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Line.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.line.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Parameter:** `ForeignName` - 
**Parameter:** `ForeignTypeConstant` - 


### Property: BoSSS.Foundation.Grid.RefElements.Line.FaceTrafoGramianSqrt <a id="bosss.foundation.grid.refelements.line.facetrafogramiansqrt"></a>
**Summary:** Always 1.0 for the line-element.

## Class: BoSSS.Foundation.Grid.RefElements.Point <a id="bosss.foundation.grid.refelements.point"></a>

**Summary:** The point reference element, i.e. $K^{\textrm{point}} = \{ 0 \}$.


### Property: BoSSS.Foundation.Grid.RefElements.Point.Instance <a id="bosss.foundation.grid.refelements.point.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Point.#ctor <a id="bosss.foundation.grid.refelements.point.#ctor"></a>
**Summary:** default constructor


## Method: BoSSS.Foundation.Grid.RefElements.Point.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.point.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** not supported - a point has no edges;
**Parameter:** `EdgeIndex` - 
**Parameter:** `EdgeVertices` - 
**Parameter:** `VolumeVertices` - 


## Method: BoSSS.Foundation.Grid.RefElements.Point.GetQuadratureRule(System.Int32) <a id="bosss.foundation.grid.refelements.point.getquadraturerule(system.int32)"></a>
**Summary:** quadrature for a point is trivial - it's just evaluation a the point,
so there is only one quadrature rule with one node that is valid for any order;
**Parameter:** `DesiredOrder` - any positive integer value;
**Returns:**
An exact quad. rule for arbitrary functions in zero dimensions !!!


### Property: BoSSS.Foundation.Grid.RefElements.Point.SpatialDimension <a id="bosss.foundation.grid.refelements.point.spatialdimension"></a>
**Summary:** dimension of a point is 0;


### Property: BoSSS.Foundation.Grid.RefElements.Point.HighestKnownOrder <a id="bosss.foundation.grid.refelements.point.highestknownorder"></a>
**Summary:** the maximum positive integer


## Method: BoSSS.Foundation.Grid.RefElements.Point.GetSubdivision <a id="bosss.foundation.grid.refelements.point.getsubdivision"></a>
**Summary:** the Point cannot be subdivided - the subdivision contains only one element;
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Point.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.point.iswithin(system.double[],system.double)"></a>
**Summary:** tests whether 'pt' is within the convex hull of
vertices or not;
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Point.GetBruteForceQuadRule(System.Int32,System.Int32) <a id="bosss.foundation.grid.refelements.point.getbruteforcequadrule(system.int32,system.int32)"></a>
**Summary:** here, the same issues as for [BoSSS.Foundation.Grid.RefElements.Point.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.point.getquadraturerule(system.int32)) apply;


## Method: BoSSS.Foundation.Grid.RefElements.Point.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.point.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** Operation not meaningful for zero-dimensional object.


## Method: BoSSS.Foundation.Grid.RefElements.Point.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.point.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** Not implemented.


## Method: BoSSS.Foundation.Grid.RefElements.Point.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.point.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))

## Class: BoSSS.Foundation.Grid.RefElements.QuadRuleResource <a id="bosss.foundation.grid.refelements.quadruleresource"></a>

**Summary:** This class reads quadrature rules, stored in text files
and converts them to a binary format (base64-encoded string)
which can be embedded in the assembly as a resource.
This approach is somewhat cleaner than the traditional one used in BoSSS 
(large C# files with auto-generated code)
since this, at some point ckacks the limits of compiler, JIT and other tools.


## Method: BoSSS.Foundation.Grid.RefElements.QuadRuleResource.ReadFromTextFile(System.String) <a id="bosss.foundation.grid.refelements.quadruleresource.readfromtextfile(system.string)"></a>
**Summary:** Imports a quadrature rule from a text file.


## Method: BoSSS.Foundation.Grid.RefElements.QuadRuleResource.DecodeFromBase64(System.String) <a id="bosss.foundation.grid.refelements.quadruleresource.decodefrombase64(system.string)"></a>
**Summary:** Decodes quadrature rules from base64 - encoded binary Data.


## Method: BoSSS.Foundation.Grid.RefElements.QuadRuleResource.ExportRules(System.String,System.String,System.Collections.Generic.IEnumerable{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.grid.refelements.quadruleresource.exportrules(system.string,system.string,system.collections.generic.ienumerable{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Exports quadrature rules to human-readable text files.

## Class: BoSSS.Foundation.Grid.RefElements.QuadRuleResource.Container <a id="bosss.foundation.grid.refelements.quadruleresource.container"></a>

**Summary:** Seems to be necessary, otherwise Json Deserializer refuses to work.


## Method: BoSSS.Foundation.Grid.RefElements.QuadRuleResource.Import(System.String) <a id="bosss.foundation.grid.refelements.quadruleresource.import(system.string)"></a>
**Summary:** Imports quadrature rules from textfile to mem.

## Class: BoSSS.Foundation.Grid.RefElements.RefElement <a id="bosss.foundation.grid.refelements.refelement"></a>

**Summary:** Base class that implements/defines features which all reference
elements (Triangles, Lines, Tetras which build up the mesh) have in
common.

**Remark:**
Geometrically, the reference element is defined to be the convex hull of
[BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices).


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_Volume <a id="bosss.foundation.grid.refelements.refelement.m_volume"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.Volume](#bosss.foundation.grid.refelements.refelement.volume).


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.Volume <a id="bosss.foundation.grid.refelements.refelement.volume"></a>
**Summary:** the [BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension)-dimensional volume of this
reference element


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.HighestSupportedPolynomialDegree <a id="bosss.foundation.grid.refelements.refelement.highestsupportedpolynomialdegree"></a>
**Summary:** maximum polynomial degree that is available for a
[BoSSS.Foundation.Basis](#bosss.foundation.basis)-object


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_NoOfFaces <a id="bosss.foundation.grid.refelements.refelement.m_nooffaces"></a>
**Summary:** must be initialized by constructor of derived class;


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces <a id="bosss.foundation.grid.refelements.refelement.nooffaces"></a>
**Summary:** the number of edges, or neighbors;


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.Center <a id="bosss.foundation.grid.refelements.refelement.center"></a>
**Summary:** Center (of gravity) of this reference element.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.NoOfVertices <a id="bosss.foundation.grid.refelements.refelement.noofvertices"></a>
**Summary:** Number of vertices this simplex consists of


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceRefElement <a id="bosss.foundation.grid.refelements.refelement.m_facerefelement"></a>
**Summary:** must be initialized by constructor of derived class;


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.HackFaceRefElement(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.refelements.refelement.hackfacerefelement(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** a hack to ensure certain reference-equalities.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceRefElement <a id="bosss.foundation.grid.refelements.refelement.facerefelement"></a>
**Summary:** The reference element that forms the faces of this element.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.refelement.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms some vertices from local coordinates on one face to the
local coordinate system of this simplex
**Parameter:** `FaceIndex` - specifies the edge
**Parameter:** `InpVerticesOnFace` - Input; Vertices in the local coordinate system of the face;
1st index: vertex index; 2nd index: spatial coordinate index, range
is 0 (including) to max([BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension)-1, 1)
(excluding)
**Parameter:** `OutVerticesInSimplex` - On exit, the 'InpVerticesOnFace' transformed to
the local coordinate system of this simplex;
1st index: vertex index;
2nd index: spatial coordinate vector, in the range of 0 (including)
to [BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension) (excluding);


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.TransformFaceVectors(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.refelement.transformfacevectors(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** Transforms some vectors from the local coordinate system on a face
to the local coordinate system of the simplex
**Parameter:** `FaceIndex` - Specifies the face
**Parameter:** `gradientsOnFace` - Input; Vectors in the local coordinate system of the face;


1st index: Vector index


2nd index: Spatial coordinate index; Range is 0 (including)
to max([BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension)-1, 1) (excluding)
**Parameter:** `gradientsInSimplex` - Output; Vectors in the local coordinate system of the element;


1st index: Vector index    


2nd index: Spatial coordinate index; Range is 0 (including)
to [BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension) (excluding)


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_EmbeddedFaceTransformation <a id="bosss.foundation.grid.refelements.refelement.m_embeddedfacetransformation"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetEmbeddedFaceTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.getembeddedfacetrafo(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetEmbeddedFaceTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getembeddedfacetrafo(system.int32)"></a>
**Summary:** returns an affine-linear transformation which transforms from the
local coordinate system of the 'FaceIndex'-th face
to the local coordinate system of the simplex.
**Remark:**
Let D be the spatial dimension of the simplex, then the spatial
dimension of the face is D-1; but, for the transformation, the face
coordinate system is embedded into
$\mathbb{R}^{D}$  and we additionally map
the D-th standard basis vector to
$\vec{c}_e + \vec{n}_e$  (center of edge
$e$  plus normal), i.e.
$\mathbb{R}^{D} \ni (0,\ldots,0,1) \mapsto \vec{c}_e + \vec{n}_e$ .


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_InverseEmbeddedFaceTransformation <a id="bosss.foundation.grid.refelements.refelement.m_inverseembeddedfacetransformation"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetInverseEmbeddedFaceTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.getinverseembeddedfacetrafo(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInverseEmbeddedFaceTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getinverseembeddedfacetrafo(system.int32)"></a>
**Summary:** the transformation from the coordinate system of the simplex to
the coordinate system of face 'FaceIndex'.
**Remark:**
Let D be the spatial dimension of the simplex, then the spatial
dimension of the face is D-1; but, for the transformation, the face
coordinate system is embedded into
$\mathbb{R}^{D}$  and we additionally map
$\vec{c}_e + \vec{n}_e$  (center of edge
$e$  plus normal) to the D-th standard
basis vector, i.e.
$\vec{c}_e + \vec{n}_e \mapsto (0,\ldots,0,1) \in \mathbb{R}^{D}$ .


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_InverseFaceTransformation <a id="bosss.foundation.grid.refelements.refelement.m_inversefacetransformation"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInverseFaceTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.getinversefacetrafo(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInverseFaceTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getinversefacetrafo(system.int32)"></a>
**Summary:** the transformation from the coordinate system of the simplex to
the coordinate system of face 'FaceIndex'.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceTransformation <a id="bosss.foundation.grid.refelements.refelement.m_facetransformation"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.getfacetrafo(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getfacetrafo(system.int32)"></a>
**Summary:** returns an affine-linear transformation which transforms from the
local coordinate system of the 'FaceIndex'-th face
the the local coordinate system of the simplex.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceTrafoGramianSqrt <a id="bosss.foundation.grid.refelements.refelement.m_facetrafogramiansqrt"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.FaceTrafoGramianSqrt](#bosss.foundation.grid.refelements.refelement.facetrafogramiansqrt)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceTrafoGramianSqrt <a id="bosss.foundation.grid.refelements.refelement.facetrafogramiansqrt"></a>
**Summary:** Square-root of the Gramian determinant of the face-to-volume
transformation, see [BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceTrafo(System.Int32)](#bosss.foundation.grid.refelements.refelement.getfacetrafo(system.int32)). 
index: face index


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_VertexIndicesToFaces <a id="bosss.foundation.grid.refelements.refelement.m_vertexindicestofaces"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.VertexIndicesToFaces](#bosss.foundation.grid.refelements.refelement.vertexindicestofaces)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.VertexIndicesToFaces <a id="bosss.foundation.grid.refelements.refelement.vertexindicestofaces"></a>
**Summary:** For some vertex (index) of this reference element, the faces (by
their index) which share this vertex;
1st index: vertex index;
2nd index: collection, no special order


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_VertexIndicesToCoFaces <a id="bosss.foundation.grid.refelements.refelement.m_vertexindicestocofaces"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.VertexIndicesToCoFaces](#bosss.foundation.grid.refelements.refelement.vertexindicestocofaces)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.VertexIndicesToCoFaces <a id="bosss.foundation.grid.refelements.refelement.vertexindicestocofaces"></a>
**Summary:** For some vertex (index) of this reference element, the co-faces
(by their index) which share this vertex;
1st index: vertex index;
2nd index: collection, no special order


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceToVertexIndices <a id="bosss.foundation.grid.refelements.refelement.m_facetovertexindices"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.FaceToVertexIndices](#bosss.foundation.grid.refelements.refelement.facetovertexindices)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceToVertexIndices <a id="bosss.foundation.grid.refelements.refelement.facetovertexindices"></a>
**Summary:** For all faces, the vertex indices of the reference element that make up the face;


1st index: face index, in the range of 0 to [BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces](#bosss.foundation.grid.refelements.refelement.nooffaces).


2nd index: face vertex index, in the range of 0 to [BoSSS.Foundation.Grid.RefElements.RefElement.FaceRefElement](#bosss.foundation.grid.refelements.refelement.facerefelement).


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceCenters <a id="bosss.foundation.grid.refelements.refelement.facecenters"></a>
**Summary:** Geometric center of all faces; 
1st index: face index, in the range of 0 to [BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces](#bosss.foundation.grid.refelements.refelement.nooffaces); 
2nd index: spatial dimension, in the range of 0 (including) to
[BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension) (excluding)


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceCenter(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getfacecenter(system.int32)"></a>
**Summary:** Center of each face.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceCenters <a id="bosss.foundation.grid.refelements.refelement.m_facecenters"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.FaceCenters](#bosss.foundation.grid.refelements.refelement.facecenters)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceNormals <a id="bosss.foundation.grid.refelements.refelement.facenormals"></a>
**Summary:** Normal vectors on all faces;
- 1st index: face index, in the range of 0 to [BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces](#bosss.foundation.grid.refelements.refelement.nooffaces);
- 2nd index: spatial dimension, in the range of 0 (including) to [BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension](#bosss.foundation.grid.refelements.refelement.spatialdimension) (excluding)


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceNormal(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getfacenormal(system.int32)"></a>
**Summary:** returns the normal for a specific face, i.e., a row from [BoSSS.Foundation.Grid.RefElements.RefElement.FaceNormals](#bosss.foundation.grid.refelements.refelement.facenormals)


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_FaceNormals <a id="bosss.foundation.grid.refelements.refelement.m_facenormals"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.FaceNormals](#bosss.foundation.grid.refelements.refelement.facenormals)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SpatialDimension <a id="bosss.foundation.grid.refelements.refelement.spatialdimension"></a>
**Summary:** The dimension of the reference element in the sense of measure-theory.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.Vertices <a id="bosss.foundation.grid.refelements.refelement.vertices"></a>
**Summary:** The vertices of the element in local coordinates;
Geometrically, the element is defined to be the convex hull of
these points;
**Remark:**
Indices are defined as follows:


1st index: Vertex index


2nd index: spatial dimension, 0 for 1D and 0,1 for 2D and 0,1,2
for 3D


The average (center of gravity) of these points must be 0. The
number of vertices must be at least D+1, where D
denotes the spatial dimension. Furthermore, if the vertices are
denoted as p[0], p[1], ... p[D],
the vectors
(p[1] - p[0], ... , p[D] - p[0])
must form a basis of the D-dimensional space.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_Vertices <a id="bosss.foundation.grid.refelements.refelement.m_vertices"></a>
**Summary:** See [BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices)


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetFaceVertices(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getfacevertices(system.int32)"></a>
**Summary:** Returns the vertices of the 'iFace'--th face.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.IsWithin(System.Double[]) <a id="bosss.foundation.grid.refelements.refelement.iswithin(system.double[])"></a>
**Summary:** tests whether a point 'pt', in local coordinates,
lies within this simplex, i.e. is element of the convex hull of the
[BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices)
**Parameter:** `pt` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.RefElement.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.refelement.iswithin(system.double[],system.double)"></a>
**Summary:** Tests whether a point 'pt', in local coordinates,
lies within this simplex (with a tolerance given by
'tolerance'), i.e. is element of the convex hull
of the [BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices)
**Parameter:** `pt` - 
**Parameter:** `tolerance` - A (small) positive number giving the tolerance (again, in the local
coordinate system) of the check.
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.RefElement.ClosestPoint(System.Double[],System.Double[]) <a id="bosss.foundation.grid.refelements.refelement.closestpoint(system.double[],system.double[])"></a>
**Summary:** Computes, for point 'pt_in', the closest point on
the boundary of the reference element ('pt_out').
**Parameter:** `pt_in` - input; some point in local cell coordinates
**Parameter:** `pt_out` - output; closest point on reference element boundary, in local
coordinates.
**Returns:**
the distance


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32)"></a>
**Summary:** provides a quadrature rule of desired or higher order;
**Parameter:** `DesiredOrder` - The desired polynomial degree that should integrated exactly
by the given quadrature rule;
highest valid value is provided
by [BoSSS.Foundation.Grid.RefElements.RefElement.HighestKnownOrder](#bosss.foundation.grid.refelements.refelement.highestknownorder);
**Returns:**
the real order of the returned quadrature rule
[BoSSS.Foundation.Quadrature.QuadRule.OrderOfPrecision](#bosss.foundation.quadrature.quadrule.orderofprecision)
may be greater or equal to 'DesiredOrder';


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetBoundaryQuadRule(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getboundaryquadrule(system.int32)"></a>
**Summary:** creates a rule for integrating over the boundary of this reference element


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetBruteForceQuadRule(System.Int32,System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getbruteforcequadrule(system.int32,system.int32)"></a>
**Summary:** Provides a brute-force quadrature rule (suitable for integrating
**Parameter:** `NoOfSubDiv` - depth of the subdivision-tree which is used to construct the 
brute-force - rule (see [BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivisionTree(System.Int32)](#bosss.foundation.grid.refelements.refelement.getsubdivisiontree(system.int32)));
**Parameter:** `BaseRuleOrder` - quad rule order of the base rule which is "multiplied"
**Returns:**



### Property: BoSSS.Foundation.Grid.RefElements.RefElement.HighestKnownOrder <a id="bosss.foundation.grid.refelements.refelement.highestknownorder"></a>
**Summary:** order of the most precise quadrature rule which is available for
this reference element


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetMaxDiameter <a id="bosss.foundation.grid.refelements.refelement.getmaxdiameter"></a>
**Summary:** the maximum distance between two vertices of the simplex
([BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices));
**Returns:**



### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_QuadRules <a id="bosss.foundation.grid.refelements.refelement.m_quadrules"></a>
**Summary:** collection of all available quadrature rules for this simplex;


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.OrthonormalPolynomials <a id="bosss.foundation.grid.refelements.refelement.orthonormalpolynomials"></a>
**Summary:** Orthonormal polynomials with respect to the reference element, sorted by degree.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetOrthonormalPolynomials(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getorthonormalpolynomials(system.int32)"></a>
**Summary:** Returns a complete basis of orthonormal polynomials up to degree 'MaxDeg'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetNoOfOrthonormalPolynomialsForDegree(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getnooforthonormalpolynomialsfordegree(system.int32)"></a>
**Summary:** Number of polynomials with an absolute degree equal to 'p'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetNoOfOrthonormalPolynomialsUptoDegree(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getnooforthonormalpolynomialsuptodegree(system.int32)"></a>
**Summary:** Number of polynomials with an absolute degree smaller or equal to 'p'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivision <a id="bosss.foundation.grid.refelements.refelement.getsubdivision"></a>
**Summary:** Provides transformations for a subdivision of this simplex.
**Returns:**
An list of transformations, which map the vertices of this simplex
([BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices)) to the vertices of the sub-simplexes.
**Remark:**
By a subdivision (of an simplex), we mean a complete, disjoint
partitioning into a number of n simplexes of similar shape.

Note for implementers: The return value of this method should be
equal every time;


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisonVertices <a id="bosss.foundation.grid.refelements.refelement.subdivisonvertices"></a>
**Summary:** returns the vertices for the first subdivision level;
**Remark:**
array indices: the 1st index corresponds with the return value of
[BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivision](#bosss.foundation.grid.refelements.refelement.getsubdivision);
2nd and 3rd index are defined like for [BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices)


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.m_SubdivisonVertices <a id="bosss.foundation.grid.refelements.refelement.m_subdivisonvertices"></a>
**Summary:** cache for [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisonVertices](#bosss.foundation.grid.refelements.refelement.subdivisonvertices)


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivisionTree(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getsubdivisiontree(system.int32)"></a>
**Parameter:** `Levels` - 
**Returns:**


## Class: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode"></a>

**Summary:** One node of a subdivision tree, as provided by [BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivisionTree(System.Int32)](#bosss.foundation.grid.refelements.refelement.getsubdivisiontree(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.#ctor(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Creates the root object of the tree
**Parameter:** `s` - 


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode,BoSSS.Platform.LinAlg.AffineTrafo) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.#ctor(bosss.foundation.grid.refelements.refelement.subdivisiontreenode,bosss.platform.linalg.affinetrafo)"></a>
**Summary:** recursive ctor.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.CollectGlobalVerticesRecursive(System.Collections.Generic.List{System.Double[]},System.Double) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.collectglobalverticesrecursive(system.collections.generic.list{system.double[]},system.double)"></a>
**Parameter:** `__GlobalVertice` - 
**Parameter:** `EqualDiamPow2` - two vertices are considered equal, if their squared Euclidean distance is 
smaller or equal to this number;


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLeavesRecursive(System.Collections.Generic.List{BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode}) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getleavesrecursive(system.collections.generic.list{bosss.foundation.grid.refelements.refelement.subdivisiontreenode})"></a>
**Summary:** implementation of [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLeaves](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getleaves);
**Parameter:** `outp` - 


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLeaves <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getleaves"></a>
**Summary:** Returns all leaves of the subdivision tree,
i.e. all nodes which have no child's.
**Returns:**



### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.RefinementLevel <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.refinementlevel"></a>
**Summary:** The refinement level of this node in the tree.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLevel <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getlevel"></a>
**Summary:** Returns all tree nodes on the actual refinement level (see [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.RefinementLevel](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.refinementlevel)).


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetFaceVertices(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getfacevertices(system.int32)"></a>
**Summary:** Returns the vertices of the 'iFace'--th face.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_NeighborIndex <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_neighborindex"></a>
**Summary:** Cache for [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetNeighbor(System.Int32)](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getneighbor(system.int32)).


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_NeighborFace <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_neighborface"></a>
**Summary:** Cache for [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetNeighbor(System.Int32)](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getneighbor(system.int32)).


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetNeighbor(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getneighbor(system.int32)"></a>
**Summary:** Neighbor ship information on the respective refinement level.
**Parameter:** `iFace` - A face index of the reference element.
**Returns:**
An pair
- item 1: neighbor index, i.e. index into the return value of [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLevel](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getlevel).
- item 2: face index of the neighbor 
Negative return values indicate that there is no neighbor at 'iFace'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLevelRecursive(System.Collections.Generic.List{BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode},System.Int32) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getlevelrecursive(system.collections.generic.list{bosss.foundation.grid.refelements.refelement.subdivisiontreenode},system.int32)"></a>
**Summary:** Implementation of [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetLeaves](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getleaves);


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.RefElement <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.refelement"></a>
**Summary:** The reference element which created the root object of this subdivision tree
during the invocation of [BoSSS.Foundation.Grid.RefElements.RefElement.GetSubdivisionTree(System.Int32)](#bosss.foundation.grid.refelements.refelement.getsubdivisiontree(system.int32));


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Vertices <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.vertices"></a>
**Summary:** 1st index: Vertex index
2nd index: spatial dimension


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_GlobalVerticeInd <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_globalverticeind"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GlobalVerticeInd](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.globalverticeind)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GlobalVerticeInd <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.globalverticeind"></a>
**Summary:** Indices of the vertices that belong to this node 
in the [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GlobalVertice](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.globalvertice)-array.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_GlobalVertice <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_globalvertice"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_GlobalVertice](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_globalvertice)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GlobalVertice <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.globalvertice"></a>
**Summary:** Global vertex list of the whole subdivision tree.

1st index: global Vertex index
2nd index: spatial dimension
**Remark:**
The returned object is reference-equal for all object in the 
subdivision tree.


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_Parrent <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_parrent"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.parrent)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Parrent <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.parrent"></a>
**Summary:** Parent node of this


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.TreeRoot <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.treeroot"></a>
**Summary:** Root of the tree/ancestor of all [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.parrent)s.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetParrentIndex <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getparrentindex"></a>
**Returns:**



### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Parrent <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2parrent"></a>
**Summary:** Affine-linear transformation from the local coordinates of this node
to the coordinate system of the parent node.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.TrafoFromParrent <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafofromparrent"></a>
**Summary:** The inverse of [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2parrent)


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Root <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2root"></a>
**Summary:** Affine-linear transformation from the local coordinates of this node
to the coordinate system of the root node of the subdivision tree.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.TrafoFromRoot <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafofromroot"></a>
**Summary:** inverse of [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Root](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2root)


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.InitializeTrafo <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.initializetrafo"></a>
**Summary:** initializes [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2parrent) and [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Trafo2Root](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.trafo2root);
Therefore, it is required that [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_parrent) and [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Vertices](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.vertices)
are correctly initialized. 
If [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.m_Parrent](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.m_parrent) is null, the transformations are set to be the idenity;


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetRoot <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getroot"></a>
**Summary:** returns the root of this tree of objects
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.SubdivideRecursive(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.subdividerecursive(system.int32)"></a>


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.Children <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.children"></a>
**Summary:** Can be null, is 
initialized by calling [BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.SubdivideRecursive(System.Int32)](#bosss.foundation.grid.refelements.refelement.subdivisiontreenode.subdividerecursive(system.int32))


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SubdivisionTreeNode.GetBasisTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.subdivisiontreenode.getbasistrafo(system.int32)"></a>
**Summary:** Computes a transformation matrix $A$, which expresses the orthonormal polynomials in the root of the subdivision tree,
$\underline{\phi}^{\text{root}}$, in terms of the orthonormal polynomials in this leaf, $\underline{\phi}^{\text{leaf}}$,
i.e.
\f[
\underline{\phi}^{\text{root}} = \underline{\phi}^{\text{leaf}} A .
\f]
**Parameter:** `p` - Polynomial degree.
**Returns:**
the transformation matrix, which is upper-triangular.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.Equals(System.Object) <a id="bosss.foundation.grid.refelements.refelement.equals(system.object)"></a>
**Summary:** equality


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetHashCode <a id="bosss.foundation.grid.refelements.refelement.gethashcode"></a>
**Summary:** base impl.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.Equals(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.refelements.refelement.equals(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** equality


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** returns the interpolation nodes for this reference element/the
specific 'type'


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationnodes(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** returns the interpolation nodes for this reference element/the
specific 'type'


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NodeType(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nodetype(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** returns the interpolation nodes types for this reference
element/the specific 'type'


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_EntityIndices(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationnodes_entityindices(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** returns the interpolation entity indices for this reference
element/the specific 'type'


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationPolynomials(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationpolynomials(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** Returns the interpolation polynomials for this reference
element/the specific 'type'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationPolynomials1stDeriv(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationpolynomials1stderiv(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** Returns the first derivatives/the gradient 
of the interpolation polynomials for this reference
element/the specific 'type'.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationDegree(BoSSS.Foundation.Grid.RefElements.CellType) <a id="bosss.foundation.grid.refelements.refelement.getinterpolationdegree(bosss.foundation.grid.refelements.celltype)"></a>
**Summary:** returns the polynomial degree of the local-to-global -- mapping;


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.SupportedCellTypes <a id="bosss.foundation.grid.refelements.refelement.supportedcelltypes"></a>
**Summary:** returns a list of supported minor cell index types


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SwitchNode(System.Int32@,System.Int32@) <a id="bosss.foundation.grid.refelements.refelement.switchnode(system.int32@,system.int32@)"></a>
**Summary:** helper function to switch array elements;

## Class: BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats <a id="bosss.foundation.grid.refelements.refelement.exchangeformats"></a>

**Summary:** List of known meshing tools / file formants


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats.GambitNeutral <a id="bosss.foundation.grid.refelements.refelement.exchangeformats.gambitneutral"></a>
**Summary:** Gambit Neutral file format ('*.neu'-files)


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats.Gmsh <a id="bosss.foundation.grid.refelements.refelement.exchangeformats.gmsh"></a>
**Summary:** Gmsh Mesh files ('*.msh');


### Field: BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats.CGNS <a id="bosss.foundation.grid.refelements.refelement.exchangeformats.cgns"></a>
**Summary:** CFD General Notation System (CGNS);


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats) <a id="bosss.foundation.grid.refelements.refelement.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats)"></a>
**Summary:** provides a permutation between BoSSS element numbering convention
and other tools
**Parameter:** `type` - 
**Parameter:** `conv` - 
**Returns:**
the mapping from BoSSS to Foreign elements; 
index i: BoSSS vertex index; 
content c[i]: node index in the 'foreign'
specification;
If the return value is null, the specific element, determined by
the 'type', is not supported in the foreign
specification;


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** converts a BoSSS Element specification (given by the object type of
this object **System.Object.GetType**, the minor type index
'type') into a foreign specification.
**Parameter:** `type` - BoSSS cell type specification
**Parameter:** `conv` - Foreign format convention
**Parameter:** `ForeignName` - If specified in the 'conv'-convention, the element
name.
**Parameter:** `ForeignTypeConstant` - If specified in the 'conv'-convention, some integer
constant which identifies the element type..
**Returns:**
false, if the element is not supported in the
'conv'-specification


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.ComputeForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.refelement.computeforeignelementmapping(bosss.foundation.grid.refelements.celltype,ilpsp.multidimensionalarray)"></a>
**Summary:** provides a permutation between BoSSS element numbering convention
and other tools
**Parameter:** `type` - The BoSSS type of the cell
**Parameter:** `ForeignNodes` - Interpolation nodes, in any user defined sequence; however, the
nodes must be the same as the ones that BoSSS is using;
Use an Affine transformation, if necessary (see
[BoSSS.Platform.LinAlg.AffineTrafo](BoSSS.Platform.md#bosss.platform.linalg.affinetrafo)).
**Returns:**
the mapping from BoSSS to Foreign elements; 
index i: BoSSS node index; 
content c[i]: node index in the 'foreign'
specification;
If the return value is null, the specific element, determined by
the 'type', is not supported in the foreign
specification;

## Class: BoSSS.Foundation.Grid.RefElements.RefElement.CoFaceInfo <a id="bosss.foundation.grid.refelements.refelement.cofaceinfo"></a>

**Summary:** helper structure


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.CoFaceVerticeIndices <a id="bosss.foundation.grid.refelements.refelement.cofaceverticeindices"></a>
**Summary:** Vertex indices of the co-faces;
- 1st index: co-face index iCoFace
- 2nd index: vertex index of the Co-Face


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.CoFaceToFaceIndices <a id="bosss.foundation.grid.refelements.refelement.cofacetofaceindices"></a>
**Summary:** For each co-face, the indices of the faces whose geometric intersection forms the iCoFace-th co-face.
- 1st index: co-face index iCoFace 
- 2nd index: in {0,1}, corresponds to first and second face.
**Remark:**
Note that each co-face can be described as the geometric intersection of 2 faces.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.FaceToCoFaceIndices <a id="bosss.foundation.grid.refelements.refelement.facetocofaceindices"></a>
**Summary:** - 1st index: face-index
- 2nd index: face-index of the face


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.CoFaceToFaceFaceIndex <a id="bosss.foundation.grid.refelements.refelement.cofacetofacefaceindex"></a>
**Summary:** Correlates with [BoSSS.Foundation.Grid.RefElements.RefElement.CoFaceToFaceIndices](#bosss.foundation.grid.refelements.refelement.cofacetofaceindices):
For each co-face, the face index of the face reference element which it corresponds to.
- 1st index: co-face index iCoFace 
- 2nd index: in {0,1}, corresponds to first and second face.


### Property: BoSSS.Foundation.Grid.RefElements.RefElement.NoOfCoFaces <a id="bosss.foundation.grid.refelements.refelement.noofcofaces"></a>
**Summary:** number of co-faces


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetCoFaceTrafo(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getcofacetrafo(system.int32)"></a>
**Summary:** Transformation from the local coordinate system of the co-face to the local coordinate system for this reference element.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetFacePlane(System.Int32) <a id="bosss.foundation.grid.refelements.refelement.getfaceplane(system.int32)"></a>
**Summary:** For each face, the affine manifold that represents the plane in which the face is located;
**Parameter:** `iFace` - face index


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** Returns a node-set
**Parameter:** `px` - Number of subdivisions in each direction.
**Parameter:** `Nodes` - 2D-array, 1st index: node index, 2nd index: spatial direction
**Parameter:** `Type` - The location of the node within the cell; 
Index: node index;

in 1D: 0 for cells, 1 for edges
in 2D: 0 for cells/volumes, 1 for edges/faces, 2 for corners
in 3D: 0 for cells/volumes, 1 for faces, 2 for edges, 3 for corners


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,BoSSS.Foundation.NodeSet@,System.Int32[]@,System.Int32[]@,System.Int32[]) <a id="bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,bosss.foundation.nodeset@,system.int32[]@,system.int32[]@,system.int32[])"></a>
**Summary:** Returns a node-set
**Parameter:** `P` - Number of subdivisions in each direction, along one edge.
**Parameter:** `Nodes` - 2D-array, 1st index: node index, 2nd index: spatial direction
**Parameter:** `Type` - The location of the node within the cell; 
Index: node index;

in 1D: 0 for cells (volume nodes, volume is 1D), 1 for vertices (vertex nodes, faces are 0D, i.e. points or vertices)
in 2D: 0 for cells (volume nodes, volume is 2D), 
1 for edges (face nodes, faces are 1D, i.e. lines),  
2 for corners (in 2D the vertices correlate with the co-faces, i.e. 0D objects)
in 3D: 0 for cells (volume nodes, volume is 3D), 
1 for faces (face nodes, the faces are 2D - polygons, e.g. rectangles or triangles),
2 for edges (co-face nodes: co-faces are the edges of the faces; these are lines) 
3 for corners (etc.)
**Parameter:** `EntityIndex` - If the k-th node is 

a type 0 nodes, i.e. a cell node, 'EntityIndex'[k] is always 0.
a face node, 'EntityIndex'[k] is the index of the face within this reference element.
a co-face node, 'EntityIndex'[k] is the index of the co-face within this reference element
a vertex node, 'EntityIndex'[k] is the index of the vertex within this reference element
**Parameter:** `TypeFilter` - Node types (see 'Type') which should be filtered OUT, i.e. nodes with types in 'TypeFilter' will be omitted.


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SelectNodalPolynomials(System.Int32,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@,System.Func{BoSSS.Foundation.Grid.Polynomial,System.Boolean},System.Int32[]) <a id="bosss.foundation.grid.refelements.refelement.selectnodalpolynomials(system.int32,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@,system.func{bosss.foundation.grid.polynomial,system.boolean},system.int32[])"></a>
**Summary:** Creates a node-set and a corresponding set of nodal polynomials;


## Method: BoSSS.Foundation.Grid.RefElements.RefElement.SelectNodalPolynomials(System.Int32,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@,ilPSP.MultidimensionalArray@,ilPSP.MultidimensionalArray@,System.Func{BoSSS.Foundation.Grid.Polynomial,System.Boolean},System.Int32[]) <a id="bosss.foundation.grid.refelements.refelement.selectnodalpolynomials(system.int32,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@,ilpsp.multidimensionalarray@,ilpsp.multidimensionalarray@,system.func{bosss.foundation.grid.polynomial,system.boolean},system.int32[])"></a>
**Summary:** Creates a node-set and a corresponding set of nodal polynomials;

## Class: BoSSS.Foundation.Grid.RefElements.Square <a id="bosss.foundation.grid.refelements.square"></a>

**Summary:** a simplex [-1,1]x[-1,1] for 2D Cartesian grids;

## Class: BoSSS.Foundation.Grid.RefElements.Square.Faces <a id="bosss.foundation.grid.refelements.square.faces"></a>

**Summary:** Indicates all four edges of the square


### Field: BoSSS.Foundation.Grid.RefElements.Square.Faces.Left <a id="bosss.foundation.grid.refelements.square.faces.left"></a>
**Summary:** edge between this cell and the neighbor cell with x - coordinates closer to negative infinity


### Field: BoSSS.Foundation.Grid.RefElements.Square.Faces.Right <a id="bosss.foundation.grid.refelements.square.faces.right"></a>
**Summary:** edge between this cell and the neighbor cell with x - coordinates closer to positive infinity


### Field: BoSSS.Foundation.Grid.RefElements.Square.Faces.Top <a id="bosss.foundation.grid.refelements.square.faces.top"></a>
**Summary:** edge between this cell and the neighbor cell with y - coordinates closer to positive infinity


### Field: BoSSS.Foundation.Grid.RefElements.Square.Faces.Bottom <a id="bosss.foundation.grid.refelements.square.faces.bottom"></a>
**Summary:** edge between this cell and the neighbor cell with y - coordinates closer to negative infinity


### Property: BoSSS.Foundation.Grid.RefElements.Square.Instance <a id="bosss.foundation.grid.refelements.square.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Square.#ctor <a id="bosss.foundation.grid.refelements.square.#ctor"></a>
**Summary:** constructs a new square simplex


## Method: BoSSS.Foundation.Grid.RefElements.Square.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.square.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms some vertices ('EdgeVertices') from the local 1D-coordinate system of either
the top, bottom, left or right edge to the local coordinate system of the square;
**Parameter:** `EdgeIndex` - 0, 1, 2, or 3; [BoSSS.Foundation.Grid.RefElements.Square.Faces](#bosss.foundation.grid.refelements.square.faces)
**Parameter:** `EdgeVertices` - input;
**Parameter:** `VolumeVertices` - output;


## Method: BoSSS.Foundation.Grid.RefElements.Square.GetSubdivision <a id="bosss.foundation.grid.refelements.square.getsubdivision"></a>
**Summary:** divides the [-1,1]x[-1,1] - square into 4 squares of equal size;
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Square.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.square.iswithin(system.double[],system.double)"></a>
**Summary:** tests whether 'pt' is within the convex hull of
vertices or not;
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Square.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.square.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Square.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.square.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Square.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats) <a id="bosss.foundation.grid.refelements.square.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats)](#bosss.foundation.grid.refelements.refelement.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Square.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.square.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Parameter:** `ForeignName` - 
**Parameter:** `ForeignTypeConstant` - 

## Class: BoSSS.Foundation.Grid.RefElements.Tetra <a id="bosss.foundation.grid.refelements.tetra"></a>

**Summary:** The tetrahedral reference element $K^{\textrm{tetra}}$.

**Remark:**
The vertices of the tetrahedron are:
\f[ 
\left[
\left( 0, 0, \sqrt{2}  \right),
\left( 0, \frac{4}{3}, -\frac{\sqrt{2}}{3}  \right),
\left( -\frac{2}{3} \sqrt(3), -\frac{2}{3}, -\frac{\sqrt{2}}{3}  \right),
\left(  \frac{2}{3} \sqrt(3), -\frac{2}{3}, -\frac{\sqrt{2}}{3}  \right)
\right]
\f]

## Class: BoSSS.Foundation.Grid.RefElements.Tetra.Edge <a id="bosss.foundation.grid.refelements.tetra.edge"></a>

**Summary:** Indicator for the edges (which are triangles, see
[BoSSS.Foundation.Grid.RefElements.Triangle](#bosss.foundation.grid.refelements.triangle))


### Field: BoSSS.Foundation.Grid.RefElements.Tetra.Edge.Front <a id="bosss.foundation.grid.refelements.tetra.edge.front"></a>
**Summary:** The front edge. Formed by vertices 1, 2 and 3


### Field: BoSSS.Foundation.Grid.RefElements.Tetra.Edge.Bottom <a id="bosss.foundation.grid.refelements.tetra.edge.bottom"></a>
**Summary:** The bottom edge. Formed by vertices 0, 2 and 3


### Field: BoSSS.Foundation.Grid.RefElements.Tetra.Edge.BackLeft <a id="bosss.foundation.grid.refelements.tetra.edge.backleft"></a>
**Summary:** The back left edge. Formed by vertices 0, 1 and 2


### Field: BoSSS.Foundation.Grid.RefElements.Tetra.Edge.BackRight <a id="bosss.foundation.grid.refelements.tetra.edge.backright"></a>
**Summary:** The back right edge. Formed by vertices 0, 1 and 3


### Field: BoSSS.Foundation.Grid.RefElements.Tetra.vertexMatrix <a id="bosss.foundation.grid.refelements.tetra.vertexmatrix"></a>
**Summary:** Matrix based on the vertices (see [BoSSS.Foundation.Grid.RefElements.RefElement.Vertices](#bosss.foundation.grid.refelements.refelement.vertices))
of this object. Required by [BoSSS.Foundation.Grid.RefElements.Tetra.IsWithin(System.Double[],System.Double)](#bosss.foundation.grid.refelements.tetra.iswithin(system.double[],system.double)). Its layout is:
(x1, y1, z1, 1; x2, y2, z2, 1; x3, y3, z3, 1; x4, y4, z4, 1)


### Property: BoSSS.Foundation.Grid.RefElements.Tetra.Instance <a id="bosss.foundation.grid.refelements.tetra.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.#ctor <a id="bosss.foundation.grid.refelements.tetra.#ctor"></a>
**Summary:** Constructs a new tetrahedron simplex.


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.tetra.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** Transforms the coordinates of the 'EdgeVertices'
(which are given ins local coordinate system of the edge simplex)
to the coordinate system of this simplex.
**Parameter:** `EdgeIndex` - The [BoSSS.Foundation.Grid.RefElements.Tetra.Edge](#bosss.foundation.grid.refelements.tetra.edge) on which 'EdgeVertices' are
placed.
**Parameter:** `EdgeVertices` - The 2D-coordinates of the vertices to be transformed
**Parameter:** `VolumeVertices` - The result (e.g. the 3D-coordinates of the vertices)


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.GetSubdivision <a id="bosss.foundation.grid.refelements.tetra.getsubdivision"></a>
**Summary:** Evenly partitions this tetrahedron into eight sub-tetrahedrons of equal
size.
**Returns:**
An array with eight elements containing the linear transformations
**Remark:**
Code taken from [BoSSS.Foundation.Grid.RefElements.Triangle](#bosss.foundation.grid.refelements.triangle) and adapted to 3D.


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.tetra.iswithin(system.double[],system.double)"></a>
**Summary:** Tests whether 'pt' is within the convex hull of
vertices.
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Tetra.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.tetra.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.tetra.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Tetra.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats) <a id="bosss.foundation.grid.refelements.tetra.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementMapping(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats)](#bosss.foundation.grid.refelements.refelement.getforeignelementmapping(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats))
**Parameter:** `MinorCellTypeIndex` - 
**Parameter:** `conv` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Tetra.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.tetra.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Parameter:** `ForeignName` - 
**Parameter:** `ForeignTypeConstant` - 

## Class: BoSSS.Foundation.Grid.RefElements.Triangle <a id="bosss.foundation.grid.refelements.triangle"></a>

**Summary:** The triangular reference element $K^{\textrm{tri}}$.

**Remark:**
The vertices in the reference space are:
\f[
\left[
(0,                      \frac{4}{3}),
(-\frac{2}{3} \sqrt{3}, -\frac{2}{3}),
( \frac{2}{3} \sqrt{3}, -\frac{2}{3}) 
\right]
\f]


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.IsWithin(System.Double[],System.Double) <a id="bosss.foundation.grid.refelements.triangle.iswithin(system.double[],system.double)"></a>
**Summary:** tests whether 'pt' is within the convex hull of
vertices or not;
**Parameter:** `pt` - 
**Parameter:** `tolerance` - 
**Returns:**



### Property: BoSSS.Foundation.Grid.RefElements.Triangle.Instance <a id="bosss.foundation.grid.refelements.triangle.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.#ctor <a id="bosss.foundation.grid.refelements.triangle.#ctor"></a>
**Summary:** constructs a new triangle simplex


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.TransformFaceCoordinates(System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.refelements.triangle.transformfacecoordinates(system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms some vertices from local edge coordinates to the local coordinate system of this
simplex
**Parameter:** `FaceIndex` - specifies the face
**Parameter:** `EdgeVertices` - Input; Vertices in the local coordinate system of the edge;
1st index: vertex index; 2nd index: spatial coordinate index, the only valid value is 0;
**Parameter:** `VolumeVertices` - On exit, the 'EdgeVertices' transformed to the local coordinate system of this simplex;
1st index: vertex index;
2nd index: spatial coordinate vector, valid values are 0,1;


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.GetSubdivision <a id="bosss.foundation.grid.refelements.triangle.getsubdivision"></a>
**Summary:** partitions this triangle into 4 subtriangles of equal size;
**Returns:**



## Method: BoSSS.Foundation.Grid.RefElements.Triangle.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.triangle.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@)"></a>
**Summary:** see [BoSSS.Foundation.Grid.RefElements.RefElement.GetNodeSet(System.Int32,ilPSP.MultidimensionalArray@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getnodeset(system.int32,ilpsp.multidimensionalarray@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.refelements.triangle.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetInterpolationNodes_NonLin(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.NodeSet@,BoSSS.Foundation.Grid.PolynomialList@,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.refelements.refelement.getinterpolationnodes_nonlin(bosss.foundation.grid.refelements.celltype,bosss.foundation.nodeset@,bosss.foundation.grid.polynomiallist@,system.int32[]@,system.int32[]@))


## Method: BoSSS.Foundation.Grid.RefElements.Triangle.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@) <a id="bosss.foundation.grid.refelements.triangle.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@)"></a>
**Summary:** [BoSSS.Foundation.Grid.RefElements.RefElement.GetForeignElementType(BoSSS.Foundation.Grid.RefElements.CellType,BoSSS.Foundation.Grid.RefElements.RefElement.ExchangeFormats,System.String@,System.Int32@)](#bosss.foundation.grid.refelements.refelement.getforeignelementtype(bosss.foundation.grid.refelements.celltype,bosss.foundation.grid.refelements.refelement.exchangeformats,system.string@,system.int32@))
**Parameter:** `Type` - 
**Parameter:** `conv` - 
**Parameter:** `ForeignName` - 
**Parameter:** `ForeignTypeConstant` - 

## Class: BoSSS.Foundation.Grid.EdgeInfo <a id="bosss.foundation.grid.edgeinfo"></a>

**Summary:** Additional information


### Field: BoSSS.Foundation.Grid.EdgeInfo.Default <a id="bosss.foundation.grid.edgeinfo.default"></a>
**Summary:** edge with nothing special


### Field: BoSSS.Foundation.Grid.EdgeInfo.EdgeSimplexIdxMask <a id="bosss.foundation.grid.edgeinfo.edgesimplexidxmask"></a>
**Summary:** masks the region where the reference element index for the
edge is stored.


### Field: BoSSS.Foundation.Grid.EdgeInfo.Cell1_Nonconformal <a id="bosss.foundation.grid.edgeinfo.cell1_nonconformal"></a>
**Summary:** The edge is aligned to cell 1 (in-cell) in a non-conformal manner (hanging nodes).
If this is _not_ set, the edge covers an entire face of the corresponding cell.


### Field: BoSSS.Foundation.Grid.EdgeInfo.Cell2_Nonconformal <a id="bosss.foundation.grid.edgeinfo.cell2_nonconformal"></a>
**Summary:** the edge is aligned to cell 2 (out-cell) in a non-conformal manner (hanging nodes).
If this is _not_ set, the edge covers an entire face of the corresponding cell.


### Field: BoSSS.Foundation.Grid.EdgeInfo.EdgeIsAffineLinear <a id="bosss.foundation.grid.edgeinfo.edgeisaffinelinear"></a>
**Summary:** the transformation from the edge to the global coordinate
system is affine-linear. In this case, also the normal
vector is constant along the edge.


### Field: BoSSS.Foundation.Grid.EdgeInfo.Boundary <a id="bosss.foundation.grid.edgeinfo.boundary"></a>
**Summary:** edge is located on the boundary of the computational domain


### Field: BoSSS.Foundation.Grid.EdgeInfo.Interprocess <a id="bosss.foundation.grid.edgeinfo.interprocess"></a>
**Summary:** edge is locates on the border between two MPI processes


### Field: BoSSS.Foundation.Grid.EdgeInfo.IsAggregate <a id="bosss.foundation.grid.edgeinfo.isaggregate"></a>
**Summary:** marks cells which are aggregated from smaller parts


### Field: BoSSS.Foundation.Grid.EdgeInfo.AllOn <a id="bosss.foundation.grid.edgeinfo.allon"></a>
**Summary:** All flags on, implementing this ensures that the enum 
is compiled using 32 bits.

## Class: BoSSS.Foundation.Grid.EdgeMask <a id="bosss.foundation.grid.edgemask"></a>

**Summary:** masks some edges in a [BoSSS.Foundation.Grid.Classic.GridData](#bosss.foundation.grid.classic.griddata)-object


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** ctor
**Parameter:** `grddat` - 
**Parameter:** `mask` - a "true" entry for all edges in grid 'grddat' that should be in the mask;
The length of this array must not exceed [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Count](#bosss.foundation.grid.classic.griddata.edgedata.count)
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Func{System.Double[],System.Boolean},BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,system.func{system.double[],system.boolean},bosss.foundation.grid.masktype)"></a>
**Summary:** ctor
**Parameter:** `grddat` - 
**Parameter:** `GeomSelector` - Returns true, if the edge with given center coordinate should be in the mask, otherwise false.
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32[],BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,system.int32[],bosss.foundation.grid.masktype)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk[]) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk[])"></a>
**Summary:** compiles an edge mask from a set of chunks
**Parameter:** `parts` - a list of chunks, which may overlap
**Parameter:** `grddat` - the grid that this mask will be associated with;


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk,bosss.foundation.grid.masktype)"></a>
**Summary:** compiles an edge mask from a single chunk
**Parameter:** `part` - a chunk
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `mt` - 


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Creates an edge mask for all edges with an edge tag that
corresponds to the given 'edgeTagName'
**Parameter:** `gridData` - 
**Parameter:** `edgeTagName` - 


## Method: BoSSS.Foundation.Grid.EdgeMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Chunk},BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.#ctor(bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.grid.chunk},bosss.foundation.grid.masktype)"></a>
**Summary:** compiles an quadrature execution mask from a set of chunks
**Parameter:** `Parts` - a list of chunks, which may overlap
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.EdgeMask.GetEmptyMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.getemptymask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)"></a>
**Summary:** Retrieves an empty edge mask;
**Parameter:** `grdDat` - grid that the returned mask will be assigned to
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.EdgeMask.Complement <a id="bosss.foundation.grid.edgemask.complement"></a>
**Summary:** complimentary edge mask


## Method: BoSSS.Foundation.Grid.EdgeMask.GetFullMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.getfullmask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)"></a>
**Summary:** Retrieves a mask containing all edges (i.e. returns the
complement of [BoSSS.Foundation.Grid.EdgeMask.GetEmptyMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType)](#bosss.foundation.grid.edgemask.getemptymask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype)))
**Parameter:** `gridDat` - Grid data that the returned mask will be assigned with
**Parameter:** `mt` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)
**Returns:**
A full mask


## Method: BoSSS.Foundation.Grid.EdgeMask.CreateInstance(System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.edgemask.createinstance(system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** like ctor;


## Method: BoSSS.Foundation.Grid.EdgeMask.GetUpperIndexBound(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.edgemask.getupperindexbound(bosss.foundation.grid.igriddata)"></a>
**Summary:** see [BoSSS.Foundation.Grid.ExecutionMask.GetUpperIndexBound(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.grid.executionmask.getupperindexbound(bosss.foundation.grid.igriddata))


## Method: BoSSS.Foundation.Grid.EdgeMask.GetAdjacentCells <a id="bosss.foundation.grid.edgemask.getadjacentcells"></a>
**Summary:** computes a cell mask that contains all cells with an edge in this edge mask


## Method: BoSSS.Foundation.Grid.EdgeMask.GetAdjacentCellsCond(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.grid.edgemask.getadjacentcellscond(bosss.foundation.grid.cellmask)"></a>
**Summary:** a cell is in the returned cell mask if
it is a neighbor cell of this edge mask and if it is also neighbor of 'X'


## Method: BoSSS.Foundation.Grid.EdgeMask.SaveToTextFile(System.String,System.Boolean,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo[]) <a id="bosss.foundation.grid.edgemask.savetotextfile(system.string,system.boolean,bosss.foundation.grid.executionmask.iteminfo[])"></a>
**Summary:** Writes the mid-points of each edge in this mask to a text file with
the given name. Useful for debugging purposes.


## Method: BoSSS.Foundation.Grid.EdgeMask.GetBitMaskForEdgeTag(BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.grid.edgemask.getbitmaskforedgetag(bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Constructs the bit mask for all edges with an edge tag that
corresponds to the given 'edgeTagName'
**Parameter:** `gridData` - 
**Parameter:** `edgeTagName` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.EdgeMask.ToGeometicalMask <a id="bosss.foundation.grid.edgemask.togeometicalmask"></a>
**Summary:** Converts this  
from a logical ([BoSSS.Foundation.Grid.IGridData.iLogicalEdges](#bosss.foundation.grid.igriddata.ilogicaledges)) mask
to a geometrical ([BoSSS.Foundation.Grid.IGridData.iGeomEdges](#bosss.foundation.grid.igriddata.igeomedges)) mask.
**Returns:**


## Class: BoSSS.Foundation.Grid.Chunk <a id="bosss.foundation.grid.chunk"></a>

**Summary:** A single range of [BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len) items, (cells or edges) starting at [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0).
Used for the definition of a execution mask (see [BoSSS.Foundation.Grid.ExecutionMask](#bosss.foundation.grid.executionmask));


### Field: BoSSS.Foundation.Grid.Chunk.i0 <a id="bosss.foundation.grid.chunk.i0"></a>
**Summary:** local element (cell or edge) index at which the integration 
should start;


### Field: BoSSS.Foundation.Grid.Chunk.Len <a id="bosss.foundation.grid.chunk.len"></a>
**Summary:** number of elements (cells or edges) to perform quadrature
on;


### Property: BoSSS.Foundation.Grid.Chunk.JE <a id="bosss.foundation.grid.chunk.je"></a>
**Summary:** sum of [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0) and [BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len).


### Property: BoSSS.Foundation.Grid.Chunk.Elements <a id="bosss.foundation.grid.chunk.elements"></a>
**Summary:** Enumeration of all element indices contained in this chunk


## Method: BoSSS.Foundation.Grid.Chunk.Equals(System.Object) <a id="bosss.foundation.grid.chunk.equals(system.object)"></a>
**Summary:** See [BoSSS.Foundation.Grid.Chunk.Equals(BoSSS.Foundation.Grid.Chunk)](#bosss.foundation.grid.chunk.equals(bosss.foundation.grid.chunk))
**Parameter:** `obj` - See **System.Object.Equals(System.Object)**
**Returns:**
See [BoSSS.Foundation.Grid.Chunk.Equals(BoSSS.Foundation.Grid.Chunk)](#bosss.foundation.grid.chunk.equals(bosss.foundation.grid.chunk))


## Method: BoSSS.Foundation.Grid.Chunk.GetHashCode <a id="bosss.foundation.grid.chunk.gethashcode"></a>
**Summary:** Builds a hash based on [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0) and [BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len)
**Returns:**
A hash code


## Method: BoSSS.Foundation.Grid.Chunk.Equals(BoSSS.Foundation.Grid.Chunk) <a id="bosss.foundation.grid.chunk.equals(bosss.foundation.grid.chunk)"></a>
**Summary:** Checks whether this chunk is equal to the given chunk by comparing
[BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0) and [BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len).
**Parameter:** `other` - The chunk for which equality should be checked.
**Returns:**
True, if [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0) and [BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len) are equal for both
chunks. False, otherwise.


## Method: BoSSS.Foundation.Grid.Chunk.GetSingleElementChunk(System.Int32) <a id="bosss.foundation.grid.chunk.getsingleelementchunk(system.int32)"></a>
**Summary:** Creates a chunk of length 1.
**Parameter:** `element` - The only element in the chunk.
**Returns:**
A chunk which includes 'element' only.

## Class: BoSSS.Foundation.Grid.MaskType <a id="bosss.foundation.grid.masktype"></a>

**Summary:** For an execution mask ([BoSSS.Foundation.Grid.ExecutionMask](#bosss.foundation.grid.executionmask), [BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask), [BoSSS.Foundation.Grid.EdgeMask](#bosss.foundation.grid.edgemask)),
whether it refers to logical entities (e.g. aggregation cells) or 
geometrical entities (i.e. the parts of an aggregate cell).


### Field: BoSSS.Foundation.Grid.MaskType.Logical <a id="bosss.foundation.grid.masktype.logical"></a>
**Summary:** Execution mask is defined on logical cells resp. edges
([BoSSS.Foundation.Grid.IGridData.iLogicalCells](#bosss.foundation.grid.igriddata.ilogicalcells) resp. [BoSSS.Foundation.Grid.IGridData.iLogicalEdges](#bosss.foundation.grid.igriddata.ilogicaledges)).


### Field: BoSSS.Foundation.Grid.MaskType.Geometrical <a id="bosss.foundation.grid.masktype.geometrical"></a>
**Summary:** Execution mask is defined on geometrical cells resp. edges
([BoSSS.Foundation.Grid.IGridData.iGeomCells](#bosss.foundation.grid.igriddata.igeomcells) resp. [BoSSS.Foundation.Grid.IGridData.iGeomEdges](#bosss.foundation.grid.igriddata.igeomedges)).

## Class: BoSSS.Foundation.Grid.ExecutionMask <a id="bosss.foundation.grid.executionmask"></a>

**Summary:** The grid mask is one core part of the subgrid framework;
The [BoSSS.Foundation.Grid.SubGrid](#bosss.foundation.grid.subgrid)-object uses
cell masks (see [BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask))
and edge masks (see [BoSSS.Foundation.Grid.EdgeMask](#bosss.foundation.grid.edgemask))
to memorize which parts of the whole grid 
belong to the subgrid.


### Property: BoSSS.Foundation.Grid.ExecutionMask.MaskType <a id="bosss.foundation.grid.executionmask.masktype"></a>
**Summary:** Whether this mask refers to logical entities (e.g. aggregation cells) or 
geometrical entities (i.e. the parts of an aggregate cell).


### Field: BoSSS.Foundation.Grid.ExecutionMask.Sequence <a id="bosss.foundation.grid.executionmask.sequence"></a>
**Summary:** Main storage entity of this class. Encoding: 


entry i is positive number v:
A [BoSSS.Foundation.Grid.Chunk](#bosss.foundation.grid.chunk) with [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0)==v-1 and
[BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len)==1;


entry i is negative number v:
A [BoSSS.Foundation.Grid.Chunk](#bosss.foundation.grid.chunk) with [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0)== -v-1 and
[BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len)==[BoSSS.Foundation.Grid.ExecutionMask.Sequence](#bosss.foundation.grid.executionmask.sequence)[i+1];


### Field: BoSSS.Foundation.Grid.ExecutionMask.m_BitMask <a id="bosss.foundation.grid.executionmask.m_bitmask"></a>
**Summary:** Cache for the bit mask corresponding to the mask defined by the
sequence in [BoSSS.Foundation.Grid.ExecutionMask.Sequence](#bosss.foundation.grid.executionmask.sequence)


### Field: BoSSS.Foundation.Grid.ExecutionMask.m_IMax <a id="bosss.foundation.grid.executionmask.m_imax"></a>
**Summary:** [BoSSS.Foundation.Grid.ExecutionMask.IMax](#bosss.foundation.grid.executionmask.imax)


### Property: BoSSS.Foundation.Grid.ExecutionMask.GridData <a id="bosss.foundation.grid.executionmask.griddata"></a>
**Summary:** the grid that this mask is associated with (necessary for methods like [BoSSS.Foundation.Grid.ExecutionMask.Complement``1](#bosss.foundation.grid.executionmask.complement``1), ...)


## Method: BoSSS.Foundation.Grid.ExecutionMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.executionmask.#ctor(bosss.foundation.grid.igriddata,system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** Builds an execution mask from a bit array. If an entry is set to
true in the bit array, it indicates that an element should be part
of the execution mask.
**Parameter:** `Mask` - The mask as **System.Collections.BitArray**
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `__MaskType` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.ExecutionMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32[],BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.executionmask.#ctor(bosss.foundation.grid.igriddata,system.int32[],bosss.foundation.grid.masktype)"></a>
**Summary:** For those users who know what they are doing, here 
a fast version without any 'compilation'; The parameters are not
checked;
**Parameter:** `_Sequence` - encoding of the quadrature execution mask: 


entry i is positive number v:
A [BoSSS.Foundation.Grid.Chunk](#bosss.foundation.grid.chunk) with [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0)==v-1 and
[BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len)==1;


entry i is negative number v:
A [BoSSS.Foundation.Grid.Chunk](#bosss.foundation.grid.chunk) with [BoSSS.Foundation.Grid.Chunk.i0](#bosss.foundation.grid.chunk.i0)== -v-1 and
[BoSSS.Foundation.Grid.Chunk.Len](#bosss.foundation.grid.chunk.len)==[BoSSS.Foundation.Grid.ExecutionMask.Sequence](#bosss.foundation.grid.executionmask.sequence)[i+1];
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `__MaskType` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.ExecutionMask.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{System.Int32},BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.executionmask.#ctor(bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{system.int32},bosss.foundation.grid.masktype)"></a>
**Summary:** Compiles an quadrature execution mask from a set of indices
**Parameter:** `Indices` - A list of indices, duplicates are ignored
**Parameter:** `grddat` - the grid that this mask will be associated with;
**Parameter:** `__MaskType` - [BoSSS.Foundation.Grid.ExecutionMask.MaskType](#bosss.foundation.grid.executionmask.masktype)


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetBitMask <a id="bosss.foundation.grid.executionmask.getbitmask"></a>
**Summary:** returns a bitmask which marks the same items as this object
**Remark:**
see also [BoSSS.Foundation.Grid.CellMask.GetBitMaskWithExternal](#bosss.foundation.grid.cellmask.getbitmaskwithexternal)


## Method: BoSSS.Foundation.Grid.ExecutionMask.Intersect``1(``0) <a id="bosss.foundation.grid.executionmask.intersect``1(``0)"></a>
**Summary:** Creates an execution mask which only contains elements that are
included in this mask and in the given mask
'otherMask'.
**Parameter:** `otherMask` - The mask to intersect this mask with
**Returns:**
A new execution mask representing
$\mathrm{this} \cap \mathrm{otherMask}$


## Method: BoSSS.Foundation.Grid.ExecutionMask.CreateInstance(System.Collections.BitArray,BoSSS.Foundation.Grid.MaskType) <a id="bosss.foundation.grid.executionmask.createinstance(system.collections.bitarray,bosss.foundation.grid.masktype)"></a>
**Summary:** similar to constructor


## Method: BoSSS.Foundation.Grid.ExecutionMask.Except``1(``0) <a id="bosss.foundation.grid.executionmask.except``1(``0)"></a>
**Summary:** Creates an execution mask which only contains elements that are
included in this mask but not in 'otherMask',
**Parameter:** `otherMask` - The mask containing the elements to exclude
**Returns:**
A new execution mask representing
$\mathrm{this} \setminus \mathrm{otherMask}$


## Method: BoSSS.Foundation.Grid.ExecutionMask.Union``1(``0,``0) <a id="bosss.foundation.grid.executionmask.union``1(``0,``0)"></a>
**Summary:** Creates an execution mask that is the union of two masks;
**Parameter:** `maskA` - 1st operand
**Parameter:** `maskB` - 2nd operand
**Returns:**
the union (logical OR) of 'maskA' and 'maskB'


## Method: BoSSS.Foundation.Grid.ExecutionMask.Intersect``1(``0,``0) <a id="bosss.foundation.grid.executionmask.intersect``1(``0,``0)"></a>
**Summary:** Creates an execution mask that is the intersection of two masks;
**Parameter:** `maskA` - 1st operand
**Parameter:** `maskB` - 2nd operand
**Returns:**
the intersection (logical OR) of 'maskA' and 'maskB'


## Method: BoSSS.Foundation.Grid.ExecutionMask.Union``1(``0) <a id="bosss.foundation.grid.executionmask.union``1(``0)"></a>
**Summary:** Creates an execution mask which only contains elements that are
included in this mask OR in the given mask
'otherMask'.
**Parameter:** `otherMask` - The mask to union this mask with
**Returns:**
A new execution mask representing
$\mathrm{this} \cup \mathrm{otherMask}$


### Property: BoSSS.Foundation.Grid.ExecutionMask.IMax <a id="bosss.foundation.grid.executionmask.imax"></a>
**Summary:** The highest used element (cell or edge) index in this execution
mask; For an empty mask, it is -1;


### Property: BoSSS.Foundation.Grid.ExecutionMask.NoOfItemsLocally <a id="bosss.foundation.grid.executionmask.noofitemslocally"></a>
**Summary:** number of mask items (cells or edges), locally on this MPI process


## Method: BoSSS.Foundation.Grid.ExecutionMask.Equals(System.Object) <a id="bosss.foundation.grid.executionmask.equals(system.object)"></a>
**Summary:** Compares two masks according to the masked
elements
**Parameter:** `obj` - The object to compare this object to
**Returns:**
True, if the given object represents a mask of the same type (cell/edge)
containing exactly the same cells/edges as this object.


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetHashCode <a id="bosss.foundation.grid.executionmask.gethashcode"></a>
**Summary:** **System.Object.GetHashCode**
**Returns:**
**System.Object.GetHashCode**


## Method: BoSSS.Foundation.Grid.ExecutionMask.CompIMax <a id="bosss.foundation.grid.executionmask.compimax"></a>
**Summary:** Computes [BoSSS.Foundation.Grid.ExecutionMask.IMax](#bosss.foundation.grid.executionmask.imax)


## Method: BoSSS.Foundation.Grid.ExecutionMask.PushChunk(System.Collections.Generic.List{System.Int32},BoSSS.Foundation.Grid.Chunk) <a id="bosss.foundation.grid.executionmask.pushchunk(system.collections.generic.list{system.int32},bosss.foundation.grid.chunk)"></a>
**Summary:** Pushes chunk 'c' onto 'seq' by
encoding it according to the entries of [BoSSS.Foundation.Grid.ExecutionMask.Sequence](#bosss.foundation.grid.executionmask.sequence)
**Parameter:** `seq` - The list the chunk will be pushed onto
**Parameter:** `c` - The chunk to be pushed


## Method: BoSSS.Foundation.Grid.ExecutionMask.FromChunkEnum(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Chunk}) <a id="bosss.foundation.grid.executionmask.fromchunkenum(system.collections.generic.ienumerable{bosss.foundation.grid.chunk})"></a>
**Summary:** Transforms a list of chunks into a sequence.
**Parameter:** `parts` - The chunks


## Method: BoSSS.Foundation.Grid.ExecutionMask.FromIndEnum(System.Collections.Generic.IEnumerable{System.Int32}) <a id="bosss.foundation.grid.executionmask.fromindenum(system.collections.generic.ienumerable{system.int32})"></a>
**Summary:** Constructs the **System.Collections.BitArray** representation of the given
list of indices
**Parameter:** `Indices` - A list of entries that are contained in the mask
**Returns:**
A **System.Collections.BitArray** representation of the mask defined by
'Indices'


## Method: BoSSS.Foundation.Grid.ExecutionMask.Complement``1 <a id="bosss.foundation.grid.executionmask.complement``1"></a>
**Summary:** Complement of this execution mask (all elements that are not in this mask);


## Method: BoSSS.Foundation.Grid.ExecutionMask.Complement``1(``0) <a id="bosss.foundation.grid.executionmask.complement``1(``0)"></a>
**Summary:** static version of [BoSSS.Foundation.Grid.ExecutionMask.Complement``1](#bosss.foundation.grid.executionmask.complement``1)


### Property: BoSSS.Foundation.Grid.ExecutionMask.IsEmptyOnRank <a id="bosss.foundation.grid.executionmask.isemptyonrank"></a>
**Summary:** true if this mask contains no items on he current MPI process


## Method: BoSSS.Foundation.Grid.ExecutionMask.IsSubMaskOf(BoSSS.Foundation.Grid.ExecutionMask) <a id="bosss.foundation.grid.executionmask.issubmaskof(bosss.foundation.grid.executionmask)"></a>
**Summary:** true if this mask is a subset of 'o'


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetUpperIndexBound(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.executionmask.getupperindexbound(bosss.foundation.grid.igriddata)"></a>
**Summary:** Retrieves the upper limit of the index range, depending on the type of mask:
- [BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells), for logical cell mask ([BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask), [BoSSS.Foundation.Grid.MaskType.Logical](#bosss.foundation.grid.masktype.logical))
- [BoSSS.Foundation.Grid.IGeometricalCellsData.Count](#bosss.foundation.grid.igeometricalcellsdata.count), for geometrical cell mask ([BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask), [BoSSS.Foundation.Grid.MaskType.Geometrical](#bosss.foundation.grid.masktype.geometrical))
- [BoSSS.Foundation.Grid.ILogicalEdgeData.Count](#bosss.foundation.grid.ilogicaledgedata.count), for logical edge mask ([BoSSS.Foundation.Grid.EdgeMask](#bosss.foundation.grid.edgemask), [BoSSS.Foundation.Grid.MaskType.Logical](#bosss.foundation.grid.masktype.logical))
- [BoSSS.Foundation.Grid.IGeometricalEdgeData.Count](#bosss.foundation.grid.igeometricaledgedata.count), for geometrical edge mask ([BoSSS.Foundation.Grid.EdgeMask](#bosss.foundation.grid.edgemask), [BoSSS.Foundation.Grid.MaskType.Geometrical](#bosss.foundation.grid.masktype.geometrical))
**Parameter:** `gridData` - The grid data object referring to the grid elements that should be
masked by an execution mask
**Returns:**


## Class: BoSSS.Foundation.Grid.ExecutionMask.ItemInfo <a id="bosss.foundation.grid.executionmask.iteminfo"></a>

**Summary:** used by [BoSSS.Foundation.Grid.ExecutionMask.SaveToTextFile(System.String,System.Boolean,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo[])](#bosss.foundation.grid.executionmask.savetotextfile(system.string,system.boolean,bosss.foundation.grid.executionmask.iteminfo[]))


## Method: BoSSS.Foundation.Grid.ExecutionMask.SaveToTextFile(System.String,System.Boolean,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo[]) <a id="bosss.foundation.grid.executionmask.savetotextfile(system.string,system.boolean,bosss.foundation.grid.executionmask.iteminfo[])"></a>
**Summary:** Serializes all elements of this mask (identified by global/physical coordinates) to a CSV format and saves the
result in a file with the given 'fileName'.
**Parameter:** `fileName` - The name of the file to contain the results.
**Parameter:** `infoFunc` - Optional; provides information that a user may want to append to the list of coordinates, for each item.
**Parameter:** `WriteHeader` - if true, the first line of the file will contain column names


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetSummary <a id="bosss.foundation.grid.executionmask.getsummary"></a>
**Summary:** Used for displaying a summary of this mask in the debugger
**Returns:**



## Method: BoSSS.Foundation.Grid.ExecutionMask.Contains(System.Int32) <a id="bosss.foundation.grid.executionmask.contains(system.int32)"></a>
**Summary:** Checks whether the given 'element' is contained
in this mask
**Parameter:** `element` - The element in question
**Returns:**
True, if 'element' is contained in this execution
mask; false otherwise.


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetEnumerator <a id="bosss.foundation.grid.executionmask.getenumerator"></a>
**Summary:** Chunk-wise enumeration
**Returns:**
A new [BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator](#bosss.foundation.grid.executionmask.chunkenumerator)


## Method: BoSSS.Foundation.Grid.ExecutionMask.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.grid.executionmask.system#collections#ienumerable#getenumerator"></a>
**Summary:** Chunk-wise enumeration
**Returns:**
a new [BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator](#bosss.foundation.grid.executionmask.chunkenumerator)

## Class: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator <a id="bosss.foundation.grid.executionmask.chunkenumerator"></a>

**Summary:** Enumerates over the execution mask, one [BoSSS.Foundation.Grid.Chunk](#bosss.foundation.grid.chunk) at a
time


### Field: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.owner <a id="bosss.foundation.grid.executionmask.chunkenumerator.owner"></a>
**Summary:** The creator of this enumerator


### Field: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.cnt <a id="bosss.foundation.grid.executionmask.chunkenumerator.cnt"></a>
**Summary:** Counter into [BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.owner](#bosss.foundation.grid.executionmask.chunkenumerator.owner).[BoSSS.Foundation.Grid.ExecutionMask.Sequence](#bosss.foundation.grid.executionmask.sequence)


### Field: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.curr <a id="bosss.foundation.grid.executionmask.chunkenumerator.curr"></a>
**Summary:** [BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.Current](#bosss.foundation.grid.executionmask.chunkenumerator.current)


## Method: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.#ctor(BoSSS.Foundation.Grid.ExecutionMask) <a id="bosss.foundation.grid.executionmask.chunkenumerator.#ctor(bosss.foundation.grid.executionmask)"></a>
**Summary:** Creates a new enumerator
**Parameter:** `__owner` - The creator of this enumerator


### Property: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.Current <a id="bosss.foundation.grid.executionmask.chunkenumerator.current"></a>
**Summary:** The current chunk


## Method: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.Dispose <a id="bosss.foundation.grid.executionmask.chunkenumerator.dispose"></a>
**Summary:** Empty


### Property: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.System#Collections#IEnumerator#Current <a id="bosss.foundation.grid.executionmask.chunkenumerator.system#collections#ienumerator#current"></a>
**Summary:** Returns the current chunk


## Method: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.MoveNext <a id="bosss.foundation.grid.executionmask.chunkenumerator.movenext"></a>
**Summary:** Advances to the next chunk in [BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.owner](#bosss.foundation.grid.executionmask.chunkenumerator.owner).Sequence
**Returns:**



## Method: BoSSS.Foundation.Grid.ExecutionMask.ChunkEnumerator.Reset <a id="bosss.foundation.grid.executionmask.chunkenumerator.reset"></a>
**Summary:** Returns to the first chunk


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetItemEnumerator <a id="bosss.foundation.grid.executionmask.getitemenumerator"></a>
**Summary:** An enumerator which contains all items/indices in this mask;


### Property: BoSSS.Foundation.Grid.ExecutionMask.ItemEnum <a id="bosss.foundation.grid.executionmask.itemenum"></a>
**Summary:** An enumerable which contains all items/indices in this mask;


## Method: BoSSS.Foundation.Grid.ExecutionMask.GetIndex2MaskItemMap <a id="bosss.foundation.grid.executionmask.getindex2maskitemmap"></a>
**Summary:** Returns an array which maps indices of cells or edges to indices into this masks items.
**Returns:**


## Class: BoSSS.Foundation.Grid.GridPartType <a id="bosss.foundation.grid.gridparttype"></a>

**Summary:** methods to compute/define a grid distribution


### Field: BoSSS.Foundation.Grid.GridPartType.ParMETIS <a id="bosss.foundation.grid.gridparttype.parmetis"></a>
**Summary:** use [BoSSS.Foundation.Grid.GridPartType.ParMETIS](#bosss.foundation.grid.gridparttype.parmetis) (parallel partitioning)


### Field: BoSSS.Foundation.Grid.GridPartType.Predefined <a id="bosss.foundation.grid.gridparttype.predefined"></a>
**Summary:** Predefined partition.


### Field: BoSSS.Foundation.Grid.GridPartType.clusterHilbert <a id="bosss.foundation.grid.gridparttype.clusterhilbert"></a>
**Summary:** Partitioning according to space-filling clusterHilbert curve considering Clusters, ...


### Field: BoSSS.Foundation.Grid.GridPartType.Hilbert <a id="bosss.foundation.grid.gridparttype.hilbert"></a>
**Summary:** Partitioning according to space-filling clusterHilbert curve, direct Costmapping ...


### Field: BoSSS.Foundation.Grid.GridPartType.none <a id="bosss.foundation.grid.gridparttype.none"></a>
**Summary:** leave grid as it is; The first J/P cells will be on first processor, ...


### Field: BoSSS.Foundation.Grid.GridPartType.METIS <a id="bosss.foundation.grid.gridparttype.metis"></a>
**Summary:** Use [BoSSS.Foundation.Grid.GridPartType.METIS](#bosss.foundation.grid.gridparttype.metis) (serial partitioning)


### Field: BoSSS.Foundation.Grid.GridPartType.OtherSession <a id="bosss.foundation.grid.gridparttype.othersession"></a>
**Summary:** Mostly for debugging:
Using a partitioning stored in a field `MPIrank` in another session;
the session ID is drawn from the partitioning options string, see [BoSSS.Foundation.Grid.IGrid.Redistribute(BoSSS.Foundation.IO.IDatabaseInfo,BoSSS.Foundation.Grid.GridPartType,System.String)](#bosss.foundation.grid.igrid.redistribute(bosss.foundation.io.idatabaseinfo,bosss.foundation.grid.gridparttype,system.string))

## Class: BoSSS.Foundation.Grid.IGrid <a id="bosss.foundation.grid.igrid"></a>

**Summary:** Common interface for all grids


### Property: BoSSS.Foundation.Grid.IGrid.iGridData <a id="bosss.foundation.grid.igrid.igriddata"></a>
**Summary:** Access to grid metrics


## Method: BoSSS.Foundation.Grid.IGrid.InvalidateGridData <a id="bosss.foundation.grid.igrid.invalidategriddata"></a>
**Summary:** Releases the object cached in [BoSSS.Foundation.Grid.IGrid.iGridData](#bosss.foundation.grid.igrid.igriddata); this is necessary if 
the grid object was changed somehow.


## Method: BoSSS.Foundation.Grid.IGrid.Redistribute(BoSSS.Foundation.IO.IDatabaseInfo,BoSSS.Foundation.Grid.GridPartType,System.String) <a id="bosss.foundation.grid.igrid.redistribute(bosss.foundation.io.idatabaseinfo,bosss.foundation.grid.gridparttype,system.string)"></a>
**Summary:** Driver method for grid redistribution; this includes 
- computing a new partition 
- application of the partition to this grid, i.e. invocation off [BoSSS.Foundation.Grid.IGrid.RedistributeGrid(System.Int32[])](#bosss.foundation.grid.igrid.redistributegrid(system.int32[]))


## Method: BoSSS.Foundation.Grid.IGrid.RedistributeGrid(System.Int32[]) <a id="bosss.foundation.grid.igrid.redistributegrid(system.int32[])"></a>
**Summary:** Low-level interface:
redistributes this grid, i.e. sends cells to different processors
**Parameter:** `part` -
- index: local cell index;
- content: MPI processor rank for respective cell;


### Property: BoSSS.Foundation.Grid.IGrid.MyRank <a id="bosss.foundation.grid.igrid.myrank"></a>
**Summary:** MPI process rank (within world communicator)


### Property: BoSSS.Foundation.Grid.IGrid.Size <a id="bosss.foundation.grid.igrid.size"></a>
**Summary:** MPI world communicator size


### Property: BoSSS.Foundation.Grid.IGrid.CellPartitioning <a id="bosss.foundation.grid.igrid.cellpartitioning"></a>
**Summary:** Gets the partition of cells over the MPI processes;


### Property: BoSSS.Foundation.Grid.IGrid.GridSerializationHandler <a id="bosss.foundation.grid.igrid.gridserializationhandler"></a>
**Summary:** %


### Property: BoSSS.Foundation.Grid.IGrid.PeriodicTrafo <a id="bosss.foundation.grid.igrid.periodictrafo"></a>
**Summary:** list of transformations which describe how some edges should be transformed to other edges;
**Remark:**
indices into this list are edge tags ([BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags](#bosss.foundation.grid.igeometricaledgedata.edgetags) minus [BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag))

## Class: BoSSS.Foundation.Grid.IGridData <a id="bosss.foundation.grid.igriddata"></a>

**Summary:** Common interface for all kinds of grids/meshes


### Property: BoSSS.Foundation.Grid.IGridData.MpiRank <a id="bosss.foundation.grid.igriddata.mpirank"></a>
**Summary:** MPI process rank (within world communicator)


### Property: BoSSS.Foundation.Grid.IGridData.MpiSize <a id="bosss.foundation.grid.igriddata.mpisize"></a>
**Summary:** MPI world communicator size


### Property: BoSSS.Foundation.Grid.IGridData.GridID <a id="bosss.foundation.grid.igriddata.gridid"></a>
**Summary:** Identification of the grid in the BoSSS database, 
equal to the [BoSSS.Foundation.IO.IDatabaseEntityInfo`1.ID](#bosss.foundation.io.idatabaseentityinfo`1.id).


### Property: BoSSS.Foundation.Grid.IGridData.Grid <a id="bosss.foundation.grid.igriddata.grid"></a>
**Summary:** return the grid


### Property: BoSSS.Foundation.Grid.IGridData.MultigridSequence <a id="bosss.foundation.grid.igriddata.multigridsequence"></a>
**Summary:** an optional (i.e. can be null) multi-grid hierarchy


## Method: BoSSS.Foundation.Grid.IGridData.IsAlive <a id="bosss.foundation.grid.igriddata.isalive"></a>
**Summary:** returns true, until [BoSSS.Foundation.Grid.IGrid.InvalidateGridData](#bosss.foundation.grid.igrid.invalidategriddata) has been called


### Property: BoSSS.Foundation.Grid.IGridData.EdgeTagNames <a id="bosss.foundation.grid.igriddata.edgetagnames"></a>
**Summary:** This is a mapping from each used EdgeTag, (see [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags](#bosss.foundation.grid.igeometricaledgedata.edgetags)) to a string that
provides a name and additional information about the EdgeTag. The
intention for this member is to provide both, a name (e.g.
'Left wall') for different regions of the boundary as well as
boundary condition type info (e.g. 'inlet' or 'wall' or 'outflow' ...).


### Property: BoSSS.Foundation.Grid.IGridData.iGeomCells <a id="bosss.foundation.grid.igriddata.igeomcells"></a>
**Summary:** %


### Property: BoSSS.Foundation.Grid.IGridData.iLogicalCells <a id="bosss.foundation.grid.igriddata.ilogicalcells"></a>
**Summary:** %


### Property: BoSSS.Foundation.Grid.IGridData.iVertices <a id="bosss.foundation.grid.igriddata.ivertices"></a>
**Summary:** Information about the vertices of the grid elements, see
[BoSSS.Foundation.Grid.IVertexData](#bosss.foundation.grid.ivertexdata).


### Property: BoSSS.Foundation.Grid.IGridData.iGeomEdges <a id="bosss.foundation.grid.igriddata.igeomedges"></a>
**Summary:** metrics and operations which are associated to edges


### Property: BoSSS.Foundation.Grid.IGridData.iLogicalEdges <a id="bosss.foundation.grid.igriddata.ilogicaledges"></a>
**Summary:** metrics and operations which are associated to edges


### Property: BoSSS.Foundation.Grid.IGridData.iParallel <a id="bosss.foundation.grid.igriddata.iparallel"></a>
**Summary:** see [BoSSS.Foundation.Grid.IParallelization](#bosss.foundation.grid.iparallelization)


### Property: BoSSS.Foundation.Grid.IGridData.SpatialDimension <a id="bosss.foundation.grid.igriddata.spatialdimension"></a>
**Summary:** The spatial dimension of the grid (usually 1, 2 or 3).


### Property: BoSSS.Foundation.Grid.IGridData.ChefBasis <a id="bosss.foundation.grid.igriddata.chefbasis"></a>
**Summary:** Evaluation of the DG basis on the grid


### Property: BoSSS.Foundation.Grid.IGridData.CellPartitioning <a id="bosss.foundation.grid.igriddata.cellpartitioning"></a>
**Summary:** Gets the partitioning of cells over the MPI processes;


### Property: BoSSS.Foundation.Grid.IGridData.CurrentGlobalIdPermutation <a id="bosss.foundation.grid.igriddata.currentglobalidpermutation"></a>
**Summary:** The global ID for each cell


## Method: BoSSS.Foundation.Grid.IGridData.TransformLocal2Global(ilPSP.MultidimensionalArray,System.Int32,System.Int32,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.igriddata.transformlocal2global(ilpsp.multidimensionalarray,system.int32,system.int32,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** transforms vertices from the local coordinate system of cells
'j0' to 'j0'+'Len'-1
to global coordinates;
**Parameter:** `LocalVerticesIn` - Input; vertices in the local coordinate system of a cell;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `GlobalVerticesOut` - Output; the vertices form 'LocalVerticesIn',
transformed to global coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of
'LocalVerticesIn';


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `j0` - local cell index of the first cell to transform
**Parameter:** `Len` - Number of cells to transform
**Parameter:** `OutArrayOffset` - an offset into the first index of 'GlobalVerticesOut';


## Method: BoSSS.Foundation.Grid.IGridData.TransformLocal2Global(ilPSP.MultidimensionalArray,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.igriddata.transformlocal2global(ilpsp.multidimensionalarray,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** transforms the 'NS'-th node set to global coordinates of
cell 'j0' to 'j0'+'Len'-1
**Parameter:** `j0` - first cell to transform
**Parameter:** `Len` - number of cells to transform
**Parameter:** `NS` - 
**Parameter:** `Nodesglob` - output, global coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of the
local nodes references by 'NS'


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;


## Method: BoSSS.Foundation.Grid.IGridData.TransformGlobal2Local(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.grid.igriddata.transformglobal2local(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.int32,system.int32)"></a>
**Summary:** Transforms vertices from the global coordinate system to the local coordinate systems 
of geometrical cells 'j0' to 'j0'+'Len'-1.
**Parameter:** `GlobalVerticesIn` - Input; vertices in the global coordinate system;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `LocalVerticesOut` - Output; the vertices form 'GlobalVerticesIn',
transformed to local coordinates;


1st index: local cell index minus 'j0', in the
range of 0 to 'Len'-1;


2nd index: vertex index, corresponds with the 1st index of
'GlobalVerticesIn';


3rd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `j0` - local cell index of the first cell to transform
**Parameter:** `Len` - Number of cells to transform
**Parameter:** `OutArrayOffset` - an offset into the first index of 'LocalVerticesOut';


## Method: BoSSS.Foundation.Grid.IGridData.TransformGlobal2Local(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Boolean[]) <a id="bosss.foundation.grid.igriddata.transformglobal2local(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.boolean[])"></a>
**Summary:** transforms vertices from the global coordinate system
the local coordinate systems 
of cells
'jCell'.
**Parameter:** `GlobalVerticesIn` - Input; vertices in the global coordinate system;

1st index: vertex index;

2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `LocalVerticesOut` - Output; the vertices form 'GlobalVerticesIn', transformed to local coordinates;


1st index: vertex index, corresponds with the 1st index of
'GlobalVerticesIn';


2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and
0,1,2 for 3D;
**Parameter:** `jCell` - local cell index of the cell to transform
**Parameter:** `NewtonConvergence` - in the case of curved cells/isoparametic elements, where a Newton algorithm has to be used for the inverse transformation, 
diagnostic information whether the Newton algorithm has converged or not.
The index correlates with the vertex index in 'GlobalVerticesIn'.


### Property: BoSSS.Foundation.Grid.IGridData.GlobalNodes <a id="bosss.foundation.grid.igriddata.globalnodes"></a>
**Summary:** Cached transformation of node sets to global coordinates.


### Property: BoSSS.Foundation.Grid.IGridData.Jacobian <a id="bosss.foundation.grid.igriddata.jacobian"></a>
**Summary:** Jacobian of transformation from reference to physical space, $(\nabla T_j)$.


### Property: BoSSS.Foundation.Grid.IGridData.AdjungateJacobian <a id="bosss.foundation.grid.igriddata.adjungatejacobian"></a>
**Summary:** Adjungate of the Jacobian of the reference-to-physical coordinate transformation, 
$\mathrm{Adj}( \nabla T_j ) =  \mathrm{Adj}( \nabla T_j ) ( \nabla T_j )^{-1}$.


### Property: BoSSS.Foundation.Grid.IGridData.InverseJacobian <a id="bosss.foundation.grid.igriddata.inversejacobian"></a>
**Summary:** Inverse of the Jacobian of the reference-to-physical coordinate transformation, $( \nabla T_j )^{-1}$.


### Property: BoSSS.Foundation.Grid.IGridData.JacobianDeterminat <a id="bosss.foundation.grid.igriddata.jacobiandeterminat"></a>
**Summary:** Determinant of the Jacobian of the reference-to-physical coordinate transformation, $\mathrm{Adj}( \nabla T_j )$.

## Class: BoSSS.Foundation.Grid.IGeometricalCellsData <a id="bosss.foundation.grid.igeometricalcellsdata"></a>

**Summary:** Geometrical properties of cells; in the case of an aggregation grids ([BoSSS.Foundation.Grid.Aggregation.AggregationGridData](#bosss.foundation.grid.aggregation.aggregationgriddata)), 
the geometrical properties of the cell parts.


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.Count <a id="bosss.foundation.grid.igeometricalcellsdata.count"></a>
**Summary:** Number of geometrical cells (including external)


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.NoOfLocalUpdatedCells <a id="bosss.foundation.grid.igeometricalcellsdata.nooflocalupdatedcells"></a>
**Summary:** Number of locally updated cells - the cells which are computed on this processor (in contrast, external/ghost cells from other MPI processors).


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetCellType(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getcelltype(system.int32)"></a>
**Summary:** Cell type for cell 'jCell'.


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.JacobiDet <a id="bosss.foundation.grid.igeometricalcellsdata.jacobidet"></a>
**Summary:** For affine-linear cells,
the absolute value of the (Jacobi) determinant of the 
transformation from local cell coordinate system to global
coordinate system.
- 1st index: local geometrical cell index;


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.InverseTransformation <a id="bosss.foundation.grid.igeometricalcellsdata.inversetransformation"></a>
**Summary:** Inverse matrices to [BoSSS.Foundation.Grid.IGeometricalCellsData.Transformation](#bosss.foundation.grid.igeometricalcellsdata.transformation)
**Remark:**
Indices are defined as follows:
- 1st index: local cell index (locally updated and external cells);
- 2nd index: matrix row index;
- 3rd index: matrix column index;


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.Transformation <a id="bosss.foundation.grid.igeometricalcellsdata.transformation"></a>
**Summary:** For all affine-linear cells, the 
linear part of the affine-linear transformation
from the local coordinate 
system of some cell to
the global coordinate system, or Jacobi-matrix.
**Remark:**
Indices are defined as follows:
- 1st index: local cell index (locally updated and external cells);
- 2nd index: matrix row index;
- 3rd index: matrix column index;


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.InfoFlags <a id="bosss.foundation.grid.igeometricalcellsdata.infoflags"></a>
**Summary:** See [BoSSS.Foundation.Grid.CellInfo](#bosss.foundation.grid.cellinfo).


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.CellVertices <a id="bosss.foundation.grid.igeometricalcellsdata.cellvertices"></a>
**Summary:** Mapping from cells to vertices/nodes of the grid (stored in
[BoSSS.Foundation.Grid.IVertexData.Coordinates](#bosss.foundation.grid.ivertexdata.coordinates)) 
- content: indices into [BoSSS.Foundation.Grid.IVertexData.Coordinates](#bosss.foundation.grid.ivertexdata.coordinates) 
- 1st index: local cell index (externals included) 
- 2nd index: cell vertex index


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetRefElementIndex(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getrefelementindex(system.int32)"></a>
**Summary:** Returns the reference element index (an index into [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)) for cell 'jCell'.
**Parameter:** `jCell` - local cell index.
**Returns:**
reference element index.


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetRefElement(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getrefelement(system.int32)"></a>
**Summary:** Returns the reference element (one of [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)) for cell 'j'.


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.IsCellAffineLinear(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.iscellaffinelinear(system.int32)"></a>
**Summary:** True, if the mapping from the reference/local coordinates to physical coordinates
**Parameter:** `jCell` - local cell index.
**Returns:**
reference element index.


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements <a id="bosss.foundation.grid.igeometricalcellsdata.refelements"></a>
**Summary:** All reference elements for cells, see [BoSSS.Foundation.Grid.IGeometricalCellsData.GetRefElementIndex(System.Int32)](#bosss.foundation.grid.igeometricalcellsdata.getrefelementindex(system.int32)) resp. [BoSSS.Foundation.Grid.IGeometricalCellsData.GetRefElement(System.Int32)](#bosss.foundation.grid.igeometricalcellsdata.getrefelement(system.int32)).


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetCellVolume(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getcellvolume(system.int32)"></a>
**Summary:** Returns the volume (to be more exact: the [BoSSS.Foundation.IO.IGridInfo.SpatialDimension](#bosss.foundation.io.igridinfo.spatialdimension) - dimensional measure) 
of the cell 'j';
**Parameter:** `j` - local cell index
**Returns:**



## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetCellBoundingBox(System.Int32,BoSSS.Platform.Utils.Geom.BoundingBox) <a id="bosss.foundation.grid.igeometricalcellsdata.getcellboundingbox(system.int32,bosss.platform.utils.geom.boundingbox)"></a>
**Summary:** Computes the bounding box of cell 'j'.
**Parameter:** `j` - local cell index.
**Parameter:** `bb` - on exit, the bounding box of cell j.


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetNoOfSimilarConsecutiveCells(BoSSS.Foundation.Grid.CellInfo,System.Int32,System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getnoofsimilarconsecutivecells(bosss.foundation.grid.cellinfo,system.int32,system.int32)"></a>
**Summary:** Aids the vectorization of various code parts.
**Parameter:** `mask` - masks which properties of the cell information (see
[BoSSS.Foundation.Grid.IGeometricalCellsData.InfoFlags](#bosss.foundation.grid.igeometricalcellsdata.infoflags)) should be considered.
**Parameter:** `j0` - start index.
**Parameter:** `Lmax` - upper limit for the return value of this function
**Returns:**
the number of consecutive cells after cell
'j0', which share the same information flags,
or 'Lmax', whichever is lower.


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.h_min <a id="bosss.foundation.grid.igeometricalcellsdata.h_min"></a>
**Summary:** The minimal Euclidean distance between two distinct vertices for each cell;
(Can be used e.g. to compute the CFL number);
- index: local cell index;


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.h_max <a id="bosss.foundation.grid.igeometricalcellsdata.h_max"></a>
**Summary:** The maximal Euclidean distance between two vertices for each cell;
(Can be used e.g. to compute the CFL number);
- index: local cell index;


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetCells4Refelement(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.igeometricalcellsdata.getcells4refelement(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Cell-Mask of all geometric cells which share the same reference element.


### Property: BoSSS.Foundation.Grid.IGeometricalCellsData.GeomCell2LogicalCell <a id="bosss.foundation.grid.igeometricalcellsdata.geomcell2logicalcell"></a>
**Summary:** Mapping form geometrical to logical cells; this is the inverse to [BoSSS.Foundation.Grid.ILogicalCellData.AggregateCellToParts](#bosss.foundation.grid.ilogicalcelldata.aggregatecelltoparts)


## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetInterpolationDegree(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getinterpolationdegree(system.int32)"></a>
**Summary:** polynomial interpolation degree of the Reference-to-Global coordinate transformation.
**Parameter:** `jCell` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.IGeometricalCellsData.GetCenter(System.Int32) <a id="bosss.foundation.grid.igeometricalcellsdata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity for the cell

## Class: BoSSS.Foundation.Grid.ILogicalCellData <a id="bosss.foundation.grid.ilogicalcelldata"></a>

**Summary:** Properties of logical cell; A logical cell can be described as:
- A logical cell may be composed of one or more geometrical parts.
- there is always a single set of DG modes for one logical cell.
- for typical meshes (no aggregation) the relation between logical and geometrical cells is 1:1


## Method: BoSSS.Foundation.Grid.ILogicalCellData.GetGlobalID(System.Int32) <a id="bosss.foundation.grid.ilogicalcelldata.getglobalid(system.int32)"></a>
**Summary:** Global identification (a cell index which remains constant under re-partitioning) for the 'j'-th cell.
**Parameter:** `j` - Local cell index.
**Returns:**
Global Id.


### Property: BoSSS.Foundation.Grid.ILogicalCellData.CellNeighbours <a id="bosss.foundation.grid.ilogicalcelldata.cellneighbours"></a>
**Summary:** local indices of neighbor cells;
- 1st index: local cell index;
- 2nd index: enumeration


### Property: BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells <a id="bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells"></a>
**Summary:** Number of locally updated cells - the cells which are computed on
this processor (in contrast, see [BoSSS.Foundation.Grid.ILogicalCellData.NoOfExternalCells](#bosss.foundation.grid.ilogicalcelldata.noofexternalcells));


### Property: BoSSS.Foundation.Grid.ILogicalCellData.NoOfExternalCells <a id="bosss.foundation.grid.ilogicalcelldata.noofexternalcells"></a>
**Summary:** Number of locally stored external cells - no computations are carried out for
that cells, but their values are needed.


### Property: BoSSS.Foundation.Grid.ILogicalCellData.Count <a id="bosss.foundation.grid.ilogicalcelldata.count"></a>
**Summary:** [BoSSS.Foundation.Grid.ILogicalCellData.NoOfExternalCells](#bosss.foundation.grid.ilogicalcelldata.noofexternalcells) plus [BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells);


### Property: BoSSS.Foundation.Grid.ILogicalCellData.AggregateCellToParts <a id="bosss.foundation.grid.ilogicalcelldata.aggregatecelltoparts"></a>
**Summary:** Mapping from logical cells to geometrical cells; only required if geometrical and logical cells are not identical, *otherwise null*.
- 1st index: local (logical) cell index
- 2nd index: enumeration of geometrical cells (parts)
This is the inverse to [BoSSS.Foundation.Grid.IGeometricalCellsData.GeomCell2LogicalCell](#bosss.foundation.grid.igeometricalcellsdata.geomcell2logicalcell).


### Property: BoSSS.Foundation.Grid.ILogicalCellData.Cells2Edges <a id="bosss.foundation.grid.ilogicalcelldata.cells2edges"></a>
**Summary:** Which edges (see [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)) bound to which cells? 
- 1st index: local cell index j, only local updated
- 2nd index: collection, order is arbitrary; 
- content e: If e is positive, then cell j is the first
(IN) cell of edge e - 1. Otherwise, if e is
negative, then cell j is the second (OUT) cell of edge -e - 1.
**Remark:**
Note: the second index does NOT correlate with the face index
of the cell. This is because, in the case of hanging nodes, the
number of edges that bound to one cell is not equal to the
number of faces, i.e., more than one edge is associated with
one face.


## Method: BoSSS.Foundation.Grid.ILogicalCellData.IsCellAffineLinear(System.Int32) <a id="bosss.foundation.grid.ilogicalcelldata.iscellaffinelinear(system.int32)"></a>
**Summary:** True, if _all_ geometrical cells which make up this logical cell are affine-linear.
**Parameter:** `jCell` - local cell index.
**Returns:**
reference element index.


## Method: BoSSS.Foundation.Grid.ILogicalCellData.GetCellVolume(System.Int32) <a id="bosss.foundation.grid.ilogicalcelldata.getcellvolume(system.int32)"></a>
**Summary:** Returns the volume (to be more exact: the
[BoSSS.Foundation.Grid.IGridData.SpatialDimension](#bosss.foundation.grid.igriddata.spatialdimension) - dimensional measure) of the
cell 'j';
**Parameter:** `j` - local cell index
**Returns:**



## Method: BoSSS.Foundation.Grid.ILogicalCellData.GetCellBoundingBox(System.Int32,BoSSS.Platform.Utils.Geom.BoundingBox) <a id="bosss.foundation.grid.ilogicalcelldata.getcellboundingbox(system.int32,bosss.platform.utils.geom.boundingbox)"></a>
**Summary:** Computes the bounding box of cell 'j'.
**Parameter:** `j` - local cell index.
**Parameter:** `bb` - on exit, the bounding box of cell j.


## Method: BoSSS.Foundation.Grid.ILogicalCellData.GetInterpolationDegree(System.Int32) <a id="bosss.foundation.grid.ilogicalcelldata.getinterpolationdegree(system.int32)"></a>
**Summary:** polynomial interpolation degree of the Reference-to-Global coordinate transformation (maximum over all geometrical parts).
**Parameter:** `jCell` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.ILogicalCellData.GetCenter(System.Int32) <a id="bosss.foundation.grid.ilogicalcelldata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity for the cell

## Class: BoSSS.Foundation.Grid.IVertexData <a id="bosss.foundation.grid.ivertexdata"></a>

**Summary:** Vertices/Nodes of the mesh


### Property: BoSSS.Foundation.Grid.IVertexData.Coordinates <a id="bosss.foundation.grid.ivertexdata.coordinates"></a>
**Summary:** - 1st index/row index: vertex index 
- 2nd index: spatial dimension


### Property: BoSSS.Foundation.Grid.IVertexData.VerticeToCell <a id="bosss.foundation.grid.ivertexdata.verticetocell"></a>
**Summary:** For each vertex, the local indices of the adjacent cells;
- 1st index: local vertex index
- 2nd index: collection

## Class: BoSSS.Foundation.Grid.IGeometricalEdgeData <a id="bosss.foundation.grid.igeometricaledgedata"></a>


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Count <a id="bosss.foundation.grid.igeometricaledgedata.count"></a>
**Summary:** total number of all edges handled on this processor;


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafos <a id="bosss.foundation.grid.igeometricaledgedata.edge2celltrafos"></a>
**Summary:** Transformations from edge coordinate system to local cell
coordinate systems.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafos_SqrtGramian <a id="bosss.foundation.grid.igeometricaledgedata.edge2celltrafos_sqrtgramian"></a>
**Summary:** Square-root of the Gramian determinant for each transformation in [BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafos](#bosss.foundation.grid.igeometricaledgedata.edge2celltrafos), i.e.
if $\myMatrix{M}$ 
is the matrix of the transformation, this number is 
$\sqrt{ \operatorname{det} ( \myMatrix{M}^T \cdot \myMatrix{M} ) }$.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafosRefElementIndices <a id="bosss.foundation.grid.igeometricaledgedata.edge2celltrafosrefelementindices"></a>
**Summary:** For each edge-to-cell transformation, see [BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafos](#bosss.foundation.grid.igeometricaledgedata.edge2celltrafos),
the index of the cell reference element, i.e. an index into [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements](#bosss.foundation.grid.igeometricaledgedata.edgerefelements).


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafoIndex <a id="bosss.foundation.grid.igeometricaledgedata.edge2celltrafoindex"></a>
**Summary:** Edge-to-Cell - transformation index, i.e. index into [BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafos](#bosss.foundation.grid.igeometricaledgedata.edge2celltrafos);
- 1st index: local edge index; resp. part index (for aggregate grids).
- 2nd index: 0,1 first and second neighbor;


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags <a id="bosss.foundation.grid.igeometricaledgedata.edgetags"></a>
**Summary:** Edge Tags, index represents local edge index.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.Info <a id="bosss.foundation.grid.igeometricaledgedata.info"></a>
**Summary:** Additional edge information, index represents local edge index.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.FaceIndices <a id="bosss.foundation.grid.igeometricaledgedata.faceindices"></a>
**Summary:** Face index, where the numbering of faces is defined by the reference element, see e.g. [BoSSS.Foundation.Grid.RefElements.RefElement.FaceToVertexIndices](#bosss.foundation.grid.refelements.refelement.facetovertexindices).
- 1st index: local edge index; resp. part index (for aggregate grids).
- 2nd index: 0 and 1 for first and second neighbor;


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements <a id="bosss.foundation.grid.igeometricaledgedata.edgerefelements"></a>
**Summary:** All reference elements for edges.


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetRefElementIndex(System.Int32) <a id="bosss.foundation.grid.igeometricaledgedata.getrefelementindex(system.int32)"></a>
**Summary:** For edge number 'e', the index into
[BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements](#bosss.foundation.grid.igeometricaledgedata.edgerefelements).


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.e2C_offet <a id="bosss.foundation.grid.igeometricaledgedata.e2c_offet"></a>
**Summary:** Some hack, used by [BoSSS.Foundation.NodeSet.GetVolumeNodeSet(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Boolean)](#bosss.foundation.nodeset.getvolumenodeset(bosss.foundation.grid.igriddata,system.int32,system.boolean)); 
only effective (un-equal 0), if more than one grid is used in the application.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.CellIndices <a id="bosss.foundation.grid.igeometricaledgedata.cellindices"></a>
**Summary:** Local *geometric* cell indices of cells that belong to an edge.
- 1st index: local edge index
- 2nd index: 0,1 first and second neighbor;
**Remark:**
Example: Let be [BoSSS.Foundation.Grid.IGeometricalEdgeData.CellIndices](#bosss.foundation.grid.igeometricaledgedata.cellindices)[i,0] = 123 and
[BoSSS.Foundation.Grid.IGeometricalEdgeData.CellIndices](#bosss.foundation.grid.igeometricaledgedata.cellindices)[i,1] = 321; Then edge i is located
on the intersection of (the closure of) cell 123 and cell 321;
A negative cell index indicates that an edge is only subset of
one cell (cells on the border of an domain). The negative cell
index is always stored at the 2nd entry.


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.LogicalCellIndices <a id="bosss.foundation.grid.igeometricaledgedata.logicalcellindices"></a>
**Summary:** Local *logical* cell indices of cells that belong to an edge.
- 1st index: local edge index
- 2nd index: 0,1 first and second neighbor;


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.SqrtGramian <a id="bosss.foundation.grid.igeometricaledgedata.sqrtgramian"></a>
**Summary:** For each edge that is affine-linear (i.e. [BoSSS.Foundation.Grid.IGeometricalEdgeData.Info](#bosss.foundation.grid.igeometricaledgedata.info)[e]
& [BoSSS.Foundation.Grid.EdgeInfo.EdgeIsAffineLinear](#bosss.foundation.grid.edgeinfo.edgeisaffinelinear) != 0), the
square root of the Gram determinant; NaN for nonlinear edges.
1st index: local edge index;
**Remark:**
Let be 
\f[ 
\mathbb{R}^{D-1} 
\ni \vec{\xi} 
\mapsto
\gamma(\vec{\xi}) \in
\mathbb{R}^{D-1}
\f]
the mapping from the edge coordinate system to the physical coordinate system.
Then the integral of $f$  over the edge 
$\gamma(K_\textrm{ref})$ 
is given as 
\f[ 
\int_{\vec{x} \in \gamma(K_\textrm{ref})} f(\vec{x}) \ \textrm{dS}
=
\int_{\xi \in K_\textrm{ref}} f(\gamma(\xi)) g(\vec{\xi}) \ \textrm{d} \vec{\xi}
\f]
with the square-root of the Gram determinant
\f[ 
g(\vec{xi}) = \sqrt{ 
\textrm{det} ( (\partial \gamma)^T \cdot (\partial \gamma) )  
}.
\f]
If the transformation 
$\gamma$
of the edge to the global coordinate system 
is affine-linear, the Jacobian 
$\partial \gamma$
is constant and 
$g$
can be precomputed.
(see Analysis 2, Knigsberger, Springer-Verlag 2000, pp. 343)


### Property: BoSSS.Foundation.Grid.IGeometricalEdgeData.NormalsCache <a id="bosss.foundation.grid.igeometricaledgedata.normalscache"></a>
**Summary:** Cached normals at nodes.


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.IsEdgeAffineLinear(System.Int32) <a id="bosss.foundation.grid.igeometricaledgedata.isedgeaffinelinear(system.int32)"></a>
**Summary:** true, if edge 'e' is affine-linear, false if not.


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetNormalsForCell(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.igeometricaledgedata.getnormalsforcell(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** Computes the normals on face 'iFace' in the
volume coordinate system of a given cell
'jCell' at the given 'Nodes'
and writes the result into 'NormalsOut'
**Parameter:** `jCell` - Cell index
**Parameter:** `iFace` - Face index
**Parameter:** `Nodes` - Evaluation nodes

1st index: Node index
2nd index: Spatial dimension
**Parameter:** `NormalsOut` -
1st index: cell index
2nd index: Node index
3rd index: Spatial dimension
**Parameter:** `QuadMetric` - A by-product: the integral transformation metric.
**Parameter:** `Offset` - An offset into the first entry of 'NormalsOut' and 'QuadMetric'.


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetNormalsForCell(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.igeometricaledgedata.getnormalsforcell(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Computes the normals on face 'iFace' in the
volume coordinate system of a given cell
'jCell' at the given 'Nodes'
and writes the result into 'NormalsOut'
**Parameter:** `jCell` - Cell index
**Parameter:** `iFace` - Face index
**Parameter:** `Nodes` - Evaluation nodes

1st index: Node index
2nd index: Spatial dimension
**Parameter:** `NormalsOut` -
1st index: cell index
2nd index: Node index
3rd index: Spatial dimension


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetEdges4RefElement(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.grid.igeometricaledgedata.getedges4refelement(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** For each (edge) reference element, this method provides a
mask containing all cells which are mapped from the specific
reference element.
**Parameter:** `Kref` - Reference element for edges.


## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetEdgeArea(System.Int32) <a id="bosss.foundation.grid.igeometricaledgedata.getedgearea(system.int32)"></a>
**Summary:** returns the area (to be more exact: the (D-1) - dimensional measure) of the geometrical edge 'e'
**Parameter:** `e` - logical edge index
**Returns:**



## Method: BoSSS.Foundation.Grid.IGeometricalEdgeData.GetCenter(System.Int32) <a id="bosss.foundation.grid.igeometricaledgedata.getcenter(system.int32)"></a>
**Summary:** Center-of-gravity for the edge

## Class: BoSSS.Foundation.Grid.ILogicalEdgeData <a id="bosss.foundation.grid.ilogicaledgedata"></a>


### Property: BoSSS.Foundation.Grid.ILogicalEdgeData.Count <a id="bosss.foundation.grid.ilogicaledgedata.count"></a>
**Summary:** total number of all edges handled on this processor;


### Property: BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices <a id="bosss.foundation.grid.ilogicaledgedata.cellindices"></a>
**Summary:** Local cell indices of cells that belong to an edge.
- 1st index: local edge index
- 2nd index: 0,1 first and second neighbor;
**Remark:**
Example: Let be [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)[i,0] = 123 and
[BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)[i,1] = 321; Then edge i is located
on the intersection of (the closure of) cell 123 and cell 321;
A negative cell index indicates that an edge is only subset of
one cell (cells on the border of an domain). The negative cell
index is always stored at the 2nd entry.


### Property: BoSSS.Foundation.Grid.ILogicalEdgeData.EdgeToParts <a id="bosss.foundation.grid.ilogicaledgedata.edgetoparts"></a>
**Summary:** Only used for aggregation grids, where each edge can be triangulated.
- 1st index: local edge index
- 2nd index: enumeration of parts.


## Method: BoSSS.Foundation.Grid.ILogicalEdgeData.GetEdgeArea(System.Int32) <a id="bosss.foundation.grid.ilogicaledgedata.getedgearea(system.int32)"></a>
**Summary:** returns the area (to be more exact: the (D-1) - dimensional measure) of the logical edge 'e',
which is the sum of all geometrical parts
**Parameter:** `e` - logical edge index
**Returns:**


## Class: BoSSS.Foundation.Grid.IParallelization <a id="bosss.foundation.grid.iparallelization"></a>

**Summary:** Common interface for properties required for MPI parallel computation on meshes.


### Property: BoSSS.Foundation.Grid.IParallelization.Global2LocalIdx <a id="bosss.foundation.grid.iparallelization.global2localidx"></a>
**Summary:** Conversion of global cell indices to local cell indices, 
i.e. the inverse of [BoSSS.Foundation.Grid.IParallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.iparallelization.globalindicesexternalcells). 
- keys: global indices of external/ghost cells 
- values: local indices of external/ghost cells


### Property: BoSSS.Foundation.Grid.IParallelization.GlobalIndicesExternalCells <a id="bosss.foundation.grid.iparallelization.globalindicesexternalcells"></a>
**Summary:** Global indices of external cells (local indices j in the range
[BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells) <= j <
[BoSSS.Foundation.Grid.ILogicalCellData.Count](#bosss.foundation.grid.ilogicalcelldata.count)); Note that there is an index
offset, so the entry at index 0 is the global index of cell at
local index [BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells);
See also [BoSSS.Foundation.Grid.IParallelization.GlobalIndicesExternalCells](#bosss.foundation.grid.iparallelization.globalindicesexternalcells);


### Property: BoSSS.Foundation.Grid.IParallelization.ProcessesToSendTo <a id="bosss.foundation.grid.iparallelization.processestosendto"></a>
**Summary:** list of processes (MPI ranks) which receive data from this process
- index: enumeration
- content: MPI process rank


### Property: BoSSS.Foundation.Grid.IParallelization.ProcessesToReceiveFrom <a id="bosss.foundation.grid.iparallelization.processestoreceivefrom"></a>
**Summary:** List of processes (MPI ranks) which send data to this process.


### Property: BoSSS.Foundation.Grid.IParallelization.SendCommLists <a id="bosss.foundation.grid.iparallelization.sendcommlists"></a>
**Summary:** Local cell indices (only border cells) which must be send to
other processors; for each processor, the communication list is
stored in ascending order.
**Remark:**
- 1st index: target processor; if the 'p'-th entry is null, there is no communication with processor 'p'
- 2nd index: enumeration;
- content: local cell index


### Property: BoSSS.Foundation.Grid.IParallelization.RcvCommListsInsertIndex <a id="bosss.foundation.grid.iparallelization.rcvcommlistsinsertindex"></a>
**Summary:** For each process, a local cell index at which items received
from other processes should be inserted;
- index: MPI process rank of process from which data is received.
- content: local cell index.


### Property: BoSSS.Foundation.Grid.IParallelization.RcvCommListsNoOfItems <a id="bosss.foundation.grid.iparallelization.rcvcommlistsnoofitems"></a>
**Summary:** For each process, the number of cells that are received from
this process
- index: MPI process rank of process from which data is received
- content: number of cells

## Class: BoSSS.Foundation.Grid.IGridData_Extensions <a id="bosss.foundation.grid.igriddata_extensions"></a>

**Summary:** Utility functions regarding [BoSSS.Foundation.Grid.IGridData](#bosss.foundation.grid.igriddata)-objects.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetGeometricCellIndices(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk) <a id="bosss.foundation.grid.igriddata_extensions.getgeometriccellindices(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk)"></a>
**Summary:** Returns an enumeration of geometrical cell indices ([BoSSS.Foundation.Grid.IGeometricalCellsData](#bosss.foundation.grid.igeometricalcellsdata))
for a range 'C' of logical cell indices.
**Parameter:** `g` - The grid object.
**Parameter:** `C` - A range of logical cell indices.
**Returns:**
An enumeration of geometrical cell indices.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetGeometricCellIndices(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.getgeometriccellindices(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Returns an enumeration of geometrical cell indices ([BoSSS.Foundation.Grid.IGeometricalCellsData](#bosss.foundation.grid.igeometricalcellsdata))
for a logical cell index 'j'.
**Parameter:** `g` - The grid object.
**Parameter:** `j` - A logical cell index.
**Returns:**
An enumeration of geometrical cell indices.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetLogicalCellIndex(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.getlogicalcellindex(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Returns the logical cell index corresponding to a given geometrical cell index 'jGeom'.
For standard grids, this is an identity mapping (i.e., 'jGeom' == logical cell index).
For aggregation or adaptive grids, this uses the GeomCell2LogicalCell mapping.
**Parameter:** `g` - The grid data object.
**Parameter:** `jGeom` - The geometrical cell index.
**Returns:**
The logical cell index corresponding to 'jGeom'.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetGeometricCellChunks(BoSSS.Foundation.Grid.CellMask,System.Int32,BoSSS.Foundation.Grid.CellInfo) <a id="bosss.foundation.grid.igriddata_extensions.getgeometriccellchunks(bosss.foundation.grid.cellmask,system.int32,bosss.foundation.grid.cellinfo)"></a>
**Summary:** Returns an enumeration of geometrical cell chunks (first index an length) for a given cell mask.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetGeometricEdgeIndices(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.Chunk) <a id="bosss.foundation.grid.igriddata_extensions.getgeometricedgeindices(bosss.foundation.grid.igriddata,bosss.foundation.grid.chunk)"></a>
**Summary:** Returns an enumeration of geometrical edge indices ([BoSSS.Foundation.Grid.IGeometricalEdgeData](#bosss.foundation.grid.igeometricaledgedata))
for a range 'C' of logical edge indices.
**Parameter:** `g` - The grid object.
**Parameter:** `C` - A range of logical edge indices.
**Returns:**
An enumeration of geometrical cell indices.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetGeometricEdgeIndices(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.getgeometricedgeindices(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Returns an enumeration of geometrical edge indices ([BoSSS.Foundation.Grid.IGeometricalCellsData](#bosss.foundation.grid.igeometricalcellsdata))
for a logical edge index 'e'.
**Parameter:** `g` - The grid object.
**Parameter:** `e` - A logical edge index.
**Returns:**
An enumeration of geometrical cell indices.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.LocatePoint(BoSSS.Foundation.Grid.IGridData,System.Double[],System.Int64@,System.Int64@,System.Boolean@,System.Boolean@,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.grid.igriddata_extensions.locatepoint(bosss.foundation.grid.igriddata,system.double[],system.int64@,system.int64@,system.boolean@,system.boolean@,bosss.foundation.grid.cellmask)"></a>
**Summary:** Find the cell which contains some point 'pt';
If 'pt' is not within any cell, the cell with its
center nearest to 'pt' is returned and in this
case, 'IsInside' is false.
**Parameter:** `pt` - 
**Parameter:** `GlobalId` - the Global ID of the found cell;
**Parameter:** `GlobalIndex` - the Global index of the found cell;
**Parameter:** `IsInside` - true, if 'pt' is within the cell identified by
'GlobalId';
otherwise, false;
**Parameter:** `OnThisProcess` - If true, the cell 'GlobalId' is located on the current MPI process.
**Parameter:** `CM` - optional cell mask to restrict the search region
**Parameter:** `gdat` - ~
**Remark:**
This operation is relatively costly, as it needs to perform a sweep
over all cells, it should not be used for performance-critical
tasks.
This operation is MPI-collective, the output-values are equal on
all MPI-processors.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetBoundaryEdgeMask(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.igriddata_extensions.getboundaryedgemask(bosss.foundation.grid.igriddata)"></a>
**Summary:** Returns an edge mask which contains all boundary cells.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetBoundaryEdges(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.igriddata_extensions.getboundaryedges(bosss.foundation.grid.igriddata)"></a>
**Summary:** Returns a mask which contains all boundary edges


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetCellNeighboursViaEdges(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Boolean) <a id="bosss.foundation.grid.igriddata_extensions.getcellneighboursviaedges(bosss.foundation.grid.igriddata,system.int32,system.boolean)"></a>
**Summary:** Finds all neighbor cells for a given cell;
**Parameter:** `jCell` - 
**Parameter:** `OmmitPeriodic` - If true, neighborship relations originating from periodic boundary conditions are ignored.
**Parameter:** `g` - Grid object.
**Returns:**
- 1st entry: local cell index of neighbor cell 
- 2nd index: edge index of connecting edge 
- 3rd index: whether the other cell is the in-cell (0) or the out-cell (1) of the edge


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetCellNeighbours(BoSSS.Foundation.Grid.IGridData,System.Int32,BoSSS.Foundation.Grid.GetCellNeighbours_Mode,System.Int32[]@,System.Int32[]@) <a id="bosss.foundation.grid.igriddata_extensions.getcellneighbours(bosss.foundation.grid.igriddata,system.int32,bosss.foundation.grid.getcellneighbours_mode,system.int32[]@,system.int32[]@)"></a>
**Summary:** Finds all neighbor cells for a given cell.
**Parameter:** `jCell` - a local cell index in the range of locally updated cells
**Parameter:** `CellNeighBours` - a collection of neighbor cells (local indices);
**Parameter:** `ConectingEntities` - a collection of all edges/all vertices of cell
'jCell'
**Parameter:** `mode` - Interpretation of neighborhood: sharing a whole edge vs.
sharing at least one vertex.
**Parameter:** `g` - Grid object.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeConformalWithCell1(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.isedgeconformalwithcell1(bosss.foundation.grid.igeometricaledgedata,system.int32)"></a>
**Summary:** For edge number 'e', whether it is conformal
with cell 1


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeConformalWithCell2(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.isedgeconformalwithcell2(bosss.foundation.grid.igeometricaledgedata,system.int32)"></a>
**Summary:** For edge number 'e', whether it is conformal
with cell 2


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeConformal(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.isedgeconformal(bosss.foundation.grid.igeometricaledgedata,system.int32,system.int32)"></a>
**Summary:** For edge number 'iedge', whether it is
conformal with the adjacent cells
**Parameter:** `iedge` - 
**Parameter:** `InOrOut` - 0 for IN-cell/first cell, see [BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeConformalWithCell1(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32)](#bosss.foundation.grid.igriddata_extensions.isedgeconformalwithcell1(bosss.foundation.grid.igeometricaledgedata,system.int32))
1 for OUT-cell/second cell, see [BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeConformalWithCell2(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32)](#bosss.foundation.grid.igriddata_extensions.isedgeconformalwithcell2(bosss.foundation.grid.igeometricaledgedata,system.int32))
**Parameter:** `ge` - ~


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.IsEdgeBoundaryEdge(BoSSS.Foundation.Grid.IGeometricalEdgeData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.isedgeboundaryedge(bosss.foundation.grid.igeometricaledgedata,system.int32)"></a>
**Summary:** true, if edge 'e' is a boundary-edge.


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetBoundaryCells(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.grid.igriddata_extensions.getboundarycells(bosss.foundation.grid.igriddata)"></a>
**Summary:** Returns a mask containing all cells which lie at the domain boundary


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.ComputeCFLTime``1(BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{``0},System.Double,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.grid.igriddata_extensions.computecfltime``1(bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{``0},system.double,bosss.foundation.grid.cellmask)"></a>
**Summary:** computes a global time-step length ("delta t") according to the Courant-Friedrichs-Lax - criterion, based on a velocity
vector ('velvect') and the cell size [BoSSS.Foundation.Grid.IGeometricalCellsData.h_min](#bosss.foundation.grid.igeometricalcellsdata.h_min);
**Parameter:** `velvect` - components of a velocity vector
**Parameter:** `max` - an upper maximum for the return value; This is useful if the velocity
defined by 'velvect' is 0 or very small everywhere;
**Parameter:** `cm` - optional restriction of domain.
**Parameter:** `__gdat` - ~
**Returns:**
the minimum (over all cells j in all processes) of [BoSSS.Foundation.Grid.IGeometricalCellsData.h_min](#bosss.foundation.grid.igeometricalcellsdata.h_min)[j]
over v, where v is the Euclidean norm of a vector build from 
'velvect';
This vector is evaluated at cell center and all cell vertices.
The return value is the same on all processes;


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.CellToEdge(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.celltoedge(bosss.foundation.grid.igriddata,system.int32,system.int32)"></a>
**Summary:** returns the logical edge index for a cell/face index pair
**Parameter:** `jCell` - local cell index
**Parameter:** `iFace` - face index (with respect tor the face numbering of the reference element [BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces](#bosss.foundation.grid.refelements.refelement.nooffaces))
**Parameter:** `g` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.Grid.IGridData,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.grid.igriddata,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** transforms vertices from the local coordinate system of cells 'jCell'
to global coordinates;
**Parameter:** `LocalVerticesIn` -
Input; vertices in the local coordinate system of a cell;
- 1st index: vertex index
- 2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and 0,1,2 for 3D;
**Parameter:** `GlobalVerticesOut` -
Output; the vertices form 'LocalVerticesIn', transformed to global
coordinates;
- 1st index: vertex index, corresponds with the 1st index of 'LocalVerticesIn';
- 2nd index: spatial coordinate index 0 for 1D and 0,1 for 2D and 0,1,2 for 3D;
**Parameter:** `jCell` - local cell index of the cell to transform
**Parameter:** `g` - 


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.Grid.IGridData,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.grid.igriddata,ilpsp.multidimensionalarray,system.int32)"></a>
**Summary:** Easy-to-use routine (version with memory allocation):
transform nodes in local coordinates to global coordinates for cell 'jCell'
**Parameter:** `g` - 
**Parameter:** `localNodes` -
2D-array:
- 1st dimension: node index
- 2nd dimension: spatial direction
**Parameter:** `jCell` - geometrical cell index
**Returns:**
2D-array, 'localNodes' transformed to global coordinates
- 1st dimension: node index
- 2nd dimension: spatial direction


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.Grid.IGridData,ilPSP.Vector,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.grid.igriddata,ilpsp.vector,system.int32)"></a>
**Summary:** Easy-to-use routine (for a single point):
transform nodes in local coordinate to a global coordinate for cell 'jCell'
**Parameter:** `g` - 
**Parameter:** `localNode` - point in local coordinates
**Parameter:** `jCell` - geometrical cell index
**Returns:**
point in global coordinates


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(ilPSP.MultidimensionalArray,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(ilpsp.multidimensionalarray,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** [BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.Grid.IGridData,ilPSP.MultidimensionalArray,System.Int32)](#bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.grid.igriddata,ilpsp.multidimensionalarray,system.int32))


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.NodeSet,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.nodeset,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** transform nodes from local edge or cell coordinates (depending on [BoSSS.Foundation.NodeSet.GetNodeCoordinateSystem(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.nodeset.getnodecoordinatesystem(bosss.foundation.grid.igriddata))) to global coordinates
**Parameter:** `iItem` - a geometrical edge or cell index
**Parameter:** `localNodes` - 
**Parameter:** `g` - 


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.TransformLocal2Global(BoSSS.Foundation.Grid.IGridData,ilPSP.MultidimensionalArray,System.Int32,System.Int32) <a id="bosss.foundation.grid.igriddata_extensions.transformlocal2global(bosss.foundation.grid.igriddata,ilpsp.multidimensionalarray,system.int32,system.int32)"></a>
**Summary:** Easy-to-use routine (version with memory allocation):
in local coordinates to global coordinates, 
for a range of cells, starting at 'jCell0' to 'jCell0'+'Len'-1.
to coordinated to global coordinates
**Parameter:** `g` - 
**Parameter:** `localNodes` -
2D-array:
- 1st dimension: node index
- 2nd dimension: spatial direction
**Parameter:** `jCell0` - geometrical cell index
**Parameter:** `Len` - Number of cells to transform consecutive to cell 'jCell0'
**Returns:**
3D-array, 'localNodes' transformed to global coordinates
- 1st dimension: cell index
- 2nd dimension: node index
- 3rd dimension: spatial direction


## Method: BoSSS.Foundation.Grid.IGridData_Extensions.GetEdgesForFace(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Int32,System.Int32@,System.Int32[]@) <a id="bosss.foundation.grid.igriddata_extensions.getedgesforface(bosss.foundation.grid.igriddata,system.int32,system.int32,system.int32@,system.int32[]@)"></a>
**Summary:** Finds all edges for a specific face of a cell
**Parameter:** `jCellGeom` - geometrical cell index
**Parameter:** `iFace` - face index ([BoSSS.Foundation.Grid.RefElements.RefElement.NoOfFaces](#bosss.foundation.grid.refelements.refelement.nooffaces))
**Parameter:** `InOrOut` -
- 0 if 'jCellGeom' is the IN-cell w.r.t. the found edge
- 1 if 'jCellGeom' is the OUT-cell w.r.t. the found edge
**Parameter:** `MoreEdges` - Only used for hanging nodes:
If there is more than one edge on the face, the indices of all edges in addition to the return value
**Parameter:** `m_owner` - 
**Returns:**
the first found edge on the face; if there are no hanging node, this is typically the only edge.

## Class: BoSSS.Foundation.Grid.GetCellNeighbours_Mode <a id="bosss.foundation.grid.getcellneighbours_mode"></a>

**Summary:** used by [BoSSS.Foundation.Grid.IGridData_Extensions.GetCellNeighbours(BoSSS.Foundation.Grid.IGridData,System.Int32,BoSSS.Foundation.Grid.GetCellNeighbours_Mode,System.Int32[]@,System.Int32[]@)](#bosss.foundation.grid.igriddata_extensions.getcellneighbours(bosss.foundation.grid.igriddata,system.int32,bosss.foundation.grid.getcellneighbours_mode,system.int32[]@,system.int32[]@)).


### Field: BoSSS.Foundation.Grid.GetCellNeighbours_Mode.ViaEdges <a id="bosss.foundation.grid.getcellneighbours_mode.viaedges"></a>
**Summary:** in this mode, any cell that shares an edge is considered a neighbor


### Field: BoSSS.Foundation.Grid.GetCellNeighbours_Mode.ViaVertices <a id="bosss.foundation.grid.getcellneighbours_mode.viavertices"></a>
**Summary:** in this mode, any cell that shares a vertex is considered a neighbor

## Class: BoSSS.Foundation.Grid.IComparableGrid <a id="bosss.foundation.grid.icomparablegrid"></a>

**Summary:** Grid comparison, divided into two parts:
- basic properties: [BoSSS.Foundation.Grid.IComparableGrid.BasePropertiesComparer](#bosss.foundation.grid.icomparablegrid.basepropertiescomparer), which is cheap
- individual cells: [BoSSS.Foundation.Grid.IComparableGrid.CellComparer](#bosss.foundation.grid.icomparablegrid.cellcomparer), expensive to run


### Property: BoSSS.Foundation.Grid.IComparableGrid.CellComparer <a id="bosss.foundation.grid.icomparablegrid.cellcomparer"></a>
**Summary:** Comparison of all cells


### Property: BoSSS.Foundation.Grid.IComparableGrid.BasePropertiesComparer <a id="bosss.foundation.grid.icomparablegrid.basepropertiescomparer"></a>
**Summary:** Comparison of spatial dimension, cell types, number of cells, etc.

## Class: BoSSS.Foundation.Grid.IGrid_Extensions <a id="bosss.foundation.grid.igrid_extensions"></a>

**Summary:** Various extension methods.


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.DefineEdgeTags(BoSSS.Foundation.Grid.IGrid,System.Func{ilPSP.Vector,System.Byte},System.String[]) <a id="bosss.foundation.grid.igrid_extensions.defineedgetags(bosss.foundation.grid.igrid,system.func{ilpsp.vector,system.byte},system.string[])"></a>
**Summary:** sets values for [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags) by using a
'EdgeTagFunc'-function; also adds entries with empty names
to the [BoSSS.Foundation.Grid.Classic.GridCommons.EdgeTagNames](#bosss.foundation.grid.classic.gridcommons.edgetagnames)-dictionary, if the edge tag
returned by the 'EdgeTagFunc'-function is not in
the dictionary


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.DefineEdgeTags(BoSSS.Foundation.Grid.IGrid,System.Func{System.Double[],System.Byte}) <a id="bosss.foundation.grid.igrid_extensions.defineedgetags(bosss.foundation.grid.igrid,system.func{system.double[],system.byte})"></a>
**Summary:** sets values for [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags) by using a
'EdgeTagFunc'-function; also adds entries with empty names
to the [BoSSS.Foundation.Grid.IGridData.EdgeTagNames](#bosss.foundation.grid.igriddata.edgetagnames)-dictionary, if the edge tag
returned by the 'EdgeTagFunc'-function is not in
the dictionary


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.DefineEdgeTags(BoSSS.Foundation.Grid.IGrid,System.Func{System.Double[],System.String}) <a id="bosss.foundation.grid.igrid_extensions.defineedgetags(bosss.foundation.grid.igrid,system.func{system.double[],system.string})"></a>
**Summary:** sets values for [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags) by using a
'EdgeTagFunc'-function; also adds entries with empty names
to the [BoSSS.Foundation.Grid.IGridData.EdgeTagNames](#bosss.foundation.grid.igriddata.edgetagnames)-dictionary, if the edge tag
returned by the 'EdgeTagFunc'-function is not in
the dictionary


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.AddEdgeTag(BoSSS.Foundation.Grid.IGrid,System.String) <a id="bosss.foundation.grid.igrid_extensions.addedgetag(bosss.foundation.grid.igrid,system.string)"></a>
**Summary:** Adds the edge tag name 'EdgeTagName' to the grid, 
regardless of whether it is used or not.


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.DefineEdgeTags(BoSSS.Foundation.Grid.IGrid,System.Func{ilPSP.Vector,System.String},System.String[]) <a id="bosss.foundation.grid.igrid_extensions.defineedgetags(bosss.foundation.grid.igrid,system.func{ilpsp.vector,system.string},system.string[])"></a>
**Summary:** sets values for [BoSSS.Foundation.Grid.Classic.Cell.CellFaceTags](#bosss.foundation.grid.classic.cell.cellfacetags) by using a
'EdgeTagFunc'-function; also adds entries with empty names
to the [BoSSS.Foundation.Grid.IGridData.EdgeTagNames](#bosss.foundation.grid.igriddata.edgetagnames)-dictionary, if the edge tag
returned by the 'EdgeTagFunc'-function is not in
the dictionary


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.EnsureMinimalBalance(BoSSS.Foundation.Grid.IGrid) <a id="bosss.foundation.grid.igrid_extensions.ensureminimalbalance(bosss.foundation.grid.igrid)"></a>


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.ConstructPeriodicEdgeTrafo(BoSSS.Foundation.Grid.Classic.GridCommons,ilPSP.Vector,ilPSP.Vector,ilPSP.Vector,ilPSP.Vector,System.Byte@) <a id="bosss.foundation.grid.igrid_extensions.constructperiodicedgetrafo(bosss.foundation.grid.classic.gridcommons,ilpsp.vector,ilpsp.vector,ilpsp.vector,ilpsp.vector,system.byte@)"></a>
**Summary:** Periodic boundary conditions are treated by connecting an "outlet"
with some "inlet". Beside the cell neighborship relations (see
[BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours](#bosss.foundation.grid.classic.griddata.celldata.cellneighbours)) an linear
transformation must be provided which maps an affine-linear
manifold A (the "outlet") of dimension D-1 (D denotes the spatial
dimension) to another affine-linear manifold B (the "inlet"). (Note
that the terms "outlet" and "inlet" are exchangeable.)
**Parameter:** `g` - 
**Parameter:** `X1` - a single point in manifold A;
**Parameter:** `N1` - normal onto manifold A
**Parameter:** `X2` - a single point in manifold B;
**Parameter:** `N2` - normal onto manifold B
**Parameter:** `PeriodicTrafo_Tag` - The edge tag for the periodic transformation


## Method: BoSSS.Foundation.Grid.IGrid_Extensions.ConstructPeriodicEdgeTrafo(BoSSS.Foundation.Grid.Classic.GridCommons,ilPSP.Vector[],ilPSP.Vector,ilPSP.Vector[],ilPSP.Vector,System.Byte@) <a id="bosss.foundation.grid.igrid_extensions.constructperiodicedgetrafo(bosss.foundation.grid.classic.gridcommons,ilpsp.vector[],ilpsp.vector,ilpsp.vector[],ilpsp.vector,system.byte@)"></a>
**Summary:** Periodic boundary conditions are treated by connecting an "outlet"
with some "inlet". Beside the cell neighborship relations (see
[BoSSS.Foundation.Grid.Classic.GridData.CellData.CellNeighbours](#bosss.foundation.grid.classic.griddata.celldata.cellneighbours)) an linear
transformation must be provided which maps an affine-linear
manifold A (the "outlet") of dimension D-1 (D denotes the spatial
dimension) to another affine-linear manifold B (the "inlet"). (Note
that the terms "outlet" and "inlet" are exchangeable.)
**Parameter:** `g` - 
**Parameter:** `X1` - D pairwise different vectors, each d-dimensional, that specify the
affine-linear manifold A;
**Parameter:** `N1` - normal onto manifold A
**Parameter:** `X2` - the image (i.e. the result when the transformation is applied onto
the vectors 'X1') of the (unknown) 
transformation in manifold B;
**Parameter:** `N2` - normal onto manifold B
**Parameter:** `PeriodicTrafo_Tag` - The edge tag for the periodic transformation

## Class: BoSSS.Foundation.Grid.Polynomial <a id="bosss.foundation.grid.polynomial"></a>

**Summary:** Just from its name, you might guess what this class is good for.


### Field: BoSSS.Foundation.Grid.Polynomial.Exponents <a id="bosss.foundation.grid.polynomial.exponents"></a>
**Summary:** 1st index: Coefficient index; 2nd index: spatial dimension index;
See [BoSSS.Foundation.Grid.Polynomial.Coeff](#bosss.foundation.grid.polynomial.coeff) for further information;


### Field: BoSSS.Foundation.Grid.Polynomial.Coeff <a id="bosss.foundation.grid.polynomial.coeff"></a>
**Summary:** Polynomial coefficients;
The polynomial value at point (x,y) is evaluated as the sum 
[BoSSS.Foundation.Grid.Polynomial.Coeff](#bosss.foundation.grid.polynomial.coeff)[i]*x^[BoSSS.Foundation.Grid.Polynomial.Exponents](#bosss.foundation.grid.polynomial.exponents)[i,0]*y^[BoSSS.Foundation.Grid.Polynomial.Exponents](#bosss.foundation.grid.polynomial.exponents)[i,1]
over all i.


## Method: BoSSS.Foundation.Grid.Polynomial.#ctor <a id="bosss.foundation.grid.polynomial.#ctor"></a>
**Summary:** Obsolete.


## Method: BoSSS.Foundation.Grid.Polynomial.#ctor(System.Guid) <a id="bosss.foundation.grid.polynomial.#ctor(system.guid)"></a>
**Summary:** Obsolete. The polynomial GUID is no longer used.


## Method: BoSSS.Foundation.Grid.Polynomial.AddCoeff(System.Double,System.Int32[]) <a id="bosss.foundation.grid.polynomial.addcoeff(system.double,system.int32[])"></a>
**Summary:** adds a coefficient/exponent pair to this polynomial


## Method: BoSSS.Foundation.Grid.Polynomial.GetCoefficientIndex(System.Int32[]) <a id="bosss.foundation.grid.polynomial.getcoefficientindex(system.int32[])"></a>
**Summary:** returns the coefficient index (index into [BoSSS.Foundation.Grid.Polynomial.Coeff](#bosss.foundation.grid.polynomial.coeff)) for a specific exponent.


### Property: BoSSS.Foundation.Grid.Polynomial.AbsoluteDegree <a id="bosss.foundation.grid.polynomial.absolutedegree"></a>
**Summary:** polynomial degree


### Property: BoSSS.Foundation.Grid.Polynomial.SpatialDimension <a id="bosss.foundation.grid.polynomial.spatialdimension"></a>
**Summary:** 2 for polynomials in x,y and 3 for polynomials in x,y,z;


## Method: BoSSS.Foundation.Grid.Polynomial.op_UnaryNegation(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.op_unarynegation(bosss.foundation.grid.polynomial)"></a>
**Summary:** Creates a new polynomial by multiplying the given polynomial by -1
**Parameter:** `p` - A polynomial to be multiplied by -1
**Returns:**
A new polynomial q with q(x) = -'p'(x)


## Method: BoSSS.Foundation.Grid.Polynomial.op_Multiply(System.Double,BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.op_multiply(system.double,bosss.foundation.grid.polynomial)"></a>
**Summary:** Creates a new polynomial by multiplying the given polynomial by 'scale'


## Method: BoSSS.Foundation.Grid.Polynomial.op_Multiply(BoSSS.Foundation.Grid.Polynomial,System.Double) <a id="bosss.foundation.grid.polynomial.op_multiply(bosss.foundation.grid.polynomial,system.double)"></a>
**Summary:** Creates a new polynomial by multiplying the given polynomial by 'scale'


## Method: BoSSS.Foundation.Grid.Polynomial.op_Multiply(BoSSS.Foundation.Grid.Polynomial,BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.op_multiply(bosss.foundation.grid.polynomial,bosss.foundation.grid.polynomial)"></a>
**Summary:** Symbolic multiplication of two polynomials


## Method: BoSSS.Foundation.Grid.Polynomial.MultiplyByMonomial(System.Int32[],System.Double) <a id="bosss.foundation.grid.polynomial.multiplybymonomial(system.int32[],system.double)"></a>
**Summary:** multiplies this polynomial with a monomial expression


## Method: BoSSS.Foundation.Grid.Polynomial.op_Addition(BoSSS.Foundation.Grid.Polynomial,BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.op_addition(bosss.foundation.grid.polynomial,bosss.foundation.grid.polynomial)"></a>
**Summary:** Calculates the sum of 'p' and 'q'
**Parameter:** `p` - First operand
**Parameter:** `q` - First operand
**Returns:**
A new polynomial r with
r(x) = 'p'(x) + 'q'(x)


## Method: BoSSS.Foundation.Grid.Polynomial.op_Subtraction(BoSSS.Foundation.Grid.Polynomial,BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.op_subtraction(bosss.foundation.grid.polynomial,bosss.foundation.grid.polynomial)"></a>
**Summary:** Calculates the difference between 'p' and
'q'
**Parameter:** `p` - First operand
**Parameter:** `q` - First operand
**Returns:**
A new polynomial r with
r(x) = 'p'(x) - 'q'(x)


## Method: BoSSS.Foundation.Grid.Polynomial.DeriveMonomial(System.Int32[],System.Int32[]) <a id="bosss.foundation.grid.polynomial.derivemonomial(system.int32[],system.int32[])"></a>
**Summary:** Computes the derivative of a monomial.
**Parameter:** `MonomExp` - Monomial exponents.
**Parameter:** `DerivExp` - Derivative symbol exponents.


## Method: BoSSS.Foundation.Grid.Polynomial.Derive(System.Int32[]) <a id="bosss.foundation.grid.polynomial.derive(system.int32[])"></a>
**Summary:** Returns a derivative of this polynomial.
**Parameter:** `Deriv` - Derivative symbol exponents.


## Method: BoSSS.Foundation.Grid.Polynomial.Evaluate(ilPSP.MultidimensionalArray,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.grid.polynomial.evaluate(ilpsp.multidimensionalarray,bosss.foundation.nodeset)"></a>
**Summary:** A vectorized evaluation of this polynomial at specific nodes.
**Parameter:** `result` - Dimension must be 1;
On exit, the k-th entry contains the value of the polynomial 
at the point 'LocalPoints'[k,:];
**Parameter:** `LocalPoints` - Points at which the polynomial should be evaluated;
1st index: Point index; 2nd index: spatial coordinate index,
0,1 for 2D and 0,1,2 for 3D;


## Method: BoSSS.Foundation.Grid.Polynomial.CompareTo(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomial.compareto(bosss.foundation.grid.polynomial)"></a>
**Summary:** compares according to polynomial [BoSSS.Foundation.Grid.Polynomial.AbsoluteDegree](#bosss.foundation.grid.polynomial.absolutedegree);
**Parameter:** `other` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.Polynomial.CloneAs <a id="bosss.foundation.grid.polynomial.cloneas"></a>
**Summary:** type-safe cloning


## Method: BoSSS.Foundation.Grid.Polynomial.Clone <a id="bosss.foundation.grid.polynomial.clone"></a>
**Summary:** cloning


## Method: BoSSS.Foundation.Grid.Polynomial.Equals(System.Object) <a id="bosss.foundation.grid.polynomial.equals(system.object)"></a>
**Summary:** If all exponents and coefficients are the same, two polynomials are equal.
**Parameter:** `obj` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.Polynomial.GetHashCode <a id="bosss.foundation.grid.polynomial.gethashcode"></a>
**Summary:** Hash code based on the exponents.


## Method: BoSSS.Foundation.Grid.Polynomial.ToString <a id="bosss.foundation.grid.polynomial.tostring"></a>
**Summary:** nice formatting

## Class: BoSSS.Foundation.Grid.PolynomialList <a id="bosss.foundation.grid.polynomiallist"></a>

**Summary:** A list of polynomials. The purpose of this class is to optimize the 
evaluation of polynomials and their derivatives. Since this is usually done
for multiple polynomials at once, optimizations can be made.


## Method: BoSSS.Foundation.Grid.PolynomialList.#ctor(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Polynomial}) <a id="bosss.foundation.grid.polynomiallist.#ctor(system.collections.generic.ienumerable{bosss.foundation.grid.polynomial})"></a>
**Summary:** ctor.
**Parameter:** `polys` - 


### Property: BoSSS.Foundation.Grid.PolynomialList.SpatialDimension <a id="bosss.foundation.grid.polynomiallist.spatialdimension"></a>
**Summary:** Spatial dimension in which all polynomials are defined.


### Property: BoSSS.Foundation.Grid.PolynomialList.MaxAbsoluteDegree <a id="bosss.foundation.grid.polynomiallist.maxabsolutedegree"></a>
**Summary:** The maximum [BoSSS.Foundation.Grid.Polynomial.AbsoluteDegree](#bosss.foundation.grid.polynomial.absolutedegree) over all polynomials.


## Method: BoSSS.Foundation.Grid.PolynomialList.IndexOf(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomiallist.indexof(bosss.foundation.grid.polynomial)"></a>
**Summary:** As defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.Grid.PolynomialList.Insert(System.Int32,BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomiallist.insert(system.int32,bosss.foundation.grid.polynomial)"></a>
**Summary:** Not supported - this is read-only.


## Method: BoSSS.Foundation.Grid.PolynomialList.RemoveAt(System.Int32) <a id="bosss.foundation.grid.polynomiallist.removeat(system.int32)"></a>
**Summary:** Not supported - this is read-only.


### Property: BoSSS.Foundation.Grid.PolynomialList.Item(System.Int32) <a id="bosss.foundation.grid.polynomiallist.item(system.int32)"></a>
**Summary:** Returns the 'index'-th polynomial.
Setting is not supported, since this list is read-only.


## Method: BoSSS.Foundation.Grid.PolynomialList.Add(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomiallist.add(bosss.foundation.grid.polynomial)"></a>
**Summary:** Not supported - this is read-only.


## Method: BoSSS.Foundation.Grid.PolynomialList.Clear <a id="bosss.foundation.grid.polynomiallist.clear"></a>
**Summary:** Not supported - this is read-only.


## Method: BoSSS.Foundation.Grid.PolynomialList.Contains(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomiallist.contains(bosss.foundation.grid.polynomial)"></a>
**Summary:** As defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.Grid.PolynomialList.CopyTo(BoSSS.Foundation.Grid.Polynomial[],System.Int32) <a id="bosss.foundation.grid.polynomiallist.copyto(bosss.foundation.grid.polynomial[],system.int32)"></a>
**Summary:** As defined by interface **System.Collections.Generic.IList`1**.


### Property: BoSSS.Foundation.Grid.PolynomialList.Count <a id="bosss.foundation.grid.polynomiallist.count"></a>
**Summary:** Number of polynomials in the list.


### Property: BoSSS.Foundation.Grid.PolynomialList.IsReadOnly <a id="bosss.foundation.grid.polynomiallist.isreadonly"></a>
**Summary:** yes.


## Method: BoSSS.Foundation.Grid.PolynomialList.Remove(BoSSS.Foundation.Grid.Polynomial) <a id="bosss.foundation.grid.polynomiallist.remove(bosss.foundation.grid.polynomial)"></a>
**Summary:** Not supported - this is read-only.


## Method: BoSSS.Foundation.Grid.PolynomialList.GetEnumerator <a id="bosss.foundation.grid.polynomiallist.getenumerator"></a>
**Summary:** As defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.Grid.PolynomialList.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.grid.polynomiallist.system#collections#ienumerable#getenumerator"></a>
**Summary:** As defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.Grid.PolynomialList.NoOfPolynomialsPerDegree(System.Int32) <a id="bosss.foundation.grid.polynomiallist.noofpolynomialsperdegree(system.int32)"></a>
**Summary:** returns the number of basis polynomials
which are of degree 'deg';
(see also [BoSSS.Foundation.Grid.PolynomialList.FirstPolynomialIndexforDegree(System.Int32)](#bosss.foundation.grid.polynomiallist.firstpolynomialindexfordegree(system.int32)));
**Parameter:** `deg` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.PolynomialList.FirstPolynomialIndexforDegree(System.Int32) <a id="bosss.foundation.grid.polynomiallist.firstpolynomialindexfordegree(system.int32)"></a>
**Summary:** returns the index of the first polynomial in this list
which is of degree 'deg';
(see also [BoSSS.Foundation.Grid.PolynomialList.NoOfPolynomialsPerDegree(System.Int32)](#bosss.foundation.grid.polynomiallist.noofpolynomialsperdegree(system.int32)));
**Parameter:** `deg` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.PolynomialList.Evaluate(BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.grid.polynomiallist.evaluate(bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Non-cached evaluation.
**Parameter:** `NS` - Node set.
**Parameter:** `R` -
Output
- 1st index: node 
- 2nd index: polynomial


### Property: BoSSS.Foundation.Grid.PolynomialList.Values <a id="bosss.foundation.grid.polynomiallist.values"></a>
**Summary:** Cached evaluation.

## Class: BoSSS.Foundation.Grid.SubGrid <a id="bosss.foundation.grid.subgrid"></a>

**Summary:** denoted a subset of the computational grid


### Property: BoSSS.Foundation.Grid.SubGrid.GridData <a id="bosss.foundation.grid.subgrid.griddata"></a>
**Summary:** the grid that this object is associated with


## Method: BoSSS.Foundation.Grid.SubGrid.#ctor(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.grid.subgrid.#ctor(bosss.foundation.grid.cellmask)"></a>
**Summary:** ctor
**Parameter:** `volMask` - volume mask for those cells which should be contained in the subgrid


### Property: BoSSS.Foundation.Grid.SubGrid.LocalCellIndex2SubgridIndex <a id="bosss.foundation.grid.subgrid.localcellindex2subgridindex"></a>
**Summary:** mapping from local (within the current MPI process) cell indices to the subgrid;
- index: a local cell index j, i.e. 0  j <
[BoSSS.Foundation.Grid.ILogicalCellData.Count](#bosss.foundation.grid.ilogicalcelldata.count);
- content: a subgrid index k, i.e. 0  k <
[BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells](#bosss.foundation.grid.subgrid.localnoofcells), or a negative number if cell
j is not contained in the subgrid.
**Remark:**
The inverse of this mapping is
[BoSSS.Foundation.Grid.SubGrid.SubgridIndex2LocalCellIndex](#bosss.foundation.grid.subgrid.subgridindex2localcellindex);
For performance reasons, this array is only computed once, and
never cloned;


## Method: BoSSS.Foundation.Grid.SubGrid.ComputeLocalCellIndex2SubgridIndex <a id="bosss.foundation.grid.subgrid.computelocalcellindex2subgridindex"></a>
**Summary:** Computes [BoSSS.Foundation.Grid.SubGrid.LocalCellIndex2SubgridIndex](#bosss.foundation.grid.subgrid.localcellindex2subgridindex). Invokes
[BoSSS.Foundation.Grid.SubGrid.ComputeSubgridIndex2LocalCellIndex](#bosss.foundation.grid.subgrid.computesubgridindex2localcellindex) which requires MPI
communication.
**Returns:**



### Property: BoSSS.Foundation.Grid.SubGrid.SubgridIndex2LocalCellIndex <a id="bosss.foundation.grid.subgrid.subgridindex2localcellindex"></a>
**Summary:** mapping from subgrid indices to local (within the current MPI process) cell indices;
- index: a subgrid index k, i.e. 0  k <
[BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells](#bosss.foundation.grid.subgrid.localnoofcells), or a negative number if cell
j is not contained in the subgrid;
- content: a local cell index j, i.e. 0 
j < [BoSSS.Foundation.Grid.ILogicalCellData.Count](#bosss.foundation.grid.ilogicalcelldata.count);
**Remark:**
The inverse of this mapping is
[BoSSS.Foundation.Grid.SubGrid.LocalCellIndex2SubgridIndex](#bosss.foundation.grid.subgrid.localcellindex2subgridindex); The array is/should be
sorted in ascending order;


## Method: BoSSS.Foundation.Grid.SubGrid.ComputeSubgridIndex2LocalCellIndex <a id="bosss.foundation.grid.subgrid.computesubgridindex2localcellindex"></a>
**Summary:** Computes [BoSSS.Foundation.Grid.SubGrid.SubgridIndex2LocalCellIndex](#bosss.foundation.grid.subgrid.subgridindex2localcellindex)
**Returns:**



### Property: BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells <a id="bosss.foundation.grid.subgrid.localnoofcells"></a>
**Summary:** number of cells in the sub-grid (on current MPI process)


### Property: BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells_WithExternal <a id="bosss.foundation.grid.subgrid.localnoofcells_withexternal"></a>
**Summary:** number of cells in the sub-grid (on current MPI process), including external/ghost cells


### Field: BoSSS.Foundation.Grid.SubGrid.m_NoOfGhostCells <a id="bosss.foundation.grid.subgrid.m_noofghostcells"></a>
**Summary:** [BoSSS.Foundation.Grid.SubGrid.NoOfGhostCells](#bosss.foundation.grid.subgrid.noofghostcells); computed on demand


### Property: BoSSS.Foundation.Grid.SubGrid.NoOfGhostCells <a id="bosss.foundation.grid.subgrid.noofghostcells"></a>
**Summary:** number of external/ghost cells


### Property: BoSSS.Foundation.Grid.SubGrid.GlobalNoOfCells <a id="bosss.foundation.grid.subgrid.globalnoofcells"></a>
**Summary:** number of cells in the sub-grid (over all MPI processes)


### Field: BoSSS.Foundation.Grid.SubGrid.m_VolumeMask <a id="bosss.foundation.grid.subgrid.m_volumemask"></a>
**Summary:** [BoSSS.Foundation.Grid.SubGrid.VolumeMask](#bosss.foundation.grid.subgrid.volumemask);


### Property: BoSSS.Foundation.Grid.SubGrid.VolumeMask <a id="bosss.foundation.grid.subgrid.volumemask"></a>
**Summary:** all cells in the sub-grid


### Property: BoSSS.Foundation.Grid.SubGrid.BoundaryEdgesMask <a id="bosss.foundation.grid.subgrid.boundaryedgesmask"></a>
**Summary:** all edges on the boundary of the subgrid


### Property: BoSSS.Foundation.Grid.SubGrid.InnerEdgesMask <a id="bosss.foundation.grid.subgrid.inneredgesmask"></a>
**Summary:** only edges between cells in [BoSSS.Foundation.Grid.SubGrid.VolumeMask](#bosss.foundation.grid.subgrid.volumemask) (see also [BoSSS.Foundation.Grid.SubGrid.AllEdgesMask](#bosss.foundation.grid.subgrid.alledgesmask));


### Property: BoSSS.Foundation.Grid.SubGrid.AllEdgesMask <a id="bosss.foundation.grid.subgrid.alledgesmask"></a>
**Summary:** all edges with at least one cell in [BoSSS.Foundation.Grid.SubGrid.VolumeMask](#bosss.foundation.grid.subgrid.volumemask)


## Method: BoSSS.Foundation.Grid.SubGrid.CompressVector``2(``1,``0,System.Int32@) <a id="bosss.foundation.grid.subgrid.compressvector``2(``1,``0,system.int32@)"></a>
**Parameter:** `inp_FullGridVec` - input; vector associated with the "full" grid, i.e. [BoSSS.Foundation.Grid.SubGrid.GridData](#bosss.foundation.grid.subgrid.griddata)
**Parameter:** `outp_SubGridVec` - output; vector associates with this subgrid
**Parameter:** `period` - period, i.e.  (length/count of 'inp_FullGridVec')/[BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells](#bosss.foundation.grid.subgrid.localnoofcells)


## Method: BoSSS.Foundation.Grid.SubGrid.CompressVector``1(``0,System.Int32@) <a id="bosss.foundation.grid.subgrid.compressvector``1(``0,system.int32@)"></a>
**Parameter:** `inp` - 
**Parameter:** `period` - 
**Returns:**
the compressed vector, i.e. vector associated with this subgrid


## Method: BoSSS.Foundation.Grid.SubGrid.UncompressVector``2(``0,``1,System.Int32@) <a id="bosss.foundation.grid.subgrid.uncompressvector``2(``0,``1,system.int32@)"></a>
**Parameter:** `outp_FullGridVec` - output; vector associated with the "full" grid, i.e. [BoSSS.Foundation.Grid.SubGrid.GridData](#bosss.foundation.grid.subgrid.griddata)
**Parameter:** `inp_SubGridVec` - input; vector associates with this subgrid
**Parameter:** `period` - period, i.e.  (length/count of 'outp_FullGridVec')/[BoSSS.Foundation.Grid.SubGrid.LocalNoOfCells](#bosss.foundation.grid.subgrid.localnoofcells)


## Method: BoSSS.Foundation.Grid.SubGrid.CompressOperatorMatrix(ilPSP.LinSolvers.MsrMatrix,System.Int32@,System.Int32@) <a id="bosss.foundation.grid.subgrid.compressoperatormatrix(ilpsp.linsolvers.msrmatrix,system.int32@,system.int32@)"></a>
**Parameter:** `inp` - 
**Parameter:** `RowPeriod` - 
**Parameter:** `ColPeriod` - 
**Returns:**



## Method: BoSSS.Foundation.Grid.SubGrid.Complement <a id="bosss.foundation.grid.subgrid.complement"></a>
**Summary:** the complement of this Subgrid
**Returns:**



### Property: BoSSS.Foundation.Grid.SubGrid.Volume <a id="bosss.foundation.grid.subgrid.volume"></a>
**Summary:** measure of all cells within the subgrid


### Property: BoSSS.Foundation.Grid.SubGrid.h_minSubGrd <a id="bosss.foundation.grid.subgrid.h_minsubgrd"></a>
**Summary:** minimum cell diameter over all cells in the subgrid
[BoSSS.Foundation.Grid.IGeometricalCellsData.h_min](#bosss.foundation.grid.igeometricalcellsdata.h_min)


### Property: BoSSS.Foundation.Grid.SubGrid.h_maxSubGrd <a id="bosss.foundation.grid.subgrid.h_maxsubgrd"></a>
**Summary:** maximum cell diameter over all cells in the subgrid
[BoSSS.Foundation.Grid.IGeometricalCellsData.h_max](#bosss.foundation.grid.igeometricalcellsdata.h_max)


## Method: BoSSS.Foundation.Grid.SubGrid.TestMatrixDependency(ilPSP.LinSolvers.IMutableMatrixEx,BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Int32) <a id="bosss.foundation.grid.subgrid.testmatrixdependency(ilpsp.linsolvers.imutablematrixex,bosss.foundation.unsetteledcoordinatemapping,bosss.foundation.unsetteledcoordinatemapping,system.int32)"></a>
**Summary:** Tests if a matrix (associated with some operator) depends only on values in this sub-grid,
or not.
**Parameter:** `__Mtx` - some operator matrix
**Parameter:** `RowMap` - row-/co-domain mapping for matrix '__Mtx'
**Parameter:** `ColMap` - column/domain mapping for matrix '__Mtx'
**Parameter:** `NoOfTests` - 
**Returns:**
0.0 if there is no dependency of the matrix '__Mtx'
on values outside of this subgrid.

## Class: BoSSS.Foundation.Basis <a id="bosss.foundation.basis"></a>

**Summary:** An orthonormal, modal basis $\phi_{j,n}$ for a DG approximation of absolute degree [BoSSS.Foundation.Basis.Degree](#bosss.foundation.basis.degree).

Extensions for handling non-orthonormal, DG approximation of (absolute) degree [BoSSS.Foundation.Basis.Degree](#bosss.foundation.basis.degree).
Use with caution!!!


### Field: BoSSS.Foundation.Basis.m_GridDat <a id="bosss.foundation.basis.m_griddat"></a>
**Summary:** See [BoSSS.Foundation.Basis.GridDat](#bosss.foundation.basis.griddat)


### Property: BoSSS.Foundation.Basis.GridDat <a id="bosss.foundation.basis.griddat"></a>
**Summary:** reference to grid of this basis


### Property: BoSSS.Foundation.Basis.Data <a id="bosss.foundation.basis.data"></a>
**Summary:** common basis


### Property: BoSSS.Foundation.Basis.IsOrthonormal <a id="bosss.foundation.basis.isorthonormal"></a>
**Summary:** True if the basis forms an orthonormal system; otherwise false. Eh' klar...


## Method: BoSSS.Foundation.Basis.#ctor(BoSSS.Foundation.Grid.IGrid,System.Int32) <a id="bosss.foundation.basis.#ctor(bosss.foundation.grid.igrid,system.int32)"></a>
**Summary:** creates a new basis
**Parameter:** `grd` - the [BoSSS.Foundation.Grid.Classic.GridData](#bosss.foundation.grid.classic.griddata) that stores grid information
**Parameter:** `degree` - highest polynomial degree of basis polynomials


## Method: BoSSS.Foundation.Basis.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.basis.#ctor(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** creates a new basis
**Parameter:** `grd` - the [BoSSS.Foundation.Grid.Classic.GridData](#bosss.foundation.grid.classic.griddata) that stores grid information
**Parameter:** `degree` - highest polynomial degree of basis polynomials


## Method: BoSSS.Foundation.Basis.IsSubBasis(BoSSS.Foundation.Basis) <a id="bosss.foundation.basis.issubbasis(bosss.foundation.basis)"></a>
**Summary:** Checks if this [BoSSS.Foundation.Basis](#bosss.foundation.basis) is a sub-basis of another basis ('other').
This is the case if, and only if, the [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)-array (lets say, of length N) of
this object is equal to the "0 to N-1" subarray of 'other'.
The comparison of the array entries is done by using (see 
[BoSSS.Foundation.Grid.Polynomial.Equals(System.Object)](#bosss.foundation.grid.polynomial.equals(system.object))).
**Parameter:** `other` - 
**Returns:**



## Method: BoSSS.Foundation.Basis.Equals(System.Object) <a id="bosss.foundation.basis.equals(system.object)"></a>
**Summary:** two [BoSSS.Foundation.Basis](#bosss.foundation.basis)-objects are equal, if their polynomial list
([BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)) is equal (equal Guid for each entry).
**Parameter:** `obj` - 
**Returns:**



## Method: BoSSS.Foundation.Basis.GetHashCode <a id="bosss.foundation.basis.gethashcode"></a>
**Summary:** default implementation;


### Property: BoSSS.Foundation.Basis.Polynomials <a id="bosss.foundation.basis.polynomials"></a>
**Summary:** the DG basis functions for the reference elements
- 1st index: reference element index (see [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements))
- 2nd index: Polynomial index


## Method: BoSSS.Foundation.Basis.GetLength(System.Int32) <a id="bosss.foundation.basis.getlength(system.int32)"></a>
**Summary:** returns the number of basis functions in the cell 'jCell';
**Parameter:** `jCell` - a local cell index;


## Method: BoSSS.Foundation.Basis.GetPolynomialIndicesForDegree(System.Int32,System.Int32) <a id="bosss.foundation.basis.getpolynomialindicesfordegree(system.int32,system.int32)"></a>
**Summary:** Returns at list of indices into [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)[$iKref], where
$iKref ist the reference element index for cell 'jCell'.
In particular, returns the indices of all polynomials with the given
'degree'.
**Parameter:** `jCell` - 
**Parameter:** `degree` - 
**Returns:**



### Property: BoSSS.Foundation.Basis.Degree <a id="bosss.foundation.basis.degree"></a>
**Summary:** highest polynomial degree of all basis polynomials


### Property: BoSSS.Foundation.Basis.MinimalLength <a id="bosss.foundation.basis.minimallength"></a>
**Summary:** the minimal number of basis polynomials (per cell) over all cells;


### Property: BoSSS.Foundation.Basis.MaximalLength <a id="bosss.foundation.basis.maximallength"></a>
**Summary:** the maximum number of basis polynomials (per cell) over all cells;


### Property: BoSSS.Foundation.Basis.Length <a id="bosss.foundation.basis.length"></a>
**Summary:** the number of degrees-of-freedom per cell, 
if [BoSSS.Foundation.Basis.MinimalLength](#bosss.foundation.basis.minimallength)==[BoSSS.Foundation.Basis.MaximalLength](#bosss.foundation.basis.maximallength); otherwise an exception.


## Method: BoSSS.Foundation.Basis.GetNoOfConsecutiveCellsWithSameLength(System.Int32,System.Int32) <a id="bosss.foundation.basis.getnoofconsecutivecellswithsamelength(system.int32,system.int32)"></a>
**Summary:** Returns the number of consecutive **logical*+ cells, starting at 'j0', 
for which the number of basis functions (i.e., [BoSSS.Foundation.Basis.GetLength(System.Int32)](#bosss.foundation.basis.getlength(system.int32))) 
is the same as in cell 'j0'.
The search stops at the first cell with a different basis length or after 'Max' cells.
**Parameter:** `j0` - The starting cell index.
**Parameter:** `Max` - The maximum number of cells to check.
**Returns:**
The number of consecutive cells (including 'j0') with the same basis length as cell 'j0'.


## Method: BoSSS.Foundation.Basis.GetNoOfConsecutiveGeometricalCellsWithSameLength(System.Int32,System.Int32) <a id="bosss.foundation.basis.getnoofconsecutivegeometricalcellswithsamelength(system.int32,system.int32)"></a>
**Summary:** Returns the number of consecutive **geometrical** cells, starting at 'j0_Geom', 
for which the number of basis functions (i.e., [BoSSS.Foundation.Basis.GetLength(System.Int32)](#bosss.foundation.basis.getlength(system.int32))) 
is the same as in cell 'j0_Geom'.
The search stops at the first cell with a different basis length or after 'Max' cells.
**Parameter:** `j0_Geom` - The starting cell index.
**Parameter:** `Max` - The maximum number of cells to check.
**Returns:**
The number of consecutive cells (including 'j0_Geom') with the same basis length as cell 'j0_Geom'.


## Method: BoSSS.Foundation.Basis.GetCellsWithLength(System.Int32) <a id="bosss.foundation.basis.getcellswithlength(system.int32)"></a>
**Summary:** Returns a mask containing all cells where [BoSSS.Foundation.Basis.GetLength(System.Int32)](#bosss.foundation.basis.getlength(system.int32)) equals 'N'
**Parameter:** `N` - The exact basis length to filter for
**Returns:**
A cell mask for matching cells


## Method: BoSSS.Foundation.Basis.GetAllUsedLengths <a id="bosss.foundation.basis.getallusedlengths"></a>
**Summary:** Returns all distinct lengths, i.e., number of basis elements per cell, for the entire mesh


## Method: BoSSS.Foundation.Basis.Evaluate(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.basis.evaluate(bosss.foundation.nodeset)"></a>
**Summary:** Evaluates all polynomials in reference space
in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials));
**Parameter:** `Ns` - 
**Returns:**
- 1st index: node index
- 2nd index: polynomial index


## Method: BoSSS.Foundation.Basis.EvaluateGradient(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.basis.evaluategradient(bosss.foundation.nodeset)"></a>
**Summary:** Evaluates the gradient of all polynomials in reference space in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials));
**Parameter:** `Ns` - 
**Returns:**
- 1st index: node index
- 2nd index: polynomial index
- 3rd index: spatial dimension


## Method: BoSSS.Foundation.Basis.Evaluate2ndDeriv(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.basis.evaluate2ndderiv(bosss.foundation.nodeset)"></a>
**Summary:** A vectorized evaluation for the 2nd derivative, i.e. the Hessian, in reference coordinates: $\partial^2_{\vec{\xi}} \phi_n$.
**Parameter:** `Ns` - 
**Returns:**
An array containing the value of the second derivatives of $\phi_n$ at the nodes 'Ns':
- 1st index: node index $m$
- 2nd index: polynomial index $n$
- 3rd index: spatial direction of 1st derivation, $k$ 
- 4th index: spatial direction of 2nd derivation, $l$ 

The $(m,n,k,l)$-th entry is equal to 
$\frac{\partial}{\partial \xi_k} \frac{\partial}{\partial \xi_l} \phi_n (\vec{\xi}_m)$,
where $\vec{\xi}_m$ is the $m$-th vector in the nodeset 'Ns'.


## Method: BoSSS.Foundation.Basis.CellEval2ndDeriv(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.basis.celleval2ndderiv(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** A vectorized evaluation for the 2nd derivative, i.e. the Hessian, in physical coordinates: \f$ \partial^2_{\vec{x}} \phi_{j n} \f$.
**Parameter:** `Nodes` - 
**Parameter:** `j0` - Index of first cell in the vector
**Parameter:** `Len` - Length of the vector
**Returns:**
- 1st index: cell
- 2nd index: node index m
- 3rd index: polynomial index n
- 4th index: spatial direction of 1st derivation, k
- 5th index: spatial direction of 2nd derivation, l

So, the entry [m,n,k,l] =
$\frac{\partial}{\partial x_k} \frac{\partial}{\partial x_l} \phi_n (\vec{x}_m)$, where $\vec{x}_m$ is the
m-th vector in the nodeset #'Nodes'.


## Method: BoSSS.Foundation.Basis.CellEval(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.basis.celleval(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluates all polynomials in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)) within specified cells.
**Parameter:** `nodes` - 
**Parameter:** `j0` - index of first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Returns:**
- 1st index: cell index
- 2nd index: node index
- 3rd index: polynomial index


## Method: BoSSS.Foundation.Basis.EdgeEval(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.basis.edgeeval(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluates all polynomials in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)) at specified edges.
**Parameter:** `nodes` - 
**Parameter:** `e0` - index of first edge to evaluate
**Parameter:** `Len` - number of edges to evaluate
**Returns:**
- 1st index: cell index
- 2nd index: node index
- 3rd index: polynomial index


## Method: BoSSS.Foundation.Basis.CellEvalGradient(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.basis.cellevalgradient(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluates the gradient of all polynomials in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)) within specified cells.
**Parameter:** `NS` - 
**Parameter:** `j0` - index of first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Returns:**
- 1st index: cell index
- 2nd index: node index
- 3rd index: polynomial index
- 4th index: spatial dimension


## Method: BoSSS.Foundation.Basis.EdgeEvalGradient(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.basis.edgeevalgradient(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluates the gradient of all polynomials in this basis (see [BoSSS.Foundation.Basis.Polynomials](#bosss.foundation.basis.polynomials)) at specified edges.
**Parameter:** `NS` - 
**Parameter:** `j0` - index of first edge to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Returns:**
For each 'in'- and 'out'-cell, arrays:
- 1st index: cell index
- 2nd index: node index
- 3rd index: polynomial index
- 4th index: spatial dimension

## Class: BoSSS.Foundation.Basis.BasisInitializer <a id="bosss.foundation.basis.basisinitializer"></a>

**Summary:** This class contains all necessary information to recreate a Basis.


### Field: BoSSS.Foundation.Basis.BasisInitializer.GridGuid <a id="bosss.foundation.basis.basisinitializer.gridguid"></a>
**Summary:** The unique id of the grid.


### Field: BoSSS.Foundation.Basis.BasisInitializer.Degree <a id="bosss.foundation.basis.basisinitializer.degree"></a>
**Summary:** The degree of the basis


## Method: BoSSS.Foundation.Basis.BasisInitializer.Initialize(BoSSS.Foundation.IO.IInitializationContext) <a id="bosss.foundation.basis.basisinitializer.initialize(bosss.foundation.io.iinitializationcontext)"></a>
**Summary:** Instantiates the basis described by this object.
**Parameter:** `c` - 
**Returns:**



## Method: BoSSS.Foundation.Basis.BasisInitializer.Equals(BoSSS.Foundation.IO.Initializer{BoSSS.Foundation.Basis}) <a id="bosss.foundation.basis.basisinitializer.equals(bosss.foundation.io.initializer{bosss.foundation.basis})"></a>
**Summary:** Compares the given object 'other' with respect
to the [BoSSS.Foundation.Basis.BasisInitializer.GridGuid](#bosss.foundation.basis.basisinitializer.gridguid) and the [BoSSS.Foundation.Basis.BasisInitializer.Degree](#bosss.foundation.basis.basisinitializer.degree).
**Parameter:** `other` - 
**Returns:**



## Method: BoSSS.Foundation.Basis.BasisInitializer.GetHashCode <a id="bosss.foundation.basis.basisinitializer.gethashcode"></a>
**Summary:** Computes a hash code based on [BoSSS.Foundation.Basis.BasisInitializer.GridGuid](#bosss.foundation.basis.basisinitializer.gridguid) and
[BoSSS.Foundation.Basis.BasisInitializer.Degree](#bosss.foundation.basis.basisinitializer.degree).


### Field: BoSSS.Foundation.Basis.BasisInitializer.myInstance <a id="bosss.foundation.basis.basisinitializer.myinstance"></a>
**Summary:** An instance of the basis of described by this object; prevents
garbage collection.


### Field: BoSSS.Foundation.Basis.m_Initializer <a id="bosss.foundation.basis.m_initializer"></a>
**Summary:** See [BoSSS.Foundation.Basis.Initializer](#bosss.foundation.basis.initializer)


### Property: BoSSS.Foundation.Basis.Initializer <a id="bosss.foundation.basis.initializer"></a>
**Summary:** To support IO-architecture, NOT for direct user interaction. Note
that it is essential that this member always returns the SAME
object (reference-equals)!


## Method: BoSSS.Foundation.Basis.#ctor(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Collections.Generic.List{BoSSS.Foundation.Grid.PolynomialList}) <a id="bosss.foundation.basis.#ctor(bosss.foundation.grid.igriddata,system.int32,system.collections.generic.list{bosss.foundation.grid.polynomiallist})"></a>
**Summary:** creates a new basis, with a nonstandard polynomial set
**Parameter:** `_grd` - the [BoSSS.Foundation.Grid.Classic.GridData](#bosss.foundation.grid.classic.griddata) that stores grid information
**Parameter:** `degree` - highest polynomial degree of basis polynomials
**Parameter:** `polys` - List of polynomials


## Method: BoSSS.Foundation.Basis.GetExtrapolationMatrices(System.Int32[0:,0:],ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.basis.getextrapolationmatrices(system.int32[0:,0:],ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** Basis transformation between cells, required e.g. for cell agglomeration
**Parameter:** `CellPairs` -
- 1st index: list of cells 
- 2nd index: in {0, 1}
**Parameter:** `M` -
- 1st index: corresponds with 1st index of 'CellPairs'
- 2nd index: matrix row index 
- 3rd index: matrix column index
**Parameter:** `Minv` - the inverse of 'M'
**Remark:**
Let $K_j$ and $K_i$ be two different cells with a linear-affine 
transformation to the reference element.
Here, $j$='CellPairs'[a,0] and $i$='CellPairs'[a,1]. 
The DG-basis in these cells can uniquely be represented as
\f[ 
\phi_{j n} (\vec{x}) = p_n (\vec{x}) \vec{1}_{K_j} (\vec{x})
\textrm{ and }
\phi_{i m} (\vec{x}) = q_m (\vec{x}) \vec{1}_{K_i} (\vec{x})
\f]
where $\vec{1}_X$ denotes the characteristic function for set $X$
and $p_n$  and $p_m$  are polynomials.

Then, for the output $M$ ='M'[a,-,-] fulfills
\f[ 
\phi_{j n} + \sum_{m} M_{m n} \phi_{i m}
=
p_n \vec{1}_{K_j \cup K_i}
\f]


## Method: BoSSS.Foundation.Basis.GetChangeofBasisMatrix(System.Int32,BoSSS.Foundation.Grid.PolynomialList) <a id="bosss.foundation.basis.getchangeofbasismatrix(system.int32,bosss.foundation.grid.polynomiallist)"></a>
**Summary:** Change-of-basis, in cell 0
**Parameter:** `jCell` - 
**Parameter:** `pl` - 

## Class: BoSSS.Foundation.BasisTransformator <a id="bosss.foundation.basistransformator"></a>

**Summary:** Provides routines to transform coefficients between different Polynomial bases


### Property: BoSSS.Foundation.BasisTransformator.Origin <a id="bosss.foundation.basistransformator.origin"></a>
**Summary:** Origin Basis of this BasisTransformer


### Property: BoSSS.Foundation.BasisTransformator.Destination <a id="bosss.foundation.basistransformator.destination"></a>
**Summary:** Destination Basis of this BasisTransformer


### Property: BoSSS.Foundation.BasisTransformator.Polynomials <a id="bosss.foundation.basistransformator.polynomials"></a>
**Summary:** the DG basis functions for the reference elements

1st index: reference element index (see [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements))
2nd index: Polynomial index


### Property: BoSSS.Foundation.BasisTransformator.Origin2Dest <a id="bosss.foundation.basistransformator.origin2dest"></a>
**Summary:** Origin -> Destination
- index: reference element index


### Property: BoSSS.Foundation.BasisTransformator.Dest2Origin <a id="bosss.foundation.basistransformator.dest2origin"></a>
**Summary:** Destination -> Origin
- index: reference element index


## Method: BoSSS.Foundation.BasisTransformator.ConstructTransform <a id="bosss.foundation.basistransformator.constructtransform"></a>
**Summary:** From origin basis to destination basis $T = \langle B_i,B_j \rangle^{-1} \langle B_j, P_k \rangle = M^{-1} \cdot S$


## Method: BoSSS.Foundation.BasisTransformator.ConstructInverseTransform <a id="bosss.foundation.basistransformator.constructinversetransform"></a>
**Summary:** From destination basis to origin basis: $T = \langle P_i,P_j \rangle^{-1} \langle P_j, B_k \rangle$


## Method: BoSSS.Foundation.BasisTransformator.TestTransformQuality <a id="bosss.foundation.basistransformator.testtransformquality"></a>

## Class: BoSSS.Foundation.BernsteinTransformator <a id="bosss.foundation.bernsteintransformator"></a>

**Summary:** Calculates the Transformation from and to Bernstein Basis Coefficients


### Property: BoSSS.Foundation.BernsteinTransformator.FaceCoefficients <a id="bosss.foundation.bernsteintransformator.facecoefficients"></a>
**Summary:** Indices of Coefficients lying on faces of the refelement
1st index: Refelement
2nd index: Face

## Class: BoSSS.Foundation.Caching.CacheStrategy <a id="bosss.foundation.caching.cachestrategy"></a>

**Summary:** Options for Different Caching Strategies


### Field: BoSSS.Foundation.Caching.CacheStrategy.DiscardLeastFrequentlyUsed <a id="bosss.foundation.caching.cachestrategy.discardleastfrequentlyused"></a>
**Summary:** Cache object with lowest number of accesses will be discarded first.


### Field: BoSSS.Foundation.Caching.CacheStrategy.DiscardLeastRecentyUsed <a id="bosss.foundation.caching.cachestrategy.discardleastrecentyused"></a>
**Summary:** Cache object wich were not accessed for the longest time will be discarded first.

## Class: BoSSS.Foundation.Caching.Cache <a id="bosss.foundation.caching.cache"></a>

**Summary:** Cache for almost everything. All kinds of cache-logic objects
may place their numerical results here and can have them back, if they are not thrown away.


## Method: BoSSS.Foundation.Caching.Cache.Verify(System.Int64@,System.Int64@) <a id="bosss.foundation.caching.cache.verify(system.int64@,system.int64@)"></a>
**Summary:** Basic checks on the correctness of the data structure.


### Field: BoSSS.Foundation.Caching.Cache.RefCounter <a id="bosss.foundation.caching.cache.refcounter"></a>
**Summary:** Reference counter


### Property: BoSSS.Foundation.Caching.Cache.MaxMem <a id="bosss.foundation.caching.cache.maxmem"></a>
**Summary:** Maximal memory, in bytes, which is used for caching.


### Property: BoSSS.Foundation.Caching.Cache.Strategy <a id="bosss.foundation.caching.cache.strategy"></a>
**Summary:** Caching strategy; may affect performance, or not.


### Property: BoSSS.Foundation.Caching.Cache.UsedMem <a id="bosss.foundation.caching.cache.usedmem"></a>
**Summary:** Total memory in cache, in bytes


### Property: BoSSS.Foundation.Caching.Cache.OverheadMem <a id="bosss.foundation.caching.cache.overheadmem"></a>
**Summary:** Some estimation for the total overhead.


## Method: BoSSS.Foundation.Caching.Cache.ResetCache <a id="bosss.foundation.caching.cache.resetcache"></a>
**Summary:** Empties the cache, resets statistics.


## Method: BoSSS.Foundation.Caching.Cache.ClearCache <a id="bosss.foundation.caching.cache.clearcache"></a>
**Summary:** Empties the cache, resets statistics.


### Property: BoSSS.Foundation.Caching.Cache.Hits <a id="bosss.foundation.caching.cache.hits"></a>
**Summary:** Number of cache hits.


### Property: BoSSS.Foundation.Caching.Cache.Misses <a id="bosss.foundation.caching.cache.misses"></a>
**Summary:** Number of cache misses.


## Method: BoSSS.Foundation.Caching.Cache.GetItem(System.UInt64) <a id="bosss.foundation.caching.cache.getitem(system.uint64)"></a>
**Summary:** Returns the item stored under reference 'Reference'
-- or --
null, if the object has been removed from the cache.


## Method: BoSSS.Foundation.Caching.Cache.IsAlive(System.UInt64) <a id="bosss.foundation.caching.cache.isalive(system.uint64)"></a>
**Summary:** Returns true if the item stored under reference 'Reference' is still present in the cache, false otherwise.
In contrast to [BoSSS.Foundation.Caching.Cache.GetItem(System.UInt64)](#bosss.foundation.caching.cache.getitem(system.uint64)), this is cheaper and does not affect cache statistics.


## Method: BoSSS.Foundation.Caching.Cache.CacheItem(System.Object,System.Int32) <a id="bosss.foundation.caching.cache.cacheitem(system.object,system.int32)"></a>
**Summary:** Caches some object 'Item'.
**Parameter:** `HonestItemSizeInBytes` - The size of 'Item' in bytes.
**Parameter:** `Item` - Object which should be cached.
**Returns:**
A reference code for later access to the object 'Item'.


## Method: BoSSS.Foundation.Caching.Cache.ForgetItem(System.UInt64) <a id="bosss.foundation.caching.cache.forgetitem(system.uint64)"></a>
**Summary:** Removes some cached item from the cache.


## Method: BoSSS.Foundation.Caching.Cache.ReCacheItem(ilPSP.MultidimensionalArray,System.Int32,System.UInt64) <a id="bosss.foundation.caching.cache.recacheitem(ilpsp.multidimensionalarray,system.int32,system.uint64)"></a>


### Property: BoSSS.Foundation.Caching.Cache.NoOfUsedBanks <a id="bosss.foundation.caching.cache.noofusedbanks"></a>
**Summary:** No of items currently in cache

## Class: BoSSS.Foundation.Caching.MonomialCache <a id="bosss.foundation.caching.monomialcache"></a>

**Summary:** Caches monomials ( e.g. $x$, $x y$, $x y^2$) for node sets. 
A global singleton, see [BoSSS.Foundation.Caching.MonomialCache.Instance](#bosss.foundation.caching.monomialcache.instance).


### Property: BoSSS.Foundation.Caching.MonomialCache.Instance <a id="bosss.foundation.caching.monomialcache.instance"></a>
**Summary:** Access to the single, global instance.


## Method: BoSSS.Foundation.Caching.MonomialCache.Evaluate(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.monomialcache.evaluate(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Un-cached evaluation of monomials at nodes 'Nodes'
up to degree 'Degree'.


## Method: BoSSS.Foundation.Caching.MonomialCache.GetMonomials(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.monomialcache.getmonomials(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Evaluates the monomials at 'NS' up to the
'degree' of this polynomial
**Parameter:** `NS` - Points at which the monomials should be evaluated;
1st index: Point index;
2nd index: Spatial coordinate index;
**Parameter:** `degree` - Required degree.
**Returns:**
Evaluated monomials at 'NS';
- 1st index: Point index;
- 2nd index: Spatial coordinate index;
- 3rd index: Exponent
If monomials are already cached for degree higher than 'degree', these are returned, so the is 
range of the third index may be higher than expected.

## Class: BoSSS.Foundation.Caching.CacheLogic_NsP <a id="bosss.foundation.caching.cachelogic_nsp"></a>

**Summary:** Cache-Logic for values which depend on
- [BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset) and (`Ns`)
- polynomial degree (`P`).


## Method: BoSSS.Foundation.Caching.CacheLogic_NsP.Evaluate(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogic_nsp.evaluate(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Evaluation of Values that should subsequently be cached.
**Parameter:** `Nodes` -
Points/Nodes to evaluate in the reference coordinate system;
- 1st index: node index
- 2nd index: spatial dimension; (0 for 1D; 0,1 for 2D; 0,1,2 for 3D)
**Parameter:** `Degree` - polynomial degree
**Returns:**



## Method: BoSSS.Foundation.Caching.CacheLogic_NsP.GetValues(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogic_nsp.getvalues(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Returns the (hopefully) cached value.

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_Ns <a id="bosss.foundation.caching.cachelogicimpl_ns"></a>

**Summary:** Delegate-supporting version of [BoSSS.Foundation.Caching.CacheLogic_Ns](#bosss.foundation.caching.cachelogic_ns).


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_Ns.#ctor(System.Func{BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray}) <a id="bosss.foundation.caching.cachelogicimpl_ns.#ctor(system.func{bosss.foundation.nodeset,ilpsp.multidimensionalarray})"></a>
**Summary:** ctor.
**Parameter:** `evalfunc` - The evaluation function, see [BoSSS.Foundation.Caching.CacheLogic_Ns.Evaluate(BoSSS.Foundation.NodeSet)](#bosss.foundation.caching.cachelogic_ns.evaluate(bosss.foundation.nodeset))


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_Ns.Evaluate(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.caching.cachelogicimpl_ns.evaluate(bosss.foundation.nodeset)"></a>
**Summary:** Evaluation fo Values if they are not in the cache.
**Parameter:** `Nodes` - node set

## Class: BoSSS.Foundation.Caching.CacheLogic_Ns <a id="bosss.foundation.caching.cachelogic_ns"></a>

**Summary:** Cache-Logic for values which depend on [BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset) (`Ns`).


## Method: BoSSS.Foundation.Caching.CacheLogic_Ns.#ctor <a id="bosss.foundation.caching.cachelogic_ns.#ctor"></a>
**Summary:** ctor.


## Method: BoSSS.Foundation.Caching.CacheLogic_Ns.Evaluate(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.caching.cachelogic_ns.evaluate(bosss.foundation.nodeset)"></a>
**Summary:** Evaluation of Values that should subsequently be cached.
**Parameter:** `Nodes` - Points/Nodes to evaluate in the reference coordinate system;
**Returns:**



## Method: BoSSS.Foundation.Caching.CacheLogic_Ns.GetValues(BoSSS.Foundation.NodeSet) <a id="bosss.foundation.caching.cachelogic_ns.getvalues(bosss.foundation.nodeset)"></a>
**Summary:** Returns the (hopefully) cached value.

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_NsP <a id="bosss.foundation.caching.cachelogicimpl_nsp"></a>

**Summary:** Delegate-supporting version of [BoSSS.Foundation.Caching.CacheLogicImpl_NsP](#bosss.foundation.caching.cachelogicimpl_nsp).


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_NsP.#ctor(System.Func{BoSSS.Foundation.NodeSet,System.Int32,ilPSP.MultidimensionalArray}) <a id="bosss.foundation.caching.cachelogicimpl_nsp.#ctor(system.func{bosss.foundation.nodeset,system.int32,ilpsp.multidimensionalarray})"></a>
**Summary:** ctor.
**Parameter:** `evalfunc` - The evaluation function, see [BoSSS.Foundation.Caching.CacheLogicImpl_NsP.Evaluate(BoSSS.Foundation.NodeSet,System.Int32)](#bosss.foundation.caching.cachelogicimpl_nsp.evaluate(bosss.foundation.nodeset,system.int32))


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_NsP.Evaluate(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogicimpl_nsp.evaluate(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Evaluation of Values if they are not in the cache.
**Parameter:** `Degree` - minimum required degree.
**Parameter:** `Nodes` - node set

## Class: BoSSS.Foundation.Caching.CacheLogicImplBy_CNs <a id="bosss.foundation.caching.cachelogicimplby_cns"></a>

**Summary:** Delegate-supporting version of [BoSSS.Foundation.Caching.CacheLogic_CNs](#bosss.foundation.caching.cachelogic_cns).


## Method: BoSSS.Foundation.Caching.CacheLogicImplBy_CNs.#ctor(BoSSS.Foundation.Grid.Classic.GridData,System.Action{BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray},System.Func{System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray}) <a id="bosss.foundation.caching.cachelogicimplby_cns.#ctor(bosss.foundation.grid.classic.griddata,system.action{bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray},system.func{system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray})"></a>
**Summary:** ctor.
**Parameter:** `g` - 
**Parameter:** `cv` - Compute-value function, see [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).
**Parameter:** `ca` - Memory allocation function, see [BoSSS.Foundation.Caching.CacheLogic_CNs.Allocate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet)](#bosss.foundation.caching.cachelogic_cns.allocate(system.int32,system.int32,bosss.foundation.nodeset)).


## Method: BoSSS.Foundation.Caching.CacheLogicImplBy_CNs.#ctor(BoSSS.Foundation.Grid.Classic.GridData,System.Action{BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray},System.Func{System.Int32,System.Int32,System.Int32[]}) <a id="bosss.foundation.caching.cachelogicimplby_cns.#ctor(bosss.foundation.grid.classic.griddata,system.action{bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray},system.func{system.int32,system.int32,system.int32[]})"></a>
**Summary:** ctor.
**Parameter:** `g` - 
**Parameter:** `cv` - Compute-value function, see [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).
**Parameter:** `bl` - Buffer length function.


## Method: BoSSS.Foundation.Caching.CacheLogicImplBy_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.caching.cachelogicimplby_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Uses the delegate handed to constructor.


## Method: BoSSS.Foundation.Caching.CacheLogicImplBy_CNs.Allocate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.caching.cachelogicimplby_cns.allocate(system.int32,system.int32,bosss.foundation.nodeset)"></a>
**Summary:** Uses the delegate handed to constructor.

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP <a id="bosss.foundation.caching.cachelogicimpl_cnsp"></a>

**Summary:** Cache-logic for data which depends 
- on cell (`C`), 
- on [BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset) (`Ns`)
- and polynomial degree (`P`)


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.#ctor(BoSSS.Foundation.Grid.IGridData,System.Action{BoSSS.Foundation.NodeSet,System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray},System.Func{System.Int32,System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray}) <a id="bosss.foundation.caching.cachelogicimpl_cnsp.#ctor(bosss.foundation.grid.igriddata,system.action{bosss.foundation.nodeset,system.int32,system.int32,system.int32,ilpsp.multidimensionalarray},system.func{system.int32,system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray})"></a>
**Summary:** ctor.
**Parameter:** `g` - 
**Parameter:** `cv` - Compute-value function.
**Parameter:** `ca` - Memory allocation function.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.#ctor(BoSSS.Foundation.Grid.IGridData,System.Action{BoSSS.Foundation.NodeSet,System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray},System.Func{System.Int32,System.Int32,System.Int32,System.Int32[]}) <a id="bosss.foundation.caching.cachelogicimpl_cnsp.#ctor(bosss.foundation.grid.igriddata,system.action{bosss.foundation.nodeset,system.int32,system.int32,system.int32,ilpsp.multidimensionalarray},system.func{system.int32,system.int32,system.int32,system.int32[]})"></a>
**Summary:** ctor.
**Parameter:** `g` - 
**Parameter:** `cv` - Compute-value function, see [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).
**Parameter:** `bl` - Buffer length function.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.GetValue_Cell(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogicimpl_cnsp.getvalue_cell(bosss.foundation.nodeset,system.int32,system.int32,system.int32)"></a>
**Summary:** returns the values for node set 'NS',
in the cells (with local index) 'j0' (including)
to 'j0'+'Len' (excluding).
**Parameter:** `NS` - the node set.
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Parameter:** `Degree` - Polynomial degree
**Returns:**

**Remark:**
This method returns, if available, cached values  or it re-computes them by
calling **BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.m_ComputeValues**.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.GetValue_EdgeDV(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogicimpl_cnsp.getvalue_edgedv(bosss.foundation.nodeset,system.int32,system.int32,system.int32)"></a>
**Summary:** Double-value (i.e. values for IN- and OUT-cell) evaluation at edges,
used for properties which ar discontinuous at edges.


### Property: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.GridData <a id="bosss.foundation.caching.cachelogicimpl_cnsp.griddata"></a>
**Summary:** Grid reference.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CNsP.Clear <a id="bosss.foundation.caching.cachelogicimpl_cnsp.clear"></a>
**Summary:** Disposes all chached values.

## Class: BoSSS.Foundation.Caching.CacheLogic_CNs <a id="bosss.foundation.caching.cachelogic_cns"></a>

**Summary:** Cache-logic for data which depends 
- on cell (`C`) and 
- on [BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset) (`Ns`).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.caching.cachelogic_cns.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** constructor


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Implementers should override this method for the computation of values which are not in the cache.
**Parameter:** `N` - Nodes at which evaluation should be done.
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Parameter:** `output` - reference to storage buffer for result


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.Allocate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.caching.cachelogic_cns.allocate(system.int32,system.int32,bosss.foundation.nodeset)"></a>
**Summary:** Allocates memory to store results from [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).
**Parameter:** `i0` - Index of first item (edge or cell).
**Parameter:** `Len` - Number of items.
**Parameter:** `NS` - Node set.
**Returns:**
Some buffer, 
1st length is expected to be equal to 'Len',
2nd length is expected to be equal to number of nodes in 'NS'.


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_Cell(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_cell(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** returns the values for node-set 'NS',
in the cells (with local index) 'j0' (including)
to 'j0'+'Len' (excluding).
**Parameter:** `NS` - the node set.
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Returns:**

**Remark:**
This method returns, if available, cached values  or it re-computes them by
calling [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_Cell(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_cell(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** returns the values for node-set 'NS',
in the cell (with local index) 'j0'.
**Parameter:** `NS` - the node set.
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Returns:**

**Remark:**
This method returns, if available, cached values  or it re-computes them by
calling [BoSSS.Foundation.Caching.CacheLogic_CNs.ComputeValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.caching.cachelogic_cns.computevalues(bosss.foundation.nodeset,system.int32,system.int32,ilpsp.multidimensionalarray)).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_EdgeSV(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_edgesv(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Single-value evaluation at edges,
used for properties which are unique at edges (e.g. edge normals or global coordinates).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_EdgeSV(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_edgesv(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Single-value evaluation at edges,
used for properties which are unique at edges (e.g. edge normals or global coordinates).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_EdgeDV(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_edgedv(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Double-value (i.e. values for IN- and OUT-cell) evaluation at edges,
used for properties which are discontinuous at edges (e.g. DG-fields).


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.GetValue_EdgeDV(BoSSS.Foundation.NodeSet,System.Int32) <a id="bosss.foundation.caching.cachelogic_cns.getvalue_edgedv(bosss.foundation.nodeset,system.int32)"></a>
**Summary:** Single-value evaluation at edges,
used for properties which are unique at edges (e.g. edge normals or global coordinates).


### Property: BoSSS.Foundation.Caching.CacheLogic_CNs.GridData <a id="bosss.foundation.caching.cachelogic_cns.griddata"></a>
**Summary:** The grid; required since one key into the cache logic is the cell index.


## Method: BoSSS.Foundation.Caching.CacheLogic_CNs.Clear <a id="bosss.foundation.caching.cachelogic_cns.clear"></a>
**Summary:** Disposes all chached values.

## Class: BoSSS.Foundation.Caching.CorEP_logic <a id="bosss.foundation.caching.corep_logic"></a>


### Field: BoSSS.Foundation.Caching.CorEP_logic.cells2cchunk <a id="bosss.foundation.caching.corep_logic.cells2cchunk"></a>
**Summary:** mapping from local cell index to computed chunk
- index: local cell index
- content: chunk which should contain the respective cell


## Method: BoSSS.Foundation.Caching.CorEP_logic.GarbageCollect <a id="bosss.foundation.caching.corep_logic.garbagecollect"></a>
**Summary:** Removes cache references to objects that were disposed from the [BoSSS.Foundation.Caching.Cache](#bosss.foundation.caching.cache).
**Returns:**
True if nothing is in the cache anymore;


## Method: BoSSS.Foundation.Caching.CorEP_logic.KillChunk(BoSSS.Foundation.Caching.CorEP_logic.CChunk) <a id="bosss.foundation.caching.corep_logic.killchunk(bosss.foundation.caching.corep_logic.cchunk)"></a>
**Summary:** removes the 'cc' from the internal cells-to-chunk mapping [BoSSS.Foundation.Caching.CorEP_logic.cells2cchunk](#bosss.foundation.caching.corep_logic.cells2cchunk)

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_CP <a id="bosss.foundation.caching.cachelogicimpl_cp"></a>

**Summary:** Cache logic for values which depend on cell and polynomial degree.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CP.#ctor(BoSSS.Foundation.Grid.IGridData,System.Func{System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray}) <a id="bosss.foundation.caching.cachelogicimpl_cp.#ctor(bosss.foundation.grid.igriddata,system.func{system.int32,system.int32,system.int32,ilpsp.multidimensionalarray})"></a>
**Summary:** constructor


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_CP.GetValue_Cell(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogicimpl_cp.getvalue_cell(system.int32,system.int32,system.int32)"></a>
**Summary:** returns the values in the cells (with local index)
'j0' (including) to
'j0'+'Len' (excluding).
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Parameter:** `degree` - Polynomial degree
**Returns:**

**Remark:**
This method returns, if available, cached values  or it re-computes them by
calling **BoSSS.Foundation.Caching.CorEP_logic.GetValue(System.Int32,System.Int32,System.Int32)**.

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_C <a id="bosss.foundation.caching.cachelogicimpl_c"></a>

**Summary:** Cache logic for values which depend on cell.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_C.#ctor(BoSSS.Foundation.Grid.Classic.GridData,BoSSS.Foundation.Caching.CacheLogicImpl_C.Del_ComputeValues) <a id="bosss.foundation.caching.cachelogicimpl_c.#ctor(bosss.foundation.grid.classic.griddata,bosss.foundation.caching.cachelogicimpl_c.del_computevalues)"></a>
**Summary:** constructor

## Class: BoSSS.Foundation.Caching.CacheLogicImpl_C.Del_ComputeValues <a id="bosss.foundation.caching.cachelogicimpl_c.del_computevalues"></a>

**Summary:** Implementers should override this method for the computation of
values which are not in the cache.


## Method: BoSSS.Foundation.Caching.CacheLogicImpl_C.GetValue_Cell(System.Int32,System.Int32) <a id="bosss.foundation.caching.cachelogicimpl_c.getvalue_cell(system.int32,system.int32)"></a>
**Summary:** returns the values in the cells (with local index)
'j0' (including) to
'j0'+'Len' (excluding).
**Parameter:** `j0` - local cell index of the first cell to evaluate
**Parameter:** `Len` - number of cells to evaluate
**Returns:**

**Remark:**
This method returns, if available, cached values  or it re-computes them by
calling [BoSSS.Foundation.Caching.CacheLogicImpl_CP.GetValue_Cell(System.Int32,System.Int32,System.Int32)](#bosss.foundation.caching.cachelogicimpl_cp.getvalue_cell(system.int32,system.int32,system.int32)).


### Property: BoSSS.Foundation.Caching.CacheLogicImpl_C.GridData <a id="bosss.foundation.caching.cachelogicimpl_c.griddata"></a>
**Summary:** The current grid

## Class: BoSSS.Foundation.Caching.EdgeNormalsCacheLogic_CNsFace <a id="bosss.foundation.caching.edgenormalscachelogic_cnsface"></a>

**Summary:** Cache-logic for data which depends on cell, [BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset) and cell-face.
This one is only used for edge normals and edge integration metrics.


## Method: BoSSS.Foundation.Caching.EdgeNormalsCacheLogic_CNsFace.#ctor(BoSSS.Foundation.Grid.Classic.GridData) <a id="bosss.foundation.caching.edgenormalscachelogic_cnsface.#ctor(bosss.foundation.grid.classic.griddata)"></a>
**Summary:** constructor


## Method: BoSSS.Foundation.Caching.EdgeNormalsCacheLogic_CNsFace.GetNormals_Edge(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.caching.edgenormalscachelogic_cnsface.getnormals_edge(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluation of a single-valued property on edges.


## Method: BoSSS.Foundation.Caching.EdgeNormalsCacheLogic_CNsFace.GetIntegrationMetric(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.caching.edgenormalscachelogic_cnsface.getintegrationmetric(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** Evaluation of a single-valued property on edges.

## Class: BoSSS.Foundation.Caching.BasisEdgeValuesCacheLogic <a id="bosss.foundation.caching.basisedgevaluescachelogic"></a>


## Method: BoSSS.Foundation.Caching.BasisEdgeValuesCacheLogic.GetValues(BoSSS.Foundation.NodeSet,System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.caching.basisedgevaluescachelogic.getvalues(bosss.foundation.nodeset,system.int32,system.int32,system.int32)"></a>
**Summary:** Evaluation of basis values for all edge-to-cell transformation within a specific range of edges
**Parameter:** `NS` - Node-Set
**Parameter:** `e0` - start of edge-range to consider
**Parameter:** `Len` - length of range to consider
**Parameter:** `Degree` - 
**Returns:**
- 1st index: edge-to-cell transformation index, for some specific edge obtained throug [BoSSS.Foundation.Grid.IGeometricalEdgeData.Edge2CellTrafoIndex](#bosss.foundation.grid.igeometricaledgedata.edge2celltrafoindex)
- 2nd index: node index, correlates with nodes in 'NS'
- 3rd index: DG mode index
- 4th index (if available): spatial direction

## Class: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1 <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1"></a>

**Summary:** Wrapper that creates quadrature rules in the volume coordinate
system from rules given by a [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1](#bosss.foundation.quadrature.iquadrulefactory`1)s that
create rules on the edges of a [BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.RefElement](#bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.refelement).


### Field: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.context <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.context"></a>
**Summary:** Omnipresent context


### Field: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.edgeRuleFactory <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.edgerulefactory"></a>
**Summary:** The factory to be wrapped


## Method: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement,BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement,bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Constructs a wrapper for 'edgeRuleFactory'.
**Parameter:** `context` - Omnipresent context
**Parameter:** `edgeRuleFactory` - The factory to be wrapped
**Parameter:** `s` - some reference element of the grid, see [BoSSS.Foundation.Grid.Classic.GridCommons.RefElements](#bosss.foundation.grid.classic.gridcommons.refelements)


## Method: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.GetCachedRuleOrders <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** Uses the given edge rule factory to create quadrature rules for
the boundaries of all cells in 'mask'.
**Parameter:** `mask` - A [BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask) containing all cells to be
integrated over.
**Parameter:** `order` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Returns:**
Quadrature rules for the boundary of all cells in
'mask' in the volume coordinate system.


### Property: BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1.RefElement <a id="bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1.refelement"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.RefElement](#bosss.foundation.quadrature.iquadrulefactory`1.refelement)

## Class: BoSSS.Foundation.Quadrature.CellBoundaryIntegrationMetric <a id="bosss.foundation.quadrature.cellboundaryintegrationmetric"></a>

**Summary:** integration metric for area integrals on cell boundaries


### Property: BoSSS.Foundation.Quadrature.CellBoundaryIntegrationMetric.AlwaysUsePerNodeScaling <a id="bosss.foundation.quadrature.cellboundaryintegrationmetric.alwaysusepernodescaling"></a>
**Summary:** For cell boundaries, the scaling is constant for each face of the cell for linear elements, therefore always false;
c.f. [BoSSS.Foundation.Quadrature.IIntegrationMetric.AlwaysUsePerNodeScaling](#bosss.foundation.quadrature.iintegrationmetric.alwaysusepernodescaling);


## Method: BoSSS.Foundation.Quadrature.CellBoundaryIntegrationMetric.GetScalingsForLinearElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryintegrationmetric.getscalingsforlinearelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** integration metrics for linear mapped cells
**Returns:**
- 1st index: cell 
- 2nd index: face


## Method: BoSSS.Foundation.Quadrature.CellBoundaryIntegrationMetric.GetScalingsForNonlinElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryintegrationmetric.getscalingsfornonlinelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** integration metrics for non-linear mapped cells
**Returns:**
- 1st index: cell
- 2nd index: quadrature node

## Class: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1 <a id="bosss.foundation.quadrature.cellboundaryquadrature`1"></a>

**Summary:** Specialized version of **BoSSS.Foundation.Quadrature** for cell boundary
integrals. That is, it builds volume quad rules based on the edge rules
of all edges of a given cell.

**Remark:**
This functionality has been separated from the **BoSSS.Foundation.Quadrature**
because having different numbers of quadrature points per edge was hard
to realize using the existing structures.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.#ctor(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.#ctor(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** constructor, for a quadrature rule which is already compiled ('domNrule')
**Parameter:** `noOfIntegralsPerCell` - tensor dimension of the integrand
**Parameter:** `context` - 
**Parameter:** `domNrule` - quadrature rule and domain
**Parameter:** `cs` - Physical or reference coordinate system?


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.nextpart(system.boolean@,system.int32@,system.int32,system.int32)"></a>
**Summary:** Sweeps whether cell 'i0' is linear/nonlinear and how many cells of the same type are going to come after it.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.checkquadraturechunk(system.int32,system.int32,system.int32)"></a>
**Summary:** Some DEBUG checks on the current quadrature chunk.


### Property: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.CurrentRuleRefElementIndex <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.currentrulerefelementindex"></a>
**Summary:** Index of the current rule's reference element into
[BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements).


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.DoQuadrature(`0,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.doquadrature(`0,system.int32,system.int32)"></a>
**Summary:** performs the quadrature


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.AllocateBuffersInternal(System.Int32,BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.allocatebuffersinternal(system.int32,bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** 2nd phase of quadrature: allocation of memory for 
the [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray))-method;
Called whenever the node set or the number of cells per evaluation is changed;
**Parameter:** `NoOfItems` - number of edges or cells to integrate
**Parameter:** `rule` - The quadrature rule applied to each item
**Parameter:** `ThreadRank` - 
**Parameter:** `iThread` - 


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.cellboundaryquadrature`1.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** creates a cell quadrature, where integrand evaluation ('_Evaluate') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.CellQuadrature](#bosss.foundation.quadrature.cellquadrature).

## Class: BoSSS.Foundation.Quadrature.CellBoundaryQuadRule <a id="bosss.foundation.quadrature.cellboundaryquadrule"></a>

**Summary:** Variant of [BoSSS.Foundation.Quadrature.QuadRule](#bosss.foundation.quadrature.quadrule) that additionally stores the
number of nodes per edge of the edge rules that have been used to
construct this rule.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadRule.CreateEmpty(BoSSS.Foundation.Grid.RefElements.RefElement,System.Int32,System.Int32,System.Int32,System.Boolean) <a id="bosss.foundation.quadrature.cellboundaryquadrule.createempty(bosss.foundation.grid.refelements.refelement,system.int32,system.int32,system.int32,system.boolean)"></a>
**Summary:** Creates an empty rule.


### Property: BoSSS.Foundation.Quadrature.CellBoundaryQuadRule.NumbersOfNodesPerFace <a id="bosss.foundation.quadrature.cellboundaryquadrule.numbersofnodesperface"></a>
**Summary:** For each face of the reference element: The number of nodes
of the edge rules that has been used to construct this volume rule.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadRule.Clone <a id="bosss.foundation.quadrature.cellboundaryquadrule.clone"></a>
**Summary:** Creates a deep copy of this object
**Returns:**
A deep copy of this object

## Class: BoSSS.Foundation.Quadrature.CellIntegrationMetric <a id="bosss.foundation.quadrature.cellintegrationmetric"></a>

**Summary:** integration metric for volume integrals


### Property: BoSSS.Foundation.Quadrature.CellIntegrationMetric.AlwaysUsePerNodeScaling <a id="bosss.foundation.quadrature.cellintegrationmetric.alwaysusepernodescaling"></a>
**Summary:** For cell volumes, the scaling is constant within the cell for linear elements, therefore always false;
c.f. [BoSSS.Foundation.Quadrature.IIntegrationMetric.AlwaysUsePerNodeScaling](#bosss.foundation.quadrature.iintegrationmetric.alwaysusepernodescaling);


## Method: BoSSS.Foundation.Quadrature.CellIntegrationMetric.GetScalingsForLinearElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellintegrationmetric.getscalingsforlinearelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** the absolute value of the Jacobian determinate, for the 
transformation that translates cell reference coordinates into physical coordinates.


## Method: BoSSS.Foundation.Quadrature.CellIntegrationMetric.GetScalingsForNonlinElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellintegrationmetric.getscalingsfornonlinelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** the absolute value of the Jacobian determinate, for the 
transformation that translates cell reference coordinates into physical coordinates.

## Class: BoSSS.Foundation.Quadrature.CellQuadrature <a id="bosss.foundation.quadrature.cellquadrature"></a>

**Summary:** quadrature over cells.


## Method: BoSSS.Foundation.Quadrature.CellQuadrature.#ctor(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.cellquadrature.#ctor(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** constructor
**Parameter:** `noOfIntegralsPerCell` - 
**Parameter:** `context` - 
**Parameter:** `rule` - 
**Parameter:** `cs` - integrate in physical or reference coordinates?


## Method: BoSSS.Foundation.Quadrature.CellQuadrature.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellquadrature.nextpart(system.boolean@,system.int32@,system.int32,system.int32)"></a>
**Summary:** Sweeps whether cell 'i0' is linear/nonlinear and how many cells of the same type are going to come after it.


## Method: BoSSS.Foundation.Quadrature.CellQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.cellquadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** creates a cell quadrature, where integrand evaluation ('_Evaluate') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.CellQuadrature](#bosss.foundation.quadrature.cellquadrature).


## Method: BoSSS.Foundation.Quadrature.CellQuadrature.GetQuadrature2(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_EvaluateEx,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_AllocateBuffersEx,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_QuadNodesChanged,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_OnCloneForThreadParallelization,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.cellquadrature.getquadrature2(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_evaluateex,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_allocatebuffersex,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_quadnodeschanged,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_oncloneforthreadparallelization,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** Creates a cell quadrature, where integrand evaluation ('_Evaluate') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.CellQuadrature](#bosss.foundation.quadrature.cellquadrature).


## Method: BoSSS.Foundation.Quadrature.CellQuadrature.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.cellquadrature.checkquadraturechunk(system.int32,system.int32,system.int32)"></a>
**Summary:** Some DEBUG checks on the current quadrature chunk.


### Property: BoSSS.Foundation.Quadrature.CellQuadrature.CurrentRuleRefElementIndex <a id="bosss.foundation.quadrature.cellquadrature.currentrulerefelementindex"></a>
**Summary:** Index of the current rule's reference element into
[BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements).

## Class: BoSSS.Foundation.Quadrature.CompositeQuadRule`1 <a id="bosss.foundation.quadrature.compositequadrule`1"></a>

**Summary:** Instances of this class describe which quadrature rule should be used
at which quadrature item (cell or edge).

**Remark:**
The main motivation behind this class is the re-use of quadrature nodes
and/or weights.


### Field: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.chunkRulePairs <a id="bosss.foundation.quadrature.compositequadrule`1.chunkrulepairs"></a>
**Summary:** Pairs of quadrature rules and the domain on which they should be
applied


### Property: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.NumberOfItems <a id="bosss.foundation.quadrature.compositequadrule`1.numberofitems"></a>
**Summary:** The number of quadrature items (cells or edges)


### Property: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.IntegrationMetric <a id="bosss.foundation.quadrature.compositequadrule`1.integrationmetric"></a>
**Summary:** [BoSSS.Foundation.Quadrature.ICompositeQuadRule`1.IntegrationMetric](#bosss.foundation.quadrature.icompositequadrule`1.integrationmetric)


## Method: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.GetEnumerator <a id="bosss.foundation.quadrature.compositequadrule`1.getenumerator"></a>
**Summary:** Defines the actual mapping of the integration sub-domains to the
respective quadrature rules.
**Returns:**
An enumerator over all pairs of chunks of the integration domain
and the associated quadrature rules.


## Method: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.quadrature.compositequadrule`1.system#collections#ienumerable#getenumerator"></a>
**Summary:** [BoSSS.Foundation.Quadrature.CompositeQuadRule`1.GetEnumerator](#bosss.foundation.quadrature.compositequadrule`1.getenumerator)
**Returns:**



## Method: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.Create``1(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},System.Int32,``0,BoSSS.Foundation.Quadrature.IIntegrationMetric) <a id="bosss.foundation.quadrature.compositequadrule`1.create``1(bosss.foundation.quadrature.iquadrulefactory{`0},system.int32,``0,bosss.foundation.quadrature.iintegrationmetric)"></a>
**Summary:** Creates a new composite quadrature rules of minimal order
'order' from a single quadrature rule factory and
an associated domain of integration.
**Parameter:** `ruleFactory` - The quadrature rule factory to be used to create the quadrature
rules for the given domain.
**Parameter:** `order` - The minimal order of the quadrature rules to be used. See
[BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32)).
**Parameter:** `domain` - The domain to be integrated over.
**Parameter:** `scaling` - 
**Returns:**
A composite rule containing the quadrature rules associated with
all elements of the given domain.
**Remark:**
The main specialty about the resulting composite rule is that the
implementation guarantees that the sets of nodes and weights
associated to the respective quadrature rules share the same
objects of their contents are equal. This is allows for the
optimization of the execution of the quadrature itself.


## Method: BoSSS.Foundation.Quadrature.CompositeQuadRule`1.Merge(BoSSS.Foundation.Quadrature.CompositeQuadRule{`0},BoSSS.Foundation.Quadrature.CompositeQuadRule{`0}) <a id="bosss.foundation.quadrature.compositequadrule`1.merge(bosss.foundation.quadrature.compositequadrule{`0},bosss.foundation.quadrature.compositequadrule{`0})"></a>
**Summary:** Merges two quadrature rules into one. If for one quadrature item
'A' and 'B' both define quadrature
rules, it will always be the one from 'B' that ends
up in the result.
**Parameter:** `A` - The inferior quadrature rule (i.e., is dominated by
'B' in case of conflicts)
**Parameter:** `B` - The dominant quadrature rule
**Returns:**
A merged quadrature rule

## Class: BoSSS.Foundation.Quadrature.CoordinateSystem <a id="bosss.foundation.quadrature.coordinatesystem"></a>

**Summary:** The integration domain of some quadrature (see [BoSSS.Foundation.Quadrature.Quadrature`2](#bosss.foundation.quadrature.quadrature`2)).


### Field: BoSSS.Foundation.Quadrature.CoordinateSystem.Reference <a id="bosss.foundation.quadrature.coordinatesystem.reference"></a>
**Summary:** integration in the reference domain


### Field: BoSSS.Foundation.Quadrature.CoordinateSystem.Physical <a id="bosss.foundation.quadrature.coordinatesystem.physical"></a>
**Summary:** integration in the physical domain

## Class: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature <a id="bosss.foundation.quadrature.doubleedgequadrature"></a>

**Summary:** A variant of the edge quadrature that uses different 
quadrature nodes and weights on both sides of an edge (different quadrature for 'in'- and 'out'-cell).


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.#ctor(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule},BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.doubleedgequadrature.#ctor(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.doubleedgequadrule},bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** constructor, for a quadrature rule which is already compiled ('domNrule')
**Parameter:** `noOfIntegralsPerCell` - tensor dimension of the integrand
**Parameter:** `context` - 
**Parameter:** `domNrule` - quadrature rule and domain
**Parameter:** `cs` - Physical or reference coordinate system?


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.doubleedgequadrature.checkquadraturechunk(system.int32,system.int32,system.int32)"></a>
**Summary:** see [BoSSS.Foundation.Quadrature.Quadrature`2.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32)](#bosss.foundation.quadrature.quadrature`2.checkquadraturechunk(system.int32,system.int32,system.int32))


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.doubleedgequadrature.nextpart(system.boolean@,system.int32@,system.int32,system.int32)"></a>
**Summary:** see [BoSSS.Foundation.Quadrature.Quadrature`2.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32)](#bosss.foundation.quadrature.quadrature`2.nextpart(system.boolean@,system.int32@,system.int32,system.int32))


### Property: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.CurrentRuleRefElementIndex <a id="bosss.foundation.quadrature.doubleedgequadrature.currentrulerefelementindex"></a>
**Summary:** not implemented


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.DoQuadrature(BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.doubleedgequadrature.doquadrature(bosss.foundation.quadrature.doubleedgequadrule,system.int32,system.int32)"></a>
**Summary:** performs the quadrature


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.AllocateBuffers(System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.quadrature.doubleedgequadrature.allocatebuffers(system.int32,bosss.foundation.nodeset)"></a>
**Summary:** 2nd phase of quadrature: allocation of memory for 
the [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray))-method;
Called whenever the node set or the number of cells per evaluation is changed;
**Parameter:** `NoOfItems` - number of edges or cells to integrate
**Parameter:** `rule` - The quadrature rule applied to each item


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.Classic.GridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.doubleedgequadrature.getquadrature(system.int32[],bosss.foundation.grid.classic.griddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.doubleedgequadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.doubleedgequadrule,bosss.foundation.grid.edgemask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.doubleedgequadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** creates a double-edge quadrature, where integrand evaluation ('_Evaluate') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.CellQuadrature](#bosss.foundation.quadrature.cellquadrature).

## Class: BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule <a id="bosss.foundation.quadrature.doubleedgequadrule"></a>

**Summary:** Variant of [BoSSS.Foundation.Quadrature.QuadRule](#bosss.foundation.quadrature.quadrule) for edge integrals, 
where different nodes/weights can be used for both sides


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule.CreateBlank(BoSSS.Foundation.Grid.RefElements.RefElement,System.Int32,System.Int32,System.Boolean) <a id="bosss.foundation.quadrature.doubleedgequadrule.createblank(bosss.foundation.grid.refelements.refelement,system.int32,system.int32,system.boolean)"></a>
**Summary:** Creates a empty (i.e. all entries set to 0.0) quadrature rule for filling by the user.


### Field: BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule.Median <a id="bosss.foundation.quadrature.doubleedgequadrule.median"></a>
**Summary:** nodes/weights from index 0 to [BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule.Median](#bosss.foundation.quadrature.doubleedgequadrule.median)-1 regard the in-cell,
indices from [BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule.Median](#bosss.foundation.quadrature.doubleedgequadrule.median) to [BoSSS.Foundation.Quadrature.QuadRule.NoOfNodes](#bosss.foundation.quadrature.quadrule.noofnodes)-1 regard the out cell.


## Method: BoSSS.Foundation.Quadrature.DoubleEdgeQuadRule.Clone <a id="bosss.foundation.quadrature.doubleedgequadrule.clone"></a>
**Summary:** Creates a deep copy of this object
**Returns:**
A deep copy of this object

## Class: BoSSS.Foundation.Quadrature.EdgeIntegrationMetric <a id="bosss.foundation.quadrature.edgeintegrationmetric"></a>

**Summary:** integration metric for area integrals on edges


### Property: BoSSS.Foundation.Quadrature.EdgeIntegrationMetric.AlwaysUsePerNodeScaling <a id="bosss.foundation.quadrature.edgeintegrationmetric.alwaysusepernodescaling"></a>
**Summary:** For edges, the scaling is constant within the edge for linear elements, therefore always false;
c.f. [BoSSS.Foundation.Quadrature.IIntegrationMetric.AlwaysUsePerNodeScaling](#bosss.foundation.quadrature.iintegrationmetric.alwaysusepernodescaling);


## Method: BoSSS.Foundation.Quadrature.EdgeIntegrationMetric.GetScalingsForLinearElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.edgeintegrationmetric.getscalingsforlinearelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** the square root of the Gramian determinant


## Method: BoSSS.Foundation.Quadrature.EdgeIntegrationMetric.GetScalingsForNonlinElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.edgeintegrationmetric.getscalingsfornonlinelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** the transformation metric for nonlinear edges.

## Class: BoSSS.Foundation.Quadrature.EdgeQuadrature <a id="bosss.foundation.quadrature.edgequadrature"></a>

**Summary:** quadrature over edges.


## Method: BoSSS.Foundation.Quadrature.EdgeQuadrature.#ctor(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.edgequadrature.#ctor(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** constructor
**Parameter:** `noOfIntegralsPerCell` - 
**Parameter:** `context` - 
**Parameter:** `rule` - 
**Parameter:** `cs` - integrate in physical or reference coordinates?


## Method: BoSSS.Foundation.Quadrature.EdgeQuadrature.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.edgequadrature.nextpart(system.boolean@,system.int32@,system.int32,system.int32)"></a>
**Summary:** Sweeps whether edge 'i0' is linear/nonlinear and how many cells of the same type are going to come after it.


## Method: BoSSS.Foundation.Quadrature.EdgeQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.edgequadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** creates an edge quadrature, where integrand evaluation ('_Evaluate') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.EdgeQuadrature](#bosss.foundation.quadrature.edgequadrature).


## Method: BoSSS.Foundation.Quadrature.EdgeQuadrature.GetQuadrature2(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_EvaluateEx,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_AllocateBuffersEx,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_QuadNodesChanged,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_OnCloneForThreadParallelization,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.edgequadrature.getquadrature2(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_evaluateex,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_allocatebuffersex,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_quadnodeschanged,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_oncloneforthreadparallelization,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** creates an edge quadrature, where integrand evaluation AND quadrature (!!!) ('_EvaluateEx') and other methods
can be passed as delegates. Use this, if you do not want to derive from [BoSSS.Foundation.Quadrature.EdgeQuadrature](#bosss.foundation.quadrature.edgequadrature).


### Property: BoSSS.Foundation.Quadrature.EdgeQuadrature.CurrentRuleRefElementIndex <a id="bosss.foundation.quadrature.edgequadrature.currentrulerefelementindex"></a>
**Summary:** Index of the current rule's reference element into
[BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements](#bosss.foundation.grid.igeometricaledgedata.edgerefelements).


## Method: BoSSS.Foundation.Quadrature.EdgeQuadrature.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.edgequadrature.checkquadraturechunk(system.int32,system.int32,system.int32)"></a>
**Summary:** Some DEBUG checks on the current quadrature chunk.

## Class: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory"></a>

**Summary:** converts a cell boundary quadrature rule into an edge quadrature rule


## Method: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory.#ctor(BoSSS.Foundation.Grid.Classic.GridData,System.Boolean,BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.CellBoundaryQuadRule},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory.#ctor(bosss.foundation.grid.classic.griddata,system.boolean,bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.cellboundaryquadrule},bosss.foundation.grid.cellmask)"></a>
**Summary:** constructor


## Method: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory.GetCachedRuleOrders <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


## Method: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** produces an edge quadrature rule
**Parameter:** `mask` - an edge mask
**Parameter:** `order` - desired order
**Returns:**



### Property: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory.WeightInbalance <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory.weightinbalance"></a>
**Summary:** total difference between quadrature weights on both sides of an edge


### Property: BoSSS.Foundation.Quadrature.EdgeRuleFromCellBoundaryFactory.RefElement <a id="bosss.foundation.quadrature.edgerulefromcellboundaryfactory.refelement"></a>
**Summary:** the edge simplex

## Class: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1 <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1"></a>

**Summary:** used by the spatial operator (see [BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.GetArgMapping(BoSSS.Foundation.IDifferentialOperator,System.Boolean,System.Func{`0,System.Boolean},System.Func{BoSSS.Foundation.IEquationComponent,BoSSS.Foundation.IEquationComponent})](#bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.getargmapping(bosss.foundation.idifferentialoperator,system.boolean,system.func{`0,system.boolean},system.func{bosss.foundation.iequationcomponent,bosss.foundation.iequationcomponent})))
to give a collection of all equation components 
of a certain type ()


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.GetArgMapping(BoSSS.Foundation.IDifferentialOperator,System.Boolean,System.Func{`0,System.Boolean},System.Func{BoSSS.Foundation.IEquationComponent,BoSSS.Foundation.IEquationComponent}) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.getargmapping(bosss.foundation.idifferentialoperator,system.boolean,system.func{`0,system.boolean},system.func{bosss.foundation.iequationcomponent,bosss.foundation.iequationcomponent})"></a>
**Summary:** returns a collection of equation components of a certain type ()
**Parameter:** `CatParams` - if true, parameter variables (see [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering))
are concatenated with domain variable names (see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).
**Parameter:** `F` - optional filter;
should return true, if the component should be added, false if not;
**Parameter:** `vectorizer` - vectorizer option: translate some equation component to another one
**Parameter:** `op` - 


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.#ctor(BoSSS.Foundation.IDifferentialOperator,System.String,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Func{`0,System.Boolean},System.Func{BoSSS.Foundation.IEquationComponent,BoSSS.Foundation.IEquationComponent}) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.#ctor(bosss.foundation.idifferentialoperator,system.string,system.collections.generic.ilist{system.string},system.collections.generic.ilist{system.string},system.func{`0,system.boolean},system.func{bosss.foundation.iequationcomponent,bosss.foundation.iequationcomponent})"></a>
**Summary:** ctor
**Parameter:** `DiffOp` - 
**Parameter:** `CoDomVarName` - the name of the variable in the codomain ([BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar)-member
of 'DiffOp', for which this object should be defined;
**Parameter:** `_fieldList` - list of domain variable names
**Parameter:** `_fieldList2` - optional (i.e. can be null)
list of parameter variable names;
will be concatenated with '_fieldList'
**Parameter:** `F` - optional filter, can be null.
**Parameter:** `vectorizer` - Function for the vectorization of the evaluation of 'F'


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_AllComponentsOfMyType <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_allcomponentsofmytype"></a>


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_LockObjects <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_lockobjects"></a>
**Summary:** if non-null, a a lock-object for synchronization of flux evaluation
- index: correlates with [BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_AllComponentsOfMyType](#bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_allcomponentsofmytype)


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_CoDomVarName <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_codomvarname"></a>


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.MapArguments(ilPSP.MultidimensionalArray[],`0,System.Boolean) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.maparguments(ilpsp.multidimensionalarray[],`0,system.boolean)"></a>
**Summary:** reorders the values of the domain variables ('FieldValues')
to comply with the argument and paramter ordering of component 'comp'.


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.AllToSub <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.alltosub"></a>
**Summary:** content: the index of a DG - field (global field index within the integrator)

1st index: equation component index; the order of the equation
components correlates, resp. is induced by [BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_AllComponentsOfMyType](#bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_allcomponentsofmytype);

2nd index: a field index, where the order of the fields is defined by 
[BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering).
(equation-specific field index)


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.NoOfArguments <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.noofarguments"></a>
**Summary:** content: number of arguments for each equation component; 
([BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering).Count) 
index: equation component index; the order of the equation
components is defined by [BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_AllComponentsOfMyType](#bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_allcomponentsofmytype);


### Field: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.NoOfParameters <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.noofparameters"></a>
**Summary:** content: number of parameters for each equation component; 
([BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering).Count) 
index: equation component index; the order of the equation
components is defined by [BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping`1.m_AllComponentsOfMyType](#bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping`1.m_allcomponentsofmytype);

## Class: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping_Extensions <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping_extensions"></a>

**Summary:** Extensions


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping_Extensions.IsNonEmpty``1(BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping{``0}[]) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping_extensions.isnonempty``1(bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping{``0}[])"></a>
**Summary:** true, if any equation component is present in 'ecm'


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping_Extensions.DetermineReqFields``1(BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping{``0}[],System.Boolean[],System.Func{``0,System.Boolean}) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping_extensions.determinereqfields``1(bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping{``0}[],system.boolean[],system.func{``0,system.boolean})"></a>
**Summary:** Utility function to determine whether it is required to evaluate some DG field resp its gradient.


## Method: BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping_Extensions.InitStopWatches``1(BoSSS.Foundation.Quadrature.FluxQuadCommon.EquationComponentArgMapping{``0}[],System.Int32,BoSSS.Foundation.Quadrature.IQuadrature) <a id="bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping_extensions.initstopwatches``1(bosss.foundation.quadrature.fluxquadcommon.equationcomponentargmapping{``0}[],system.int32,bosss.foundation.quadrature.iquadrature)"></a>
**Summary:** Creating performance stopwatches and registering them among [BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers](#bosss.foundation.quadrature.iquadrature.customtimers) (and related).

## Class: BoSSS.Foundation.Quadrature.FixedRuleFactory`1 <a id="bosss.foundation.quadrature.fixedrulefactory`1"></a>

**Summary:** Helper class that wraps a given quadrature rule into a
[BoSSS.Foundation.Quadrature.IQuadRuleFactory`1](#bosss.foundation.quadrature.iquadrulefactory`1). Mainly exists to support
legacy code. New code should directly provide a quad rule factory.


## Method: BoSSS.Foundation.Quadrature.FixedRuleFactory`1.#ctor(`0) <a id="bosss.foundation.quadrature.fixedrulefactory`1.#ctor(`0)"></a>
**Summary:** Constructs the factory.


## Method: BoSSS.Foundation.Quadrature.FixedRuleFactory`1.GetCachedRuleOrders <a id="bosss.foundation.quadrature.fixedrulefactory`1.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


### Property: BoSSS.Foundation.Quadrature.FixedRuleFactory`1.RefElement <a id="bosss.foundation.quadrature.fixedrulefactory`1.refelement"></a>
**Summary:** Not implemented since it isn't required.


## Method: BoSSS.Foundation.Quadrature.FixedRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.fixedrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** Returns the quad rule supplied to the constructor for every
single chunk in 'mask'.
**Parameter:** `mask` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Parameter:** `order` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Returns:**
[BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))

## Class: BoSSS.Foundation.Quadrature.ICompositeQuadRule`1 <a id="bosss.foundation.quadrature.icompositequadrule`1"></a>

**Summary:** Implementations of this interface describe which quadrature rule should
be used at which quadrature item (cell or edge).


### Property: BoSSS.Foundation.Quadrature.ICompositeQuadRule`1.GridData <a id="bosss.foundation.quadrature.icompositequadrule`1.griddata"></a>
**Summary:** a composite quadrature rule is always associated with a grid/mesh


### Property: BoSSS.Foundation.Quadrature.ICompositeQuadRule`1.NumberOfItems <a id="bosss.foundation.quadrature.icompositequadrule`1.numberofitems"></a>
**Summary:** The number of quadrature items (cells or edges)


### Property: BoSSS.Foundation.Quadrature.ICompositeQuadRule`1.IntegrationMetric <a id="bosss.foundation.quadrature.icompositequadrule`1.integrationmetric"></a>
**Summary:** The quadrature scaling/integration metric

## Class: BoSSS.Foundation.Quadrature.IIntegrationMetric <a id="bosss.foundation.quadrature.iintegrationmetric"></a>

**Summary:** Quadrature rules ([BoSSS.Foundation.Quadrature.QuadRule](#bosss.foundation.quadrature.quadrule)) are defined in the reference coordinate system of cells or edges.
To obtain a quadrature rule in the physical domain, the integrand must be applied with an integration metric/scaling factor,
see also https://en.wikipedia.org/wiki/Integral_transform 

This interface is required e.g., because not all quadrature rules which are defined in cell coordinates
are necessarily also volume integrals, therefore the quadrature rule must provide its scaling factors
for the quadrature kernel ([BoSSS.Foundation.Quadrature.CellQuadrature](#bosss.foundation.quadrature.cellquadrature), [BoSSS.Foundation.Quadrature.EdgeQuadrature](#bosss.foundation.quadrature.edgequadrature), [BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1](#bosss.foundation.quadrature.cellboundaryquadrature`1)).
One example are integrals over embedded manifolds, e.g. level-set-surface integrals; Those are defined 
in cell coordinates, but require different scaling factors than volume integrals.


## Method: BoSSS.Foundation.Quadrature.IIntegrationMetric.GetScalingsForLinearElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.iintegrationmetric.getscalingsforlinearelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** Provides integration metric factors for linear edges or cells, i.e., 
where the transformation from the reference to the physical domain is linear, resp. affine-linear.
For such edges or cells, the metric factor is constant within a cell.
**Parameter:** `i0` - Index of first cell or edge for which to obtain the scaling factors.
**Parameter:** `L` - Number of cells or edges for which to obtain the scaling factors.
**Parameter:** `qr` - Quadrature rule in reference element for edges/cells 'i0' to 'i0'+'L'-1
**Parameter:** `gridData` - current grid
**Returns:**
Scaling factors for each cell or edge
- index: cell or edge index, from 0 (including) to 'L' (excluding)


### Property: BoSSS.Foundation.Quadrature.IIntegrationMetric.AlwaysUsePerNodeScaling <a id="bosss.foundation.quadrature.iintegrationmetric.alwaysusepernodescaling"></a>
**Summary:** If true, the integration metric is non-constant within a cell, therefore always the [BoSSS.Foundation.Quadrature.IIntegrationMetric.GetScalingsForNonlinElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32)](#bosss.foundation.quadrature.iintegrationmetric.getscalingsfornonlinelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)) method will be used.
This is the case e.g. for integrating over the level-set in XDG.


## Method: BoSSS.Foundation.Quadrature.IIntegrationMetric.GetScalingsForNonlinElements(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.QuadRule,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.iintegrationmetric.getscalingsfornonlinelements(bosss.foundation.grid.igriddata,bosss.foundation.quadrature.quadrule,system.int32,system.int32)"></a>
**Summary:** Provides integration metric factors for edges or cells, 
where the transformation from the reference to the physical domain is nonlinear (and also not affine-linear).
For such edges or cells, the metric factor might change for each node in rule 'qr'.
**Parameter:** `i0` - Index of first cell or edge for which to obtain the scaling factors.
**Parameter:** `L` - Number of cells or edges for which to obtain the scaling factors.
**Parameter:** `qr` - Quadrature rule in reference element for edges/cells 'i0' to 'i0'+'L'-1
**Parameter:** `gridData` - current grid
**Returns:**
Scaling factors for each node in each cell or edge
- 1st index: cell or edge index, from 0 (including) to 'L' (excluding)
- 2nd index: node index, from 0 (including) to number of nodes in quadrature rule (excluding)

## Class: BoSSS.Foundation.Quadrature.IQuadrature <a id="bosss.foundation.quadrature.iquadrature"></a>

**Summary:** common methods for all kinds of quadrature objects


## Method: BoSSS.Foundation.Quadrature.IQuadrature.Execute <a id="bosss.foundation.quadrature.iquadrature.execute"></a>
**Summary:** execute the quadrature


### Property: BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers <a id="bosss.foundation.quadrature.iquadrature.customtimers"></a>
**Summary:** Additional timers, which may be derived in derived classes, that are added to the performance analysis.


### Property: BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers_Names <a id="bosss.foundation.quadrature.iquadrature.customtimers_names"></a>
**Summary:** Names of the custom timers (see [BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers](#bosss.foundation.quadrature.iquadrature.customtimers)), for reference reasons in the log files.
Index correlates with [BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers](#bosss.foundation.quadrature.iquadrature.customtimers);


### Property: BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers_RootPointer <a id="bosss.foundation.quadrature.iquadrature.customtimers_rootpointer"></a>
**Summary:** If one wants to establish a call tree among the custom timers, one can use this.

## Class: BoSSS.Foundation.Quadrature.IQuadRuleFactory`1 <a id="bosss.foundation.quadrature.iquadrulefactory`1"></a>

**Summary:** Common interface for all providers of quadrature rules.

**Remark:**
The interface has been designed such that it is covariant in its type
parameter (hence the "out" keyword). As a result, assignments of the
type

IQuadRuleFactory<CellBndQuadRulegt; factory = someFactory;
IQuadRuleFactory<QuadRulegt variableUsingBasetype = factory;

are perfectly valid. To achieve this, the signature of
[BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32)) had to been changed to a type that is
also covariant in its type parameter (which is not true, for instance,
in case of **System.Collections.Generic.IDictionary`2**.


### Property: BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.RefElement <a id="bosss.foundation.quadrature.iquadrulefactory`1.refelement"></a>
**Summary:** The reference element to be integrated over.


## Method: BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** Creates the quadrature rules for all elements (i.e., cell or edges)
in 'mask'. The used quadrature rules have an order
of 'order'. The chunks used as keys of the
resulting dictionary are subsets of the chunks of
'mask'. Depending on the implementation, the
quadrature rule may or may not vary from cell to cell which implies
that the chunks may or may not be equal to the chunks of
'mask'.
**Parameter:** `mask` - Mask containing the elements for which the quadrature rules are
needed.
**Parameter:** `order` - The desired order of the integration rules.
**Returns:**
A mapping between chunks of elements and the integration rule
proposed by the specific implementation.


## Method: BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetCachedRuleOrders <a id="bosss.foundation.quadrature.iquadrulefactory`1.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.

## Class: BoSSS.Foundation.Quadrature.IChunkRulePair`1 <a id="bosss.foundation.quadrature.ichunkrulepair`1"></a>

**Summary:** A tuple consisting of a chunk (a subset of a domain of integration) and
an associated quadrature rule.

**Remark:**
Introduced since **System.Collections.Generic.KeyValuePair`2** is not covariant in
the type parameter T.


### Property: BoSSS.Foundation.Quadrature.IChunkRulePair`1.Chunk <a id="bosss.foundation.quadrature.ichunkrulepair`1.chunk"></a>
**Summary:** A chunk of integration elements.


### Property: BoSSS.Foundation.Quadrature.IChunkRulePair`1.Rule <a id="bosss.foundation.quadrature.ichunkrulepair`1.rule"></a>
**Summary:** A quadrature rule valid for all elements of .

## Class: BoSSS.Foundation.Quadrature.ChunkRulePair`1 <a id="bosss.foundation.quadrature.chunkrulepair`1"></a>

**Summary:** Represents an immutable tuple of a chunk and an associated quad rule.


## Method: BoSSS.Foundation.Quadrature.ChunkRulePair`1.#ctor(BoSSS.Foundation.Grid.Chunk,`0) <a id="bosss.foundation.quadrature.chunkrulepair`1.#ctor(bosss.foundation.grid.chunk,`0)"></a>
**Summary:** Just stores the given values


## Method: BoSSS.Foundation.Quadrature.ChunkRulePair`1.#ctor(BoSSS.Foundation.Quadrature.IChunkRulePair{`0}) <a id="bosss.foundation.quadrature.chunkrulepair`1.#ctor(bosss.foundation.quadrature.ichunkrulepair{`0})"></a>
**Summary:** Half-Shallow Clone


### Property: BoSSS.Foundation.Quadrature.ChunkRulePair`1.Chunk <a id="bosss.foundation.quadrature.chunkrulepair`1.chunk"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IChunkRulePair`1.Chunk](#bosss.foundation.quadrature.ichunkrulepair`1.chunk)


### Property: BoSSS.Foundation.Quadrature.ChunkRulePair`1.Rule <a id="bosss.foundation.quadrature.chunkrulepair`1.rule"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IChunkRulePair`1.Rule](#bosss.foundation.quadrature.ichunkrulepair`1.rule)

## Class: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2 <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2"></a>


### Property: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.GAMMA <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.gamma"></a>
**Summary:** number of codomain variables


### Property: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.DELTA <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.delta"></a>
**Summary:** number of domain variables

## Class: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals"></a>


### Property: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.IsNonEmpty <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.isnonempty"></a>
**Summary:** true, if this integrator is responsible for any component


### Property: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.LinearRequired <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.linearrequired"></a>
**Summary:** true, if integration of [BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_Matrix](#bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_matrix) is required.


### Property: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.AffineRequired <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.affinerequired"></a>
**Summary:** true, if integration of [BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_AffineVector](#bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_affinevector) is required.


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.GlobalNodes <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.globalnodes"></a>
**Summary:** Quadrature nodes in global coordinates
- 1st index: edge
- 2nd index: quadrature node
- 3rd index: spatial direction


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.NormalBuffer <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.normalbuffer"></a>
**Summary:** Guess what this is!


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.m_ParameterFieldsValues_IN <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.m_parameterfieldsvalues_in"></a>
**Summary:** result of parameter field evaluation, for the IN-cell
index: parameter field (correlates with [BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_ParameterFields](#bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_parameterfields)


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.ThreadLocals.m_ParameterFieldsValues_OUT <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.threadlocals.m_parameterfieldsvalues_out"></a>
**Summary:** result of parameter field evaluation, for the IN-cell
index: parameter field (correlates with [BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_ParameterFields](#bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_parameterfields)


## Method: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.Execute(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,`0,`1,System.Double) <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.execute(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,`0,`1,system.double)"></a>
**Summary:** Execution of quadrature
**Parameter:** `domNrule` - 
**Parameter:** `RowMap` - 
**Parameter:** `ParamsMap` - 
**Parameter:** `ColMap` - Domain variables resp. trial variables resp. matrix column variables
**Parameter:** `Matrix` - output: matrix components will be accumulated here
**Parameter:** `AffineVector` - output: affine components will be accumulated here
**Parameter:** `time` - 


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_ParameterFields <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_parameterfields"></a>
**Summary:** parameter fields


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_RowL <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_rowl"></a>
**Summary:** length of codomain basis per cell


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_TestFunctions <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_testfunctions"></a>


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_ColL <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_coll"></a>
**Summary:** length of domain basis per cell


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_TrialFunctions <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_trialfunctions"></a>


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_Matrix <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_matrix"></a>
**Summary:** Matrix where the result is saved


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_AffineVector <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_affinevector"></a>
**Summary:** Affine vector where the result is saved


### Field: BoSSS.Foundation.Quadrature.Linear.LECEdgeQuadrature2`2.m_alpha <a id="bosss.foundation.quadrature.linear.lecedgequadrature2`2.m_alpha"></a>
**Summary:** scaling factor for accumulation

## Class: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2 <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2"></a>


### Property: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.GAMMA <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.gamma"></a>
**Summary:** number of codomain variables


### Property: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.DELTA <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.delta"></a>
**Summary:** number of domain variables


## Method: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.Execute(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,`0,`1,System.Double) <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.execute(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,`0,`1,system.double)"></a>
**Summary:** Performs the integration of edge components.
**Parameter:** `domNrule` - 
**Parameter:** `RowMap` - 
**Parameter:** `ParamsMap` - 
**Parameter:** `ColMap` - Domain variables resp. trial variables resp. matrix column variables
**Parameter:** `Matrix` - output accumulator: matrix where the linear part of the operator is stored.
**Parameter:** `Vector` - output accumulator: vector where the affine part of the operator is stored.
**Parameter:** `time` - 


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_ParameterFields <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_parameterfields"></a>
**Summary:** parameter fields


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_RowL <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_rowl"></a>
**Summary:** length of codomain basis per cell


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Vfunctions <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_vfunctions"></a>


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_ColL <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_coll"></a>
**Summary:** length of domain basis per cell


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Ufunctions <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_ufunctions"></a>


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Matrix <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_matrix"></a>
**Summary:** Matrix where the linear part of the operator is saved.


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Vector <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_vector"></a>
**Summary:** Vector where the affine part of the operator is saved.

## Class: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals"></a>


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeSource_GradV <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumesource_gradv"></a>
**Summary:** index: test function/codomain variable


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeSource_V <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumesource_v"></a>
**Summary:** index: test function/codomain variable


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeForm_GradUxGradV <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumeform_graduxgradv"></a>
**Summary:** index: test function/codomain variable


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeForm_GradUxV <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumeform_graduxv"></a>
**Summary:** index: test function/codomain variable


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeForm_UxGradV <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumeform_uxgradv"></a>
**Summary:** index: test function/codomain variable


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.m_VolumeForm_UxV <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.m_volumeform_uxv"></a>
**Summary:** index: test function/codomain variable


### Property: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.AffineRequired <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.affinerequired"></a>
**Summary:** true, if integration of [BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Vector](#bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_vector) is required.


### Property: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.LinearRequired <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.linearrequired"></a>
**Summary:** true, if integration of [BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_Matrix](#bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_matrix) is required.


### Property: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.ThreadLocals.IsNonEmpty <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.threadlocals.isnonempty"></a>
**Summary:** true, if this integrator is responsible for any component


### Field: BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature2`2.m_alpha <a id="bosss.foundation.quadrature.linear.lecvolumequadrature2`2.m_alpha"></a>
**Summary:** scaling factor for accumulation

## Class: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer"></a>


## Method: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.ToString <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.tostring"></a>
**Summary:** Returns name of nested form.


## Method: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.GetCoeff(System.Double@,System.Double@,BoSSS.Foundation.CommonParamsVol@) <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.getcoeff(system.double@,system.double@,bosss.foundation.commonparamsvol@)"></a>
**Summary:** tests for components which are bilinear in u and v


## Method: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.GetCoeff(System.Double@,BoSSS.Foundation.CommonParamsVol@) <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.getcoeff(system.double@,bosss.foundation.commonparamsvol@)"></a>
**Summary:** tests for components which are linear in v and independent of u


### Property: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.ArgumentOrdering <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.argumentordering"></a>
**Summary:** ordering of argument variables


### Property: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.ParameterOrdering <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.parameterordering"></a>
**Summary:** ordering of parameter variables


## Method: BoSSS.Foundation.Quadrature.Linear.LinearVolumeFormVectorizer.BoSSS#Foundation#IVolumeForm_GradUxGradV#Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearvolumeformvectorizer.bosss#foundation#ivolumeform_graduxgradv#form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IVolumeForm_GradUxGradV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.ivolumeform_graduxgradv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray))

## Class: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer"></a>


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.ToString <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.tostring"></a>
**Summary:** Returns name of nested form.


### Property: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.ArgumentOrdering <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.argumentordering"></a>
**Summary:** ordering of argument variables


### Property: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.ParameterOrdering <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.parameterordering"></a>
**Summary:** ordering of parameter variables


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IInnerEdgeform_GradUxV#InternalEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iinneredgeform_graduxv#internaledge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IInnerEdgeform_GradUxV.InternalEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iinneredgeform_graduxv.internaledge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IBoundaryEdgeform_GradUxV#BoundaryEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iboundaryedgeform_graduxv#boundaryedge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IBoundaryEdgeform_GradUxV.BoundaryEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iboundaryedgeform_graduxv.boundaryedge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IInnerEdgeform_UxGradV#InternalEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iinneredgeform_uxgradv#internaledge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IInnerEdgeform_UxGradV.InternalEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iinneredgeform_uxgradv.internaledge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IBoundaryEdgeform_UxGradV#BoundaryEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iboundaryedgeform_uxgradv#boundaryedge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IBoundaryEdgeform_UxGradV.BoundaryEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iboundaryedgeform_uxgradv.boundaryedge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IInnerEdgeSource_V#InternalEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iinneredgesource_v#internaledge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IInnerEdgeSource_V.InternalEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iinneredgesource_v.internaledge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IBoundaryEdgeSource_V#BoundaryEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iboundaryedgesource_v#boundaryedge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IBoundaryEdgeSource_V.BoundaryEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iboundaryedgesource_v.boundaryedge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IInnerEdgeSource_GradV#InternalEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iinneredgesource_gradv#internaledge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IInnerEdgeSource_GradV.InternalEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iinneredgesource_gradv.internaledge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IBoundaryEdgeSource_GradV#BoundaryEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iboundaryedgesource_gradv#boundaryedge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IBoundaryEdgeSource_GradV.BoundaryEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iboundaryedgesource_gradv.boundaryedge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IInnerEdgeform_UxV#InternalEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iinneredgeform_uxv#internaledge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IInnerEdgeform_UxV.InternalEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iinneredgeform_uxv.internaledge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.Quadrature.Linear.LinearEdgeFormVectorizer.BoSSS#Foundation#IBoundaryEdgeform_UxV#BoundaryEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.linear.linearedgeformvectorizer.bosss#foundation#iboundaryedgeform_uxv#boundaryedge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.IBoundaryEdgeform_UxV.BoundaryEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray)](#bosss.foundation.iboundaryedgeform_uxv.boundaryedge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray))

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon"></a>

**Summary:** Common implementations for edge- and volume-quadrature of 
'N'onlinear 'E'quation 'C'omponents;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Operator <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.operator"></a>
**Summary:** the differential operator


### Property: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.GridDat <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.griddat"></a>
**Summary:** the gird on which this quadrature object operates on.


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.DifferentialOperator,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.differentialoperator,system.collections.generic.ienumerable{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** ctor.
**Parameter:** `context` - the context which Bjoern loves so much
**Parameter:** `DiffOp` - the spatial operator
**Parameter:** `_DomainFields` - the mapping for the DG fields (variables) in the domain of the differential operator 'DiffOp';
**Parameter:** `CodomainMapping` - the mapping for the DG fields (variables) in the codomain of the differential operator 'DiffOp';
**Parameter:** `ParamFields` - the mapping for the DG fields (variables) in the parameter list of the differential operator 'DiffOp';

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals"></a>


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals.m_NonlinFluxes <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals.m_nonlinfluxes"></a>
**Summary:** array index: equation index


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals.m_NonlinFluxesEx <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals.m_nonlinfluxesex"></a>
**Summary:** array index: equation index


### Property: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals.IsNonEmpty <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals.isnonempty"></a>
**Summary:** true, if this integrator is responsible for any component


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals.m_NonlinFluxesWatches <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals.m_nonlinfluxeswatches"></a>
**Summary:** array index: equation index


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.ThreadLocals.m_NonlinFluxesExWatches <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.threadlocals.m_nonlinfluxesexwatches"></a>
**Summary:** array index: equation index


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_Time <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_time"></a>
**Summary:** [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Time](#bosss.foundation.quadrature.nonlin.necquadraturecommon.time)


### Property: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Time <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.time"></a>
**Summary:** time value passed to flux functions


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_MyMap <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_mymap"></a>
**Summary:** Index offset for each codomain variable


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_CodomainMapping <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_codomainmapping"></a>
**Summary:** DG coordinate mapping for the codomain (output) of this
quadrature object;
index mapping for [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_Output](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_output);


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_CodomainBasisS <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_codomainbasiss"></a>
**Summary:** The basis of the codomain variables - these are used as test functions;
equal to the [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)-member
of [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_CodomainMapping](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_codomainmapping);


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields"></a>
**Summary:** domain fields AND parameters (for the evaluation, there is no real difference between a domain field and a parameter),
i.e., correlates with the concatenation of [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar) and [BoSSS.Foundation.IDifferentialOperator.ParameterVar](#bosss.foundation.idifferentialoperator.parametervar)


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainFields <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainfields"></a>
**Summary:** domain fields AND parameters (for the evaluation, there is no real difference between a domain field and a parameter),
i.e., correlates with the concatenation of [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar)


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_NoOfTestFunctions <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_nooftestfunctions"></a>
**Summary:** Number of test functions;
The test functions are the basis functions of the fields in the codomain;
corresponds with [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_CodomainBasisS](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_codomainbasiss);


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_Output <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_output"></a>
**Summary:** output array for the results of the integration;
indices into it should be computed with [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_CodomainMapping](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_codomainmapping);
The results of the integration/quadrature are multiplied by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_alpha](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_alpha)
and accumulated here;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_alpha <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_alpha"></a>
**Summary:** Scaling for the result of the integration, see [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_Output](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_output);


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_Quad <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.m_quad"></a>
**Summary:** The performer of the quadrature.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.IsNonEmpty <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.isnonempty"></a>
**Summary:** to be set by ctor of derivative class


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Execute <a id="bosss.foundation.quadrature.nonlin.necquadraturecommon.execute"></a>
**Summary:** executes the quadrature

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge <a id="bosss.foundation.quadrature.nonlin.necquadratureedge"></a>

**Summary:** edge quadrature of nonlinear equation components


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.SubGridCellsMarker <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.subgridcellsmarker"></a>
**Summary:** In subgrid mode, i.e. with restricted evaluation, this denotes
which cells are within the subgrid, usually acquired by 
[BoSSS.Foundation.Grid.CellMask.GetBitMaskWithExternal](#bosss.foundation.grid.cellmask.getbitmaskwithexternal)


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.SubGridBoundaryTreatment <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.subgridboundarytreatment"></a>
**Summary:** See [BoSSS.Foundation.SubGridBoundaryModes](#bosss.foundation.subgridboundarymodes)


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.DifferentialOperator,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.differentialoperator,system.collections.generic.ienumerable{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** ctor.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.VectorComponentIndices <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.vectorcomponentindices"></a>
**Summary:** - Describes which tuples of the domain and parameter variables form vector fields
- Required mainly for non-parallel periodic edges;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.m_ValueRequired <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.m_valuerequired"></a>
**Summary:** true, if the evaluation of the a domain variable is required. 
index: correlates with domain variables


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.m_MeanValueRequired <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.m_meanvaluerequired"></a>
**Summary:** true, if the evaluation of the a domain variable mean value is required. 
index: correlates with domain variables


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.m_GradientRequired <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.m_gradientrequired"></a>
**Summary:** true, if the evaluation of the gradient of a domain variable is required. 
index: correlates with domain variables

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg"></a>


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_EdgeForm_GradV <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_edgeform_gradv"></a>
**Summary:** array index: codomain variable


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_EdgeForm_V <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_edgeform_v"></a>
**Summary:** array index: codomain variable


### Property: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.IsNonEmpty <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.isnonempty"></a>
**Summary:** true, if this integrator is responsible for any component


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FieldValuesIN <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fieldvaluesin"></a>
**Summary:** storage for field values at quadrature nodes in the first (in) cell which bounds to the edge;
**Remark:**
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields);

For each **ilPSP.MultidimensionalArray**:

1st index: local edge index, with some offset;
2nd index: node index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FieldValuesOT <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fieldvaluesot"></a>
**Summary:** storage for field values at quadrature nodes in the second (out) cell which bounds to the edge;
**Remark:**
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields);

For each **ilPSP.MultidimensionalArray**:

1st index: local edge index, with some offset;
2nd index: node index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FieldGradientIN <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fieldgradientin"></a>
**Summary:** storage for field gradients at quadrature nodes in the first (in) cell which bounds to the edge;
**Remark:**
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields);

For each **ilPSP.MultidimensionalArray**:

1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial direction of derivative


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FieldGradientOT <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fieldgradientot"></a>
**Summary:** storage for field gradients at quadrature nodes in the second (out) cell which bounds to the edge;
**Remark:**
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields);

For each **ilPSP.MultidimensionalArray**:

1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial direction of derivative


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_MeanFieldValuesIN <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_meanfieldvaluesin"></a>
**Summary:** storage for mean field values at quadrature nodes in the second cell which bounds to the edge;
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields)
if one array entry is null, no mean value evaluation of the corresponding field is needed,
because ther is no [BoSSS.Foundation.INonlinearFluxEx](#bosss.foundation.inonlinearfluxex)-object which requires it.
1st index: local edge index, with some offset;
of course, the mean value is equal on all quadrature nodes on an edge, so there is no index 
for the quadrature node;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_MeanFieldValuesOT <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_meanfieldvaluesot"></a>
**Summary:** storage for mean field values at quadrature nodes in the second cell which bounds to the edge;
array index: field index, where field order is defined by [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields)
if one array entry is null, no mean value evaluation of the corresponding field is needed,
because there is no [BoSSS.Foundation.INonlinearFluxEx](#bosss.foundation.inonlinearfluxex)-object which requires it.
1st index: local edge index, with some offset;
of course, the mean value is equal on all quadrature nodes on an edge, so there is no index 
for the quadrature node;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FluxValuesIN <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fluxvaluesin"></a>
**Summary:** values of Riemann fluxes at quadrature nodes, for the IN-cell (in order to support arbitrary forms, IN and OUT flux may differ)
**Remark:**
Array index: codomain variable index: (see 
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar),
[BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Operator](#bosss.foundation.quadrature.nonlin.necquadraturecommon.operator));

For each **ilPSP.MultidimensionalArray**:

1st index/array index: codomain variable index
2nd index: local edge index, with some offset;
3rd index: node index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_FluxValuesOT <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_fluxvaluesot"></a>
**Summary:** values of Riemann fluxes at quadrature nodes, for the IN-cell (in order to support arbitrary forms, IN and OUT flux may differ)
**Remark:**
Array index: codomain variable index: (see 
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar),
[BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Operator](#bosss.foundation.quadrature.nonlin.necquadraturecommon.operator));

For each **ilPSP.MultidimensionalArray**:

1st index/array index: codomain variable index
2nd index: local edge index, with some offset;
3rd index: node index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_GradientFluxValuesIN <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_gradientfluxvaluesin"></a>
**Summary:** values of 'Gradient fluxes' at quadrature nodes, for the IN-cell (in order to support arbitrary forms, IN and OUT flux may differ)
**Remark:**
Array index: codomain variable index: (see 
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar),
[BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Operator](#bosss.foundation.quadrature.nonlin.necquadraturecommon.operator));

For each **ilPSP.MultidimensionalArray**:

1st index/array index: codomain variable index
2nd index: local edge index, with some offset;
3rd index: node index;
4th index: spatial direction;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.m_GradientFluxValuesOT <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.m_gradientfluxvaluesot"></a>
**Summary:** values of 'Gradient fluxes' at quadrature nodes, for the IN-cell (in order to support arbitary forms, IN and OUT flux may differ)
**Remark:**
Array index: codomain variable index: (see 
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar),
[BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.Operator](#bosss.foundation.quadrature.nonlin.necquadraturecommon.operator));

For each **ilPSP.MultidimensionalArray**:

1st index/array index: codomain variable index
2nd index: local edge index, with some offset;
3rd index: node index;
4th index: spatial direction;


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.ThreadLocalsEdg.EvaluateEx(System.Int32,System.Int32,BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Quadrature.IIntegrationMetric,ilPSP.MultidimensionalArray,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.threadlocalsedg.evaluateex(system.int32,system.int32,bosss.foundation.quadrature.quadrule,bosss.foundation.quadrature.iintegrationmetric,ilpsp.multidimensionalarray,system.int32,system.int32)"></a>
**Summary:** Integrand evaluation.


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.SaveIntegrationResults(System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.saveintegrationresults(system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Stores the result of the quadrature.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge._PeriodicVectorTrafo <a id="bosss.foundation.quadrature.nonlin.necquadratureedge._periodicvectortrafo"></a>
**Summary:** [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.PeriodicVectorTrafo](#bosss.foundation.quadrature.nonlin.necquadratureedge.periodicvectortrafo)

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.PeriodicVectorTrafo <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.periodicvectortrafo"></a>

**Summary:** Feature to support non-parallel periodic boundaries, e.g. cake-pies of rotational symmetrical domains.
These must be integrated in two passes, one for the IN and one for the OUT-cell of the respective periodic edges.
In both passes, a different (inverse) transformation is applied onto vector and normal fields.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.PeriodicVectorTrafo.nix <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.periodicvectortrafo.nix"></a>
**Summary:** Periodic vector transform turned off.
Can also be used for parallel periodic boundaries which do **not** require vector transformations.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.PeriodicVectorTrafo.fwd <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.periodicvectortrafo.fwd"></a>
**Summary:** writes to the OUT-cell, no contribution to IN-cell


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge.PeriodicVectorTrafo.bck <a id="bosss.foundation.quadrature.nonlin.necquadratureedge.periodicvectortrafo.bck"></a>
**Summary:** writes to the IN-cell, no contribution to OUT-cell

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume"></a>

**Summary:** edge quadrature of nonlinear equation components


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.DifferentialOperator,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.differentialoperator,system.collections.generic.ienumerable{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** ctor.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.m_MaxCodBasis_Gradient <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.m_maxcodbasis_gradient"></a>
**Summary:** Maximal codomain/testfunction basis for which the gradient values are required.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.m_MaxCodBasis <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.m_maxcodbasis"></a>
**Summary:** Maximal codomain/testfunction basis for which the values are required.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.m_ValueRequired <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.m_valuerequired"></a>
**Summary:** true, if the evaluation of the a domain variable is required. 
index: correlates with domain variables


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.m_GradientRequired <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.m_gradientrequired"></a>
**Summary:** true, if the evaluation of the gradient of a domain variable is required. 
index: correlates with domain variables

## Class: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol"></a>


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_NonlinSources <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_nonlinsources"></a>
**Summary:** array index: equation index/codomain variable index


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_NonlinFormV <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_nonlinformv"></a>
**Summary:** array index: equation index/codomain variable index


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_NonlinFormGradV <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_nonlinformgradv"></a>
**Summary:** array index: equation index/codomain variable index


### Property: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.IsNonEmpty <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.isnonempty"></a>
**Summary:** true, if this integrator is responsible for any component


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_FieldValues <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_fieldvalues"></a>
**Summary:** values of fields in the domain (of the operator);
**Remark:**
index: corresponds with [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields)


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_FieldGradients <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_fieldgradients"></a>
**Summary:** values of fields in the domain (of the operator);
**Remark:**
index: corresponds with [BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.m_DomainAndParamFields](#bosss.foundation.quadrature.nonlin.necquadraturecommon.m_domainandparamfields)


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_FluxValues <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_fluxvalues"></a>
**Summary:** values of Riemann flux functions
**Remark:**
index: codomain variable index;
for each entry:

1st index: local cell index, with some offset;
2nd index: node index;
3rd index: spatial dimension index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_FluxValuesTrf <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_fluxvaluestrf"></a>
**Summary:** values of Riemann flux functions, transformed to reference coordinate system.
**Remark:**
index: codomain variable index;
for each entry:

1st index: local cell index, with some offset;
2nd index: node index;
3rd index: spatial dimension index;


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_SourceValues <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_sourcevalues"></a>
**Summary:** index: equation;
an entry is null, if the corresponding equation contains no sources 
([BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_NonlinSources](#bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_nonlinsources));
for each entry:
1st index: local edge index, with some offset;
2nd index: node index;


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.EvaluateEx(System.Int32,System.Int32,BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Quadrature.IIntegrationMetric,ilPSP.MultidimensionalArray,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.evaluateex(system.int32,system.int32,bosss.foundation.quadrature.quadrule,bosss.foundation.quadrature.iintegrationmetric,ilpsp.multidimensionalarray,system.int32,system.int32)"></a>


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_TestFuncWeighted <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_testfuncweighted"></a>
**Summary:** Buffer to store values of test functions multiplied by quadrature weights.


### Field: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.ThreadLocalsVol.m_TestFuncGradWeighted <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.threadlocalsvol.m_testfuncgradweighted"></a>
**Summary:** Buffer to store values of test function gradients multiplied by quadrature weights.


## Method: BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume.SaveIntegrationResults(System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.nonlin.necquadraturevolume.saveintegrationresults(system.int32,system.int32,ilpsp.multidimensionalarray)"></a>

## Class: BoSSS.Foundation.Quadrature.NonLin.NonlinVolumeFormVectorizer <a id="bosss.foundation.quadrature.nonlin.nonlinvolumeformvectorizer"></a>


## Method: BoSSS.Foundation.Quadrature.NonLin.NonlinVolumeFormVectorizer.ToString <a id="bosss.foundation.quadrature.nonlin.nonlinvolumeformvectorizer.tostring"></a>
**Summary:** Returns name of nested form.


### Property: BoSSS.Foundation.Quadrature.NonLin.NonlinVolumeFormVectorizer.ArgumentOrdering <a id="bosss.foundation.quadrature.nonlin.nonlinvolumeformvectorizer.argumentordering"></a>
**Summary:** ordering of argument variables


### Property: BoSSS.Foundation.Quadrature.NonLin.NonlinVolumeFormVectorizer.ParameterOrdering <a id="bosss.foundation.quadrature.nonlin.nonlinvolumeformvectorizer.parameterordering"></a>
**Summary:** ordering of parameter variables

## Class: BoSSS.Foundation.Quadrature.NonLin.NonlinEdgeFormVectorizer <a id="bosss.foundation.quadrature.nonlin.nonlinedgeformvectorizer"></a>


## Method: BoSSS.Foundation.Quadrature.NonLin.NonlinEdgeFormVectorizer.ToString <a id="bosss.foundation.quadrature.nonlin.nonlinedgeformvectorizer.tostring"></a>
**Summary:** Returns name of nested form.

## Class: BoSSS.Foundation.Quadrature.PeriodicBoundaryUtils <a id="bosss.foundation.quadrature.periodicboundaryutils"></a>

**Summary:** (Mainly internal) Utility routines for the integration on periodic boundaries


## Method: BoSSS.Foundation.Quadrature.PeriodicBoundaryUtils.GetVectorFieldIndices(System.Collections.Generic.IEnumerable{System.String},System.Int32) <a id="bosss.foundation.quadrature.periodicboundaryutils.getvectorfieldindices(system.collections.generic.ienumerable{system.string},system.int32)"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.VectorFieldIndices](#bosss.foundation.idifferentialoperator.vectorfieldindices)

## Class: BoSSS.Foundation.Quadrature.Quadrature_Settings <a id="bosss.foundation.quadrature.quadrature_settings"></a>

**Summary:** tuning parameters for the quadrature


### Field: BoSSS.Foundation.Quadrature.Quadrature_Settings.CHUNK_LIMIT <a id="bosss.foundation.quadrature.quadrature_settings.chunk_limit"></a>
**Summary:** Number of cells or edges done at maximum in a singe quadrature chunk


### Field: BoSSS.Foundation.Quadrature.Quadrature_Settings.ENABLE_MULTITHREAD_CHECKING <a id="bosss.foundation.quadrature.quadrature_settings.enable_multithread_checking"></a>
**Summary:** if enabled, 
the results from multi-threaded quadrature are compared against single-threaded quadrature execution.


### Field: BoSSS.Foundation.Quadrature.Quadrature_Settings.MULTITHREAD_CHECKING_ABS_THRESHOLD <a id="bosss.foundation.quadrature.quadrature_settings.multithread_checking_abs_threshold"></a>


### Field: BoSSS.Foundation.Quadrature.Quadrature_Settings.MULTITHREAD_CHECKING_REL_THRESHOLD <a id="bosss.foundation.quadrature.quadrature_settings.multithread_checking_rel_threshold"></a>
**Summary:** relative comparison threshold

## Class: BoSSS.Foundation.Quadrature.Quadrature`2 <a id="bosss.foundation.quadrature.quadrature`2"></a>

**Summary:** baseclass for vectorized quadrature


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.CloneForThreadParallelization(System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.cloneforthreadparallelization(system.int32,system.int32)"></a>
**Summary:** In order to support multi-thread parallelization, this methods must provide clones with separate thread-local memory,
see e.g., [BoSSS.Foundation.Quadrature.Quadrature`2.AllocateBuffers(System.Int32,BoSSS.Foundation.NodeSet)](#bosss.foundation.quadrature.quadrature`2.allocatebuffers(system.int32,bosss.foundation.nodeset))
**Returns:**



### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_OnCloneForThreadParallelization <a id="bosss.foundation.quadrature.quadrature`2.m_oncloneforthreadparallelization"></a>
**Summary:** called on some object after [BoSSS.Foundation.Quadrature.Quadrature`2.CloneForThreadParallelization(System.Int32,System.Int32)](#bosss.foundation.quadrature.quadrature`2.cloneforthreadparallelization(system.int32,system.int32)) to initialize thread-locals


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.ExecuteParallel <a id="bosss.foundation.quadrature.quadrature`2.executeparallel"></a>
**Summary:** activate multi-thread-parallelization (quasi OpenMP)


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CoordinateSystem <a id="bosss.foundation.quadrature.quadrature`2.coordinatesystem"></a>
**Summary:** whether the integration should be performed in the reference or the physical coordinate system


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_TotalNoOfIntegralsPerItem <a id="bosss.foundation.quadrature.quadrature`2.m_totalnoofintegralsperitem"></a>
**Summary:** The total number of integrals per cell;


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_IntegralsComponent <a id="bosss.foundation.quadrature.quadrature`2.m_integralscomponent"></a>
**Summary:** see [BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim)


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim <a id="bosss.foundation.quadrature.quadrature`2.integralcompdim"></a>
**Summary:** Integrand dimension (the integrand can be a tensor, and this are its dimensions).


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CurrentRule <a id="bosss.foundation.quadrature.quadrature`2.currentrule"></a>
**Summary:** the quadrature rule used for the current evaluation, only 
available during the call to [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray))


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CurrentRuleRefElementIndex <a id="bosss.foundation.quadrature.quadrature`2.currentrulerefelementindex"></a>
**Summary:** For the currently used quadrature rule (see [BoSSS.Foundation.Quadrature.Quadrature`2.CurrentRule](#bosss.foundation.quadrature.quadrature`2.currentrule)),
the index of the reference element for which the rule is valid.


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.gridData <a id="bosss.foundation.quadrature.quadrature`2.griddata"></a>
**Summary:** The grid on which this quadrature object operates on.


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.GridDat <a id="bosss.foundation.quadrature.quadrature`2.griddat"></a>
**Summary:** The grid on which this quadrature object operates on.


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_EvalResults <a id="bosss.foundation.quadrature.quadrature`2.m_evalresults"></a>
**Summary:** results of evaluation
- 1st index: quadrature item (cell, edge)
- 2nd index: quadrature node 
- 3rd to ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length + 2)-th index: integral components


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_QuadResults <a id="bosss.foundation.quadrature.quadrature`2.m_quadresults"></a>
**Summary:** results of quadrature
- 1st index: quadrature item (cell, edge)
- 2nd to ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length + 1)-th index: integral components


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_QuadResultsCollapsed <a id="bosss.foundation.quadrature.quadrature`2.m_quadresultscollapsed"></a>
**Summary:** shallow copy of [BoSSS.Foundation.Quadrature.Quadrature`2.m_QuadResults](#bosss.foundation.quadrature.quadrature`2.m_quadresults), where the last ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length) 
indices/dimensions ale collapsed into one.


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_EvalResultsCollapsed <a id="bosss.foundation.quadrature.quadrature`2.m_evalresultscollapsed"></a>
**Summary:** shallow copy of [BoSSS.Foundation.Quadrature.Quadrature`2.m_EvalResults](#bosss.foundation.quadrature.quadrature`2.m_evalresults), where the last ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length) 
indices/dimensions ale collapsed into one.


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.IntegrationMetric <a id="bosss.foundation.quadrature.quadrature`2.integrationmetric"></a>
**Summary:** integration metric


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.#ctor(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.quadrature`2.#ctor(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** Standard constructor
**Parameter:** `noOfIntegralsPerCell` - The number of integrals to be computed
**Parameter:** `context` - see [BoSSS.Foundation.Quadrature.Quadrature`2.gridData](#bosss.foundation.quadrature.quadrature`2.griddata).
**Parameter:** `rule` - quadrature domain and rules.
**Parameter:** `cs` - integrate in physical or reference coordinates?


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.#ctor(System.Int32[],BoSSS.Foundation.Grid.Classic.GridData,BoSSS.Foundation.Quadrature.IQuadratureScheme{`0,`1},System.Int32,BoSSS.Foundation.Quadrature.CoordinateSystem) <a id="bosss.foundation.quadrature.quadrature`2.#ctor(system.int32[],bosss.foundation.grid.classic.griddata,bosss.foundation.quadrature.iquadraturescheme{`0,`1},system.int32,bosss.foundation.quadrature.coordinatesystem)"></a>
**Summary:** Alternative constructor that allows for the usage of a scheme
instead of a compiled quadrature rule.
**Parameter:** `noOfIntegralsPerCell` - 
**Parameter:** `context` - 
**Parameter:** `scheme` - 
**Parameter:** `order` - 
**Parameter:** `cs` - integrate in physical or reference coordinates?


### Field: BoSSS.Foundation.Quadrature.Quadrature`2.m_compositeRule <a id="bosss.foundation.quadrature.quadrature`2.m_compositerule"></a>
**Summary:** Quadrature domain (which cells/edges)
and quadrature rules.


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.AllocateBuffers(System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.quadrature.quadrature`2.allocatebuffers(system.int32,bosss.foundation.nodeset)"></a>
**Summary:** 2nd phase of quadrature: allocation of memory for 
the [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray))-method;
Called whenever the node set or the number of cells per evaluation is changed;
**Parameter:** `NoOfItems` - number of edges or cells to integrate
**Parameter:** `ruleNodes` - quadrature rule nodes


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.AllocateBuffersInternal(System.Int32,BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.allocatebuffersinternal(system.int32,bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** 2nd phase of quadrature: allocation of memory for 
the [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray))-method;
Called whenever the node set or the number of cells per evaluation is changed;
**Parameter:** `NoOfItems` - number of edges or cells to integrate
**Parameter:** `ruleNodes` - quadrature rule nodes
**Parameter:** `iThread` - should be used to allocate thread-local resources when multi-thread parallelization is used
**Parameter:** `NumThreads` - should be used to allocate thread-local resources when multi-thread parallelization is used


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.QuadNodesChanged(BoSSS.Foundation.NodeSet,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.quadnodeschanged(bosss.foundation.nodeset,system.int32,system.int32)"></a>
**Summary:** 1st Phase of quadrature: preparation of nodes;
This method will be called whenever a new 
node set family was locked, i.e. whenever the set of quadrature nodes is changed.


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray)"></a>
**Summary:** 3rd phase of quadrature: vectorized evaluation of the integrand.
Override this method to implement the integrand;
**Parameter:** `i0` - local index of first cell or edge
**Parameter:** `Length` - number of cells or edges to process
**Parameter:** `rule` - Quadrature nodes and weights in reference coordinates.
**Parameter:** `EvalResult` -
On exit, the result of the integrand evaluation.
Implementers can expect a cleared array, i.e. all entries are 0.0.
- 1st index: local cell or edge index minus 'i0';
- 2nd index: Node Index;
- 3rd to ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length + 2)-th index: integral component;


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.SaveIntegrationResults(System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.quadrature.quadrature`2.saveintegrationresults(system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** 4th (and final) phase of quadrature: save the results somewhere;
Override this method to write the results of the quadrature from temporary buffers
to wherever they belong
**Parameter:** `i0` - local index of first cell or edge
**Parameter:** `Length` - number of cells or edges to process
**Parameter:** `ResultsOfIntegration` -
1st index: local cell or edge index minus 'i0';
2nd to ([BoSSS.Foundation.Quadrature.Quadrature`2.IntegralCompDim](#bosss.foundation.quadrature.quadrature`2.integralcompdim).Length + 1)-th index:  integral component;


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CustomTimers <a id="bosss.foundation.quadrature.quadrature`2.customtimers"></a>
**Summary:** Additional timers, which may be derived in derived classes, that are added to the performance analysis.


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CustomTimers_Names <a id="bosss.foundation.quadrature.quadrature`2.customtimers_names"></a>
**Summary:** Names of the custom timers (see [BoSSS.Foundation.Quadrature.Quadrature`2.CustomTimers](#bosss.foundation.quadrature.quadrature`2.customtimers)), for reference reasons in the log files.
Index correlates with [BoSSS.Foundation.Quadrature.Quadrature`2.CustomTimers](#bosss.foundation.quadrature.quadrature`2.customtimers);


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.CustomTimers_RootPointer <a id="bosss.foundation.quadrature.quadrature`2.customtimers_rootpointer"></a>
**Summary:** If one wants to establish a call tree among the custom timers, one can use this.


### Property: BoSSS.Foundation.Quadrature.Quadrature`2.ChunkDataLimitOverride <a id="bosss.foundation.quadrature.quadrature`2.chunkdatalimitoverride"></a>
**Summary:** - if smaller or equal 0, ignored; (default) 
- otherwise, an override to the global variable [BoSSS.Foundation.Quadrature.Quadrature_Settings.CHUNK_LIMIT](#bosss.foundation.quadrature.quadrature_settings.chunk_limit)


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.Execute <a id="bosss.foundation.quadrature.quadrature`2.execute"></a>
**Summary:** performs an integration over cells or edges in the composite rule provided to the constructor;


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.SplitQuadRuleForMultithread(System.Int32,System.Int32@) <a id="bosss.foundation.quadrature.quadrature`2.splitquadruleformultithread(system.int32,system.int32@)"></a>
**Summary:** splits the composite quadrature rule [BoSSS.Foundation.Quadrature.Quadrature`2.m_compositeRule](#bosss.foundation.quadrature.quadrature`2.m_compositerule) int 'NumThreads' parts of approximately equal cost.
The cost of some quadrature in some cell is measured as number of nodes.


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.DoQuadrature(`0,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.doquadrature(`0,system.int32,system.int32)"></a>
**Summary:** performs the quadrature
**Parameter:** `quadRule` - 
**Parameter:** `j0` - 
**Parameter:** `_Bulksize` - number of quadrature items


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.CheckQuadratureChunk(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.checkquadraturechunk(system.int32,system.int32,system.int32)"></a>
**Summary:** various checks for the current quadrature check - only called in DEBUG mode;


## Method: BoSSS.Foundation.Quadrature.Quadrature`2.NextPart(System.Boolean@,System.Int32@,System.Int32,System.Int32) <a id="bosss.foundation.quadrature.quadrature`2.nextpart(system.boolean@,system.int32@,system.int32,system.int32)"></a>
**Summary:** identifies the chunk of elements (edges or cells), starting from 'i0'
which are all either linear or all non-linear.
**Parameter:** `Linear` - on exit, true for linear elements, otherwise false
**Parameter:** `NoOfElm` - on exit, the number of elements following 'i0' which are all either linear or all non-linear.
**Parameter:** `i0` - 
**Parameter:** `Len` - limit for the maximum chunk size, i.e. 'NoOfElm' will be bound by 'Len'.

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_Evaluate <a id="bosss.foundation.quadrature.quadrature`2.del_evaluate"></a>

**Summary:** see [BoSSS.Foundation.Quadrature.Quadrature`2.Evaluate(System.Int32,System.Int32,`0,ilPSP.MultidimensionalArray)](#bosss.foundation.quadrature.quadrature`2.evaluate(system.int32,system.int32,`0,ilpsp.multidimensionalarray)),

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_EvaluateEx <a id="bosss.foundation.quadrature.quadrature`2.del_evaluateex"></a>

**Summary:** evaluation of integrand, multiplication with quadrature weights, and summation, in **a multi-threaded environment**.

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_SaveIntegrationResults <a id="bosss.foundation.quadrature.quadrature`2.del_saveintegrationresults"></a>

**Summary:** used by [BoSSS.Foundation.Quadrature.CellQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellquadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)),
[BoSSS.Foundation.Quadrature.EdgeQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.edgequadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)) and
[BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellboundaryquadrature`1.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem))

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_AllocateBuffersEx <a id="bosss.foundation.quadrature.quadrature`2.del_allocatebuffersex"></a>

**Summary:** used by [BoSSS.Foundation.Quadrature.CellQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellquadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)),
[BoSSS.Foundation.Quadrature.EdgeQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.edgequadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)) and
[BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellboundaryquadrature`1.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem))

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_QuadNodesChanged <a id="bosss.foundation.quadrature.quadrature`2.del_quadnodeschanged"></a>

**Summary:** used by [BoSSS.Foundation.Quadrature.CellQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellquadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)),
[BoSSS.Foundation.Quadrature.EdgeQuadrature.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{BoSSS.Foundation.Quadrature.QuadRule,BoSSS.Foundation.Grid.EdgeMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.edgequadrature.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_evaluate,bosss.foundation.quadrature.quadrature{bosss.foundation.quadrature.quadrule,bosss.foundation.grid.edgemask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem)) and
[BoSSS.Foundation.Quadrature.CellBoundaryQuadrature`1.GetQuadrature(System.Int32[],BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.ICompositeQuadRule{`0},BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_Evaluate,BoSSS.Foundation.Quadrature.Quadrature{`0,BoSSS.Foundation.Grid.CellMask}.Del_SaveIntegrationResults,BoSSS.Foundation.Quadrature.CoordinateSystem)](#bosss.foundation.quadrature.cellboundaryquadrature`1.getquadrature(system.int32[],bosss.foundation.grid.igriddata,bosss.foundation.quadrature.icompositequadrule{`0},bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_evaluate,bosss.foundation.quadrature.quadrature{`0,bosss.foundation.grid.cellmask}.del_saveintegrationresults,bosss.foundation.quadrature.coordinatesystem))

## Class: BoSSS.Foundation.Quadrature.Quadrature`2.Del_OnCloneForThreadParallelization <a id="bosss.foundation.quadrature.quadrature`2.del_oncloneforthreadparallelization"></a>

**Summary:** might be used with multithread-parallelization to init thread-local variables, e.g. [BoSSS.Foundation.Quadrature.IQuadrature.CustomTimers](#bosss.foundation.quadrature.iquadrature.customtimers)

## Class: BoSSS.Foundation.Quadrature.IFactoryDomainPair`2 <a id="bosss.foundation.quadrature.ifactorydomainpair`2"></a>

**Summary:** A pairing of a quadrature rule factory and its assigned domain.


### Property: BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.RuleFactory <a id="bosss.foundation.quadrature.ifactorydomainpair`2.rulefactory"></a>
**Summary:** A factory for quadrature rules


### Property: BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.Domain <a id="bosss.foundation.quadrature.ifactorydomainpair`2.domain"></a>
**Summary:** The domain of integration


### Property: BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.Order <a id="bosss.foundation.quadrature.ifactorydomainpair`2.order"></a>
**Summary:** An optional order that overrides the order passed to
[BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.RuleFactory](#bosss.foundation.quadrature.ifactorydomainpair`2.rulefactory).

## Class: BoSSS.Foundation.Quadrature.IQuadratureScheme`2 <a id="bosss.foundation.quadrature.iquadraturescheme`2"></a>

**Summary:** Defines a mapping between quadrature rule factories (see
[BoSSS.Foundation.Quadrature.IQuadRuleFactory`1](#bosss.foundation.quadrature.iquadrulefactory`1)) and the domains in which they should
be used. The main purpose of implementations is to provide a measure to
represent different domains and their different requirements on
quadrature rules by a single object that can optimize the use of
resources (see [BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.iquadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32)))


### Property: BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Domain <a id="bosss.foundation.quadrature.iquadraturescheme`2.domain"></a>


### Property: BoSSS.Foundation.Quadrature.IQuadratureScheme`2.FactoryChain <a id="bosss.foundation.quadrature.iquadraturescheme`2.factorychain"></a>
**Summary:** Quadrature rule factories which should be applied. The higher
quadrature rules (those at higher indices) dominate, i.e. they
overwrite the lower ones.


## Method: BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.iquadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Compiles the chain of factories (see [BoSSS.Foundation.Quadrature.IQuadratureScheme`2.FactoryChain](#bosss.foundation.quadrature.iquadraturescheme`2.factorychain))
into a composite quadrature rules, i.e. a fixed mapping of chunks
and quadrature rules.
**Parameter:** `gridData` - Information about the grid.
**Parameter:** `order` - The minimum desired order of accuracy (if applicable)
**Returns:**
A quadrature

## Class: BoSSS.Foundation.Quadrature.QuadratureScheme`2 <a id="bosss.foundation.quadrature.quadraturescheme`2"></a>

**Summary:** Base class for all quadrature schemes. Inherit from this class in order
to fix a specific combination of the type of quadrature rule and the
type of the occurring domains.


### Field: BoSSS.Foundation.Quadrature.QuadratureScheme`2.factoryChain <a id="bosss.foundation.quadrature.quadraturescheme`2.factorychain"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadratureScheme`2.FactoryChain](#bosss.foundation.quadrature.iquadraturescheme`2.factorychain)


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,System.Boolean,`1) <a id="bosss.foundation.quadrature.quadraturescheme`2.#ctor(bosss.foundation.quadrature.iintegrationmetric,system.boolean,`1)"></a>
**Summary:** Creates a scheme with a given background domain.
**Parameter:** `domain` - Optional: A background domain (see
[BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Domain](#bosss.foundation.quadrature.iquadraturescheme`2.domain)). If null, the domain
created by [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultdomain(bosss.foundation.grid.igriddata)) will be used.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.
**Parameter:** `scaling` - 


### Field: BoSSS.Foundation.Quadrature.QuadratureScheme`2.IntegrationMetric <a id="bosss.foundation.quadrature.quadraturescheme`2.integrationmetric"></a>
**Summary:** Scaling/Integration metric which will be forwarded to the produced composite quadrature rules ([BoSSS.Foundation.Quadrature.ICompositeQuadRule`1.IntegrationMetric](#bosss.foundation.quadrature.icompositequadrule`1.integrationmetric))


### Property: BoSSS.Foundation.Quadrature.QuadratureScheme`2.Domain <a id="bosss.foundation.quadrature.quadraturescheme`2.domain"></a>
**Summary:** The background domain, see
[BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Domain](#bosss.foundation.quadrature.iquadraturescheme`2.domain)


### Property: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryChain <a id="bosss.foundation.quadrature.quadraturescheme`2.factorychain"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadratureScheme`2.FactoryChain](#bosss.foundation.quadrature.iquadraturescheme`2.factorychain)


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32}) <a id="bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32})"></a>
**Summary:** Allows to add factories to [BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryChain](#bosss.foundation.quadrature.quadraturescheme`2.factorychain). Factories
added later will dominate over the ones that have
been added earlier. That is, in case of conflicts (more than one
factory assigned to the same (sub-)domain), the one added later
will be chosen.
**Parameter:** `factory` - The factory to be added.
**Parameter:** `domain` - The domain on which 'factory' should act.
**Parameter:** `order` - An optional order that overrides the order passed to
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32)).
**Returns:**
This object (to allow for fluent addition of multiple factories).


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDomainForRefElement(BoSSS.Foundation.Grid.RefElements.RefElement,BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.quadrature.quadraturescheme`2.getdomainforrefelement(bosss.foundation.grid.refelements.refelement,bosss.foundation.grid.igriddata)"></a>
**Summary:** Constructs the [BoSSS.Foundation.Grid.ExecutionMask](#bosss.foundation.grid.executionmask) of the appropriate type
containing all cells/edges with reference element 'E'
**Parameter:** `E` - 
**Parameter:** `g` - 
**Returns:**



## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.iquadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.quadrature.quadraturescheme`2.getdefaultdomain(bosss.foundation.grid.igriddata)"></a>
**Summary:** Implement this method by returning a default domain, e.g. all cells
or edges of the grid.
**Parameter:** `gridData` - Information about the grid.
**Returns:**
A default domain of integration.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.quadraturescheme`2.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Implement this method by returning a default factory that should
be valid in the standard case (e.g., that returns Gauss rules for
the reference element 'elem')
**Parameter:** `gridData` - Information about the grid.
**Parameter:** `elem` - reference element
**Returns:**
A default quadrature rules factory.

## Class: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair <a id="bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair"></a>

**Summary:** Plain implementation of [BoSSS.Foundation.Quadrature.IFactoryDomainPair`2](#bosss.foundation.quadrature.ifactorydomainpair`2)


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.#ctor(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32}) <a id="bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.#ctor(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32})"></a>
**Summary:** Just stores the given values.
**Parameter:** `ruleFactory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.RuleFactory](#bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.rulefactory)
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.Domain](#bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.domain)
**Parameter:** `order` - The desired order of the quadrature rule. Note that this is
order not necessarily achieved by all
'ruleFactory's


### Property: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.RuleFactory <a id="bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.rulefactory"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.RuleFactory](#bosss.foundation.quadrature.ifactorydomainpair`2.rulefactory)


### Property: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.Domain <a id="bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.domain"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IFactoryDomainPair`2.Domain](#bosss.foundation.quadrature.ifactorydomainpair`2.domain)


### Property: BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.Order <a id="bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.order"></a>
**Summary:** An optional order that overrides the order passed to
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.FactoryDomainPair.RuleFactory](#bosss.foundation.quadrature.quadraturescheme`2.factorydomainpair.rulefactory).

## Class: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext <a id="bosss.foundation.quadrature.quadraturescheme_ext"></a>

**Summary:** Extension methods for [BoSSS.Foundation.Quadrature.IQuadratureScheme`2](#bosss.foundation.quadrature.iquadraturescheme`2) and various
classes which implement this interface.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.SaveToTextFileCell``2(BoSSS.Foundation.Quadrature.IQuadratureScheme{``0,``1},BoSSS.Foundation.Grid.IGridData,System.Int32,System.String) <a id="bosss.foundation.quadrature.quadraturescheme_ext.savetotextfilecell``2(bosss.foundation.quadrature.iquadraturescheme{``0,``1},bosss.foundation.grid.igriddata,system.int32,system.string)"></a>
**Summary:** Save Quadrule nodes in cell as .txt file


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.SaveToTextFileEdge``2(BoSSS.Foundation.Quadrature.IQuadratureScheme{``0,``1},BoSSS.Foundation.Grid.IGridData,System.Int32,System.String) <a id="bosss.foundation.quadrature.quadraturescheme_ext.savetotextfileedge``2(bosss.foundation.quadrature.iquadraturescheme{``0,``1},bosss.foundation.grid.igriddata,system.int32,system.string)"></a>
**Summary:** Save Quadrule nodes on edge as .txt file


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFactory``3(``0,BoSSS.Foundation.Quadrature.IQuadRuleFactory{``1},``2) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfactory``3(``0,bosss.foundation.quadrature.iquadrulefactory{``1},``2)"></a>
**Summary:** adds a factory to a quadrature scheme


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFactory``1(BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme,BoSSS.Foundation.Quadrature.IQuadRuleFactory{``0}) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfactory``1(bosss.foundation.quadrature.cellboundaryquadraturescheme,bosss.foundation.quadrature.iquadrulefactory{``0})"></a>
**Summary:** adds a factory to a cell-boundary quadrature scheme


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFactory``1(BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.Quadrature.IQuadRuleFactory{``0}) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfactory``1(bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.quadrature.iquadrulefactory{``0})"></a>
**Summary:** adds a factory to a cell quadrature scheme


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFactory``1(BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.IQuadRuleFactory{``0}) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfactory``1(bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.iquadrulefactory{``0})"></a>
**Summary:** adds a factory to an edge quadrature scheme


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFixedRule``3(``0,``1,``2) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfixedrule``3(``0,``1,``2)"></a>
**Summary:** adds a fixed rule to the quadrature scheme 'scheme';
this can be used to explicitly specify a quadrature rule, the choice of the order during the compilation of the scheme
(see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))) will have no effect.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFixedRuleS``3(``0,System.Collections.Generic.IEnumerable{``1},``2[]) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfixedrules``3(``0,system.collections.generic.ienumerable{``1},``2[])"></a>
**Summary:** adds multiple fixed rules to the quadrature scheme 'scheme';
this can be used to explicitly specify a quadrature rule, the choice of the order during the compilation of the scheme
(see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))) will have no effect.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFixedRuleS``1(BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.CellMask[]) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfixedrules``1(bosss.foundation.quadrature.cellquadraturescheme,system.collections.generic.ienumerable{``0},bosss.foundation.grid.cellmask[])"></a>
**Summary:** adds multiple fixed rules to the quadrature scheme 'scheme';
this can be used to explicitly specify a quadrature rule, the choice of the order during the compilation of the scheme
(see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))) will have no effect.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFixedOrderRules(BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfixedorderrules(bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** adds rules with fixed quadrature order to the quadrature scheme 'scheme';
this can be used to explicitly specify the quadrature order, the choice of the order during the compilation of the scheme
(see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))) will have no effect.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddFixedOrderRules(BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addfixedorderrules(bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** adds rules with fixed quadrature order to the quadrature scheme 'scheme';
this can be used to explicitly specify the quadrature order, the choice of the order during the compilation of the scheme
(see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32))) will have no effect.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddStandardRule``2(``0,BoSSS.Foundation.Grid.RefElements.RefElement,``1) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addstandardrule``2(``0,bosss.foundation.grid.refelements.refelement,``1)"></a>
**Summary:** adds a standard (Gaussian) quadrature rule to the quadrature scheme 'scheme';
the actual order of the quadrature rule will be determined by the order which is passed 
at the scheme compilation (see [BoSSS.Foundation.Quadrature.QuadratureScheme`2.Compile(BoSSS.Foundation.Grid.IGridData,System.Int32)](#bosss.foundation.quadrature.quadraturescheme`2.compile(bosss.foundation.grid.igriddata,system.int32)));


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddStandardRule(BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addstandardrule(bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** adds a standard(Gaussian) quadrature rule to the quadrature scheme 'scheme'.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.AddStandardRule(BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.quadraturescheme_ext.addstandardrule(bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** adds a standard(Gaussian) quadrature rule to the quadrature scheme 'scheme'.


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.SaveCompile(BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.quadraturescheme_ext.savecompile(bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Compilation of a cell volume scheme, even if it is null!


## Method: BoSSS.Foundation.Quadrature.QuadratureScheme_Ext.SaveCompile(BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Grid.IGridData,System.Int32) <a id="bosss.foundation.quadrature.quadraturescheme_ext.savecompile(bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.grid.igriddata,system.int32)"></a>
**Summary:** Compilation of an edge scheme, even if it is null!

## Class: BoSSS.Foundation.Quadrature.CellQuadratureScheme <a id="bosss.foundation.quadrature.cellquadraturescheme"></a>

**Summary:** Quadrature scheme for standard volume integration over cells.


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,System.Boolean,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellquadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,system.boolean,bosss.foundation.grid.cellmask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.
**Parameter:** `scaling` - if null, the default scaling for volume integration will be used.


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.#ctor(System.Boolean,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellquadraturescheme.#ctor(system.boolean,bosss.foundation.grid.cellmask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellquadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.cellmask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `scaling` - 


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellquadraturescheme.#ctor(bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.cellmask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.quadrature.cellquadraturescheme.getdefaultdomain(bosss.foundation.grid.igriddata)"></a>
**Summary:** [BoSSS.Foundation.Grid.CellMask.GetFullMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType)](#bosss.foundation.grid.cellmask.getfullmask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype))
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultdomain(bosss.foundation.grid.igriddata))
**Returns:**
A mask containing all cells of the grid.


## Method: BoSSS.Foundation.Quadrature.CellQuadratureScheme.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.cellquadraturescheme.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** [BoSSS.Foundation.Quadrature.StandardQuadRuleFactory](#bosss.foundation.quadrature.standardquadrulefactory)
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement))
**Parameter:** `elem` - reference element, must be one of [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)
**Returns:**
An instance of [BoSSS.Foundation.Quadrature.StandardQuadRuleFactory](#bosss.foundation.quadrature.standardquadrulefactory) for the volume
simplex.

## Class: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme <a id="bosss.foundation.quadrature.edgequadraturescheme"></a>

**Summary:** Quadrature scheme for standard integration over edges.


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,System.Boolean,BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.quadrature.edgequadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,system.boolean,bosss.foundation.grid.edgemask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.
**Parameter:** `scaling` - 


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.#ctor(System.Boolean,BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.quadrature.edgequadraturescheme.#ctor(system.boolean,bosss.foundation.grid.edgemask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.quadrature.edgequadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.edgemask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `scaling` - 


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.quadrature.edgequadraturescheme.#ctor(bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.edgemask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.quadrature.edgequadraturescheme.getdefaultdomain(bosss.foundation.grid.igriddata)"></a>
**Summary:** [BoSSS.Foundation.Grid.EdgeMask.GetFullMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType)](#bosss.foundation.grid.edgemask.getfullmask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype))
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultdomain(bosss.foundation.grid.igriddata))
**Returns:**
A mask containing all edges of the grid.


## Method: BoSSS.Foundation.Quadrature.EdgeQuadratureScheme.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.edgequadraturescheme.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** [BoSSS.Foundation.Quadrature.StandardQuadRuleFactory](#bosss.foundation.quadrature.standardquadrulefactory)
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement))
**Parameter:** `Kref` - an edge reference element, must be one of [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements](#bosss.foundation.grid.igeometricaledgedata.edgerefelements).
**Returns:**
An instance of [BoSSS.Foundation.Quadrature.StandardQuadRuleFactory](#bosss.foundation.quadrature.standardquadrulefactory) for the edge
simplex.

## Class: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme"></a>

**Summary:** Quadrature scheme for standard integration over the boundaries of
cells. That is, for a given cell, integration is performed over
all edges adjacent to this cell.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,System.Boolean,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,system.boolean,bosss.foundation.grid.cellmask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.
**Parameter:** `scaling` - 


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.#ctor(System.Boolean,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.#ctor(system.boolean,bosss.foundation.grid.cellmask)"></a>
**Summary:** Constructs an empty quadrature scheme.
**Parameter:** `domain` - Background domain.
**Parameter:** `UseDefaultFactories` - if true, quadrature rule factories for default (Gaussian) rules will be added for the domain 'domain';
if false, the user must add factories for all items in the domain.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IIntegrationMetric,BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.CellBoundaryQuadRule},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.#ctor(bosss.foundation.quadrature.iintegrationmetric,bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.cellboundaryquadrule},bosss.foundation.grid.cellmask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `scaling` - 


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.#ctor(BoSSS.Foundation.Quadrature.IQuadRuleFactory{BoSSS.Foundation.Quadrature.CellBoundaryQuadRule},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.#ctor(bosss.foundation.quadrature.iquadrulefactory{bosss.foundation.quadrature.cellboundaryquadrule},bosss.foundation.grid.cellmask)"></a>
**Summary:** Convenience constructor that allows for the construction of a
scheme with a predefined factory. Equivalent to creating an empty
scheme and calling
[BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))('factory', 'domain').
**Parameter:** `factory` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))
**Parameter:** `domain` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.AddFactoryDomainPair(BoSSS.Foundation.Quadrature.IQuadRuleFactory{`0},`1,System.Nullable{System.Int32})](#bosss.foundation.quadrature.quadraturescheme`2.addfactorydomainpair(bosss.foundation.quadrature.iquadrulefactory{`0},`1,system.nullable{system.int32}))


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.getdefaultdomain(bosss.foundation.grid.igriddata)"></a>
**Summary:** [BoSSS.Foundation.Grid.CellMask.GetFullMask(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.MaskType)](#bosss.foundation.grid.cellmask.getfullmask(bosss.foundation.grid.igriddata,bosss.foundation.grid.masktype))
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultDomain(BoSSS.Foundation.Grid.IGridData)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultdomain(bosss.foundation.grid.igriddata))
**Returns:**
A mask containing all cells of the grid.


## Method: BoSSS.Foundation.Quadrature.CellBoundaryQuadratureScheme.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.cellboundaryquadraturescheme.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** [BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1](#bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1)
**Parameter:** `gridData` - [BoSSS.Foundation.Quadrature.QuadratureScheme`2.GetDefaultRuleFactory(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement)](#bosss.foundation.quadrature.quadraturescheme`2.getdefaultrulefactory(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement))
**Parameter:** `elem` - reference element, must be one of [BoSSS.Foundation.Grid.IGeometricalCellsData.RefElements](#bosss.foundation.grid.igeometricalcellsdata.refelements)
**Returns:**
An instance of [BoSSS.Foundation.Quadrature.CellBoundaryFromEdgeRuleFactory`1](#bosss.foundation.quadrature.cellboundaryfromedgerulefactory`1)
based on a [BoSSS.Foundation.Quadrature.StandardQuadRuleFactory](#bosss.foundation.quadrature.standardquadrulefactory) for the edge
simplex.

## Class: BoSSS.Foundation.Quadrature.QuadRule <a id="bosss.foundation.quadrature.quadrule"></a>

**Summary:** a container for quadrature rules, used by the [BoSSS.Foundation.Quadrature.Quadrature`2](#bosss.foundation.quadrature.quadrature`2) class


## Method: BoSSS.Foundation.Quadrature.QuadRule.CreateBlank(BoSSS.Foundation.Grid.RefElements.RefElement,System.Int32,System.Int32,System.Boolean) <a id="bosss.foundation.quadrature.quadrule.createblank(bosss.foundation.grid.refelements.refelement,system.int32,system.int32,system.boolean)"></a>
**Summary:** Creates a empty (i.e. all entries set to 0.0) quadrature rule for filling by the user.
**Parameter:** `noOfNodes` - 
**Parameter:** `D` - spatial dimension
**Parameter:** `Kref` - reference element for which this quadrature rule is valid
**Parameter:** `useNodeSetCaching` - switching on the caching for the associated Nodes ([BoSSS.Foundation.NodeSet](#bosss.foundation.nodeset))
**Returns:**
an empty (i.e. all weights are 0.0) quadrature rule.
Note: before this rule can be used, the nodes ([BoSSS.Foundation.Quadrature.QuadRule.Nodes](#bosss.foundation.quadrature.quadrule.nodes)) must be locked (**ilPSP.MultidimensionalArray.LockForever**).


### Property: BoSSS.Foundation.Quadrature.QuadRule.RefElement <a id="bosss.foundation.quadrature.quadrule.refelement"></a>
**Summary:** the reference element on which this rule is valid


### Property: BoSSS.Foundation.Quadrature.QuadRule.NoOfNodes <a id="bosss.foundation.quadrature.quadrule.noofnodes"></a>
**Summary:** number of nodes


### Field: BoSSS.Foundation.Quadrature.QuadRule.Nodes <a id="bosss.foundation.quadrature.quadrule.nodes"></a>
**Summary:** Nodes (i.e. Points in the domain at which the integrand is evaluated);
- 1st index: node index; 
- 2nd index: spatial coordinate index, valid indexes are 0 for 1D and 0,1 for 2D and 0,1,2 for 3D;


### Field: BoSSS.Foundation.Quadrature.QuadRule.Weights <a id="bosss.foundation.quadrature.quadrule.weights"></a>
**Summary:** quadrature weights; 

index corresponds with 1st index of [BoSSS.Foundation.Quadrature.QuadRule.Nodes](#bosss.foundation.quadrature.quadrule.nodes);


### Field: BoSSS.Foundation.Quadrature.QuadRule.OrderOfPrecision <a id="bosss.foundation.quadrature.quadrule.orderofprecision"></a>
**Summary:** if applicable, the maximum degree of a polynomial which is integrated
exactly by this quadrature rule.


### Property: BoSSS.Foundation.Quadrature.QuadRule.IsEmpty <a id="bosss.foundation.quadrature.quadrule.isempty"></a>
**Summary:** Guess What?


### Property: BoSSS.Foundation.Quadrature.QuadRule.SpatialDim <a id="bosss.foundation.quadrature.quadrule.spatialdim"></a>
**Summary:** spatial dimension of quad rule.


## Method: BoSSS.Foundation.Quadrature.QuadRule.Equals(System.Object) <a id="bosss.foundation.quadrature.quadrule.equals(system.object)"></a>
**Summary:** See [BoSSS.Foundation.Quadrature.QuadRule.Equals(BoSSS.Foundation.Quadrature.QuadRule)](#bosss.foundation.quadrature.quadrule.equals(bosss.foundation.quadrature.quadrule))
**Parameter:** `obj` - See **System.Object.Equals(System.Object)**
**Returns:**
See [BoSSS.Foundation.Quadrature.QuadRule.Equals(BoSSS.Foundation.Quadrature.QuadRule)](#bosss.foundation.quadrature.quadrule.equals(bosss.foundation.quadrature.quadrule))


## Method: BoSSS.Foundation.Quadrature.QuadRule.GetHashCode <a id="bosss.foundation.quadrature.quadrule.gethashcode"></a>
**Summary:** Creates a hash based on the hashes of [BoSSS.Foundation.Quadrature.QuadRule.Weights](#bosss.foundation.quadrature.quadrule.weights) and
[BoSSS.Foundation.Quadrature.QuadRule.Nodes](#bosss.foundation.quadrature.quadrule.nodes)
**Returns:**
A hash code for this object


## Method: BoSSS.Foundation.Quadrature.QuadRule.Clone <a id="bosss.foundation.quadrature.quadrule.clone"></a>
**Summary:** Creates a deep copy of this object.
**Returns:**
An independent clone of this object.


## Method: BoSSS.Foundation.Quadrature.QuadRule.Equals(BoSSS.Foundation.Quadrature.QuadRule) <a id="bosss.foundation.quadrature.quadrule.equals(bosss.foundation.quadrature.quadrule)"></a>
**Summary:** Checks if two quad rules can be considered equal. This is true, if
they have the same [BoSSS.Foundation.Quadrature.QuadRule.Weights](#bosss.foundation.quadrature.quadrule.weights) and the same
[BoSSS.Foundation.Quadrature.QuadRule.Nodes](#bosss.foundation.quadrature.quadrule.nodes)
**Parameter:** `other` - The quad rule for which equality should be checked
**Returns:**
True, if [BoSSS.Foundation.Quadrature.QuadRule.Weights](#bosss.foundation.quadrature.quadrule.weights) and [BoSSS.Foundation.Quadrature.QuadRule.Nodes](#bosss.foundation.quadrature.quadrule.nodes) are equal.
Otherwise, false is returned.

## Class: BoSSS.Foundation.Quadrature.StandardDoubleEdgeRuleFactory <a id="bosss.foundation.quadrature.standarddoubleedgerulefactory"></a>

**Summary:** a double-edge-quadrature [BoSSS.Foundation.Quadrature.DoubleEdgeQuadrature](#bosss.foundation.quadrature.doubleedgequadrature) which uses the same rule for all edges.


## Method: BoSSS.Foundation.Quadrature.StandardDoubleEdgeRuleFactory.#ctor(BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.standarddoubleedgerulefactory.#ctor(bosss.foundation.grid.igriddata,bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** ctor.


### Property: BoSSS.Foundation.Quadrature.StandardDoubleEdgeRuleFactory.RefElement <a id="bosss.foundation.quadrature.standarddoubleedgerulefactory.refelement"></a>
**Summary:** the edge simplex of the grid


## Method: BoSSS.Foundation.Quadrature.StandardDoubleEdgeRuleFactory.GetCachedRuleOrders <a id="bosss.foundation.quadrature.standarddoubleedgerulefactory.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


## Method: BoSSS.Foundation.Quadrature.StandardDoubleEdgeRuleFactory.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.standarddoubleedgerulefactory.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** construction of the quadrature rule.

## Class: BoSSS.Foundation.Quadrature.StandardQuadRuleFactory <a id="bosss.foundation.quadrature.standardquadrulefactory"></a>

**Summary:** Standard quad rule factory that constructs quadrature rules that are
suitable for continuous integrands.


## Method: BoSSS.Foundation.Quadrature.StandardQuadRuleFactory.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.standardquadrulefactory.#ctor(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Constructs a new factory for the given simplex.
**Parameter:** `simplex` - The simplex to be integrated over.


## Method: BoSSS.Foundation.Quadrature.StandardQuadRuleFactory.GetCachedRuleOrders <a id="bosss.foundation.quadrature.standardquadrulefactory.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


## Method: BoSSS.Foundation.Quadrature.StandardQuadRuleFactory.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.standardquadrulefactory.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32)) to create a quad rule
(i.e., the quad rule is the same for all elements of
'mask')
**Parameter:** `mask` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Parameter:** `order` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Returns:**
[BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32))


### Property: BoSSS.Foundation.Quadrature.StandardQuadRuleFactory.RefElement <a id="bosss.foundation.quadrature.standardquadrulefactory.refelement"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.RefElement](#bosss.foundation.quadrature.iquadrulefactory`1.refelement)

## Class: BoSSS.Foundation.Quadrature.StandardCellBoundaryQuadRuleFactory <a id="bosss.foundation.quadrature.standardcellboundaryquadrulefactory"></a>

**Summary:** Standard quad rule factory that constructs quadrature rules that are
suitable for continuous integrands.


## Method: BoSSS.Foundation.Quadrature.StandardCellBoundaryQuadRuleFactory.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement) <a id="bosss.foundation.quadrature.standardcellboundaryquadrulefactory.#ctor(bosss.foundation.grid.refelements.refelement)"></a>
**Summary:** Constructs a new factory for the given simplex.
**Parameter:** `simplex` - The simplex to be integrated over.


## Method: BoSSS.Foundation.Quadrature.StandardCellBoundaryQuadRuleFactory.GetCachedRuleOrders <a id="bosss.foundation.quadrature.standardcellboundaryquadrulefactory.getcachedruleorders"></a>
**Summary:** If there are any cached rules, this method returns their order.


## Method: BoSSS.Foundation.Quadrature.StandardCellBoundaryQuadRuleFactory.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32) <a id="bosss.foundation.quadrature.standardcellboundaryquadrulefactory.getquadruleset(bosss.foundation.grid.executionmask,system.int32)"></a>
**Summary:** Uses [BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32)) to create a quad rule
(i.e., the quad rule is the same for all elements of
'mask')
**Parameter:** `mask` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Parameter:** `order` - [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.GetQuadRuleSet(BoSSS.Foundation.Grid.ExecutionMask,System.Int32)](#bosss.foundation.quadrature.iquadrulefactory`1.getquadruleset(bosss.foundation.grid.executionmask,system.int32))
**Returns:**
[BoSSS.Foundation.Grid.RefElements.RefElement.GetQuadratureRule(System.Int32)](#bosss.foundation.grid.refelements.refelement.getquadraturerule(system.int32))


### Property: BoSSS.Foundation.Quadrature.StandardCellBoundaryQuadRuleFactory.RefElement <a id="bosss.foundation.quadrature.standardcellboundaryquadrulefactory.refelement"></a>
**Summary:** [BoSSS.Foundation.Quadrature.IQuadRuleFactory`1.RefElement](#bosss.foundation.quadrature.iquadrulefactory`1.refelement)

## Class: BoSSS.Foundation.ICompositeQuadRule_Ext <a id="bosss.foundation.icompositequadrule_ext"></a>

**Summary:** extension methods


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.GetCellMask(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.icompositequadrule_ext.getcellmask(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Creates a [BoSSS.Foundation.Grid.CellMask](#bosss.foundation.grid.cellmask) containing all cells covered by this composite quadrature rule.
**Parameter:** `compositeRule` - The composite quadrature rule to convert
**Returns:**
A cell mask matching the quadrature rule's coverage


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.RestrictToMask(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.ExecutionMask) <a id="bosss.foundation.icompositequadrule_ext.restricttomask(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.executionmask)"></a>
**Summary:** Restricts a composite quadrature rule to an execution mask.
**Parameter:** `compositeRule` - Original quadrature rule.
**Parameter:** `executionMask` - Mask to restrict to.
**Returns:**
New composite rule containing only parts of the original rule within the mask.


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.SumOfWeightsToTextFileEdge(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.icompositequadrule_ext.sumofweightstotextfileedge(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Saves the sum of weights of each edge rule in the given
'compositeRule' together with the coordinates of
the corresponding edge center into a text file.


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.SumOfWeightsToTextFileVolume(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.icompositequadrule_ext.sumofweightstotextfilevolume(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Saves the sum of weights of each volume rule in the given
'compositeRule' together with the coordinates of
the corresponding cell center into a text file.


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.SaveToTextFileCell(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String,System.Boolean) <a id="bosss.foundation.icompositequadrule_ext.savetotextfilecell(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string,system.boolean)"></a>
**Summary:** Saves the location and weight associated with each node in
'compositeRule' into a text file


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.SaveToTextFileEdge(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String,System.Boolean) <a id="bosss.foundation.icompositequadrule_ext.savetotextfileedge(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string,system.boolean)"></a>
**Summary:** Saves the location and weight associated with each node in
'compositeRule' into a text file


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.ToVtpFilesEdge(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.icompositequadrule_ext.tovtpfilesedge(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Write the edge quadrature rules into vtp files (importable to paraview)
**Parameter:** `chunRulePairList` - the lsit of edge quadrature rules
**Parameter:** `gd` - grid data
**Parameter:** `filename` - filename header


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.ToVtpFilesCell(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.IGridData,System.String) <a id="bosss.foundation.icompositequadrule_ext.tovtpfilescell(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.igriddata,system.string)"></a>
**Summary:** Write the cell quadrature rules (volume or surface) into vtp files (importable to paraview)
**Parameter:** `chunRulePairList` - the lsit of edge quadrature rules
**Parameter:** `gd` - grid data
**Parameter:** `filename` - filename header


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.OutputQuadratureRuleAsVtpXML(BoSSS.Foundation.Quadrature.QuadRule,System.String) <a id="bosss.foundation.icompositequadrule_ext.outputquadratureruleasvtpxml(bosss.foundation.quadrature.quadrule,system.string)"></a>
**Summary:** Writes a xml file for visualization (Use .vtp extension for Paraview)


## Method: BoSSS.Foundation.ICompositeQuadRule_Ext.OutputQuadratureRuleAsVtpXML(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.String) <a id="bosss.foundation.icompositequadrule_ext.outputquadratureruleasvtpxml(ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.string)"></a>
**Summary:** Writes a xml file for visualization (Use .vtp extension for Paraview)

## Class: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField <a id="bosss.foundation.constraineddgprojection.constraineddgfield"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.#ctor(BoSSS.Foundation.Basis,BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.#ctor(bosss.foundation.basis,bosss.foundation.constraineddgprojection.projectionstrategy)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.ProjectDGField(BoSSS.Foundation.ConventionalDGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.projectdgfield(bosss.foundation.conventionaldgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** Projects some DG field 'orgDGField' onto the internal, continuous representation
**Parameter:** `orgDGField` - input; unchanged on exit
**Parameter:** `mask` - 


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.ProjectDGField_patchwise(BoSSS.Foundation.Grid.CellMask,System.Int32) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.projectdgfield_patchwise(bosss.foundation.grid.cellmask,system.int32)"></a>
**Parameter:** `mask` - 
**Parameter:** `NoOfPatchesPerProcess` - 
**Returns:**



## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.ProjectOnLocalMergePatch_edgewise(BoSSS.Foundation.Grid.CellMask,System.Collections.Generic.List{BoSSS.Foundation.Grid.CellMask}) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.projectonlocalmergepatch_edgewise(bosss.foundation.grid.cellmask,system.collections.generic.list{bosss.foundation.grid.cellmask})"></a>
**Summary:** for debugging
**Parameter:** `mask` - 
**Parameter:** `patches` - 


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.ProjectDGFieldGlobal(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.projectdgfieldglobal(bosss.foundation.grid.cellmask)"></a>
**Summary:** Uses global solver which means solver runs on MPI_comm.WORLD
**Parameter:** `mask` - 


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.ProjectDGFieldOnPatch(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.projectdgfieldonpatch(bosss.foundation.grid.cellmask,bosss.foundation.grid.edgemask)"></a>
**Summary:** Uses local solver which means solver runs on MPI_comm.SELF
**Parameter:** `mask` - 
**Parameter:** `fixedBoundaryMask` - 


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.getEdgeInterpolationNodes(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.getedgeinterpolationnodes(system.int32,system.int32,system.int32)"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.UpdateInternalProjection <a id="bosss.foundation.constraineddgprojection.constraineddgfield.updateinternalprojection"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.CheckLocalProjection(BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.checklocalprojection(bosss.foundation.grid.cellmask,system.boolean)"></a>
**Parameter:** `mask` - 
**Parameter:** `onInterProc` - 
**Returns:**



## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField.AccToDGField(System.Double,BoSSS.Foundation.ConventionalDGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfield.acctodgfield(system.double,bosss.foundation.conventionaldgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** Accumulate the internal continuous field to a DG Field
**Parameter:** `alpha` - Scaling factor
**Parameter:** `DGField` - output
**Parameter:** `mask` - 

## Class: BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy <a id="bosss.foundation.constraineddgprojection.projectionstrategy"></a>

**Summary:** [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Factory(BoSSS.Foundation.Basis,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy)](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.factory(bosss.foundation.basis,bosss.foundation.grid.cellmask,bosss.foundation.constraineddgprojection.projectionstrategy))


### Field: BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy.globalOnly <a id="bosss.foundation.constraineddgprojection.projectionstrategy.globalonly"></a>
**Summary:** [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField_Global](#bosss.foundation.constraineddgprojection.constraineddgfield_global)


### Field: BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy.patchwiseOnly <a id="bosss.foundation.constraineddgprojection.projectionstrategy.patchwiseonly"></a>
**Summary:** [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise)

## Class: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3 <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3"></a>

**Summary:** Projection of a DG field onto a continuous subspace of the DG space;
Applications which require continuous approximations are:
- Level Set algorithms; if a level-set field is not continuous, the zero-set is not connected, which can result in many pathological cases
- Artificial Viscosity (AV): also AV fields must be continuous to provide decent results

**Remark:**
- Explained in PhD thesis of M. Smuda, see https://tuprints.ulb.tu-darmstadt.de/17376/


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Factory(BoSSS.Foundation.Basis,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.ConstrainedDGprojection.ProjectionStrategy) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.factory(bosss.foundation.basis,bosss.foundation.grid.cellmask,bosss.foundation.constraineddgprojection.projectionstrategy)"></a>
**Summary:** Factory to produce different variants.
**Parameter:** `b` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Basis](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.basis)
**Parameter:** `__domainLimit` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.domainLimit](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.domainlimit)
**Parameter:** `s` - 
**Returns:**



## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.#ctor(BoSSS.Foundation.Basis,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.#ctor(bosss.foundation.basis,bosss.foundation.grid.cellmask)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Dispose <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.dispose"></a>
**Summary:** release of internal solvers


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.domainLimit <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.domainlimit"></a>
**Summary:** domain on which the projection is performed;
null denotes the entire domain;
in the case of level-set continuity projection, typically the narrow band.


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Basis <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.basis"></a>


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.m_Coordinates <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.m_coordinates"></a>
**Summary:** DG Coordinates of the current approximation;
after execution of the approximation algorithm, hopefully continuous;


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.internalProjection <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.internalprojection"></a>
**Summary:** DG representation of the current solution


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.InternalDGfield <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.internaldgfield"></a>
**Summary:** DG representation of the current solution;
[BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.CheckLocalProjection(BoSSS.Foundation.SinglePhaseField@,BoSSS.Foundation.Grid.CellMask,System.Boolean)](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.checklocalprojection(bosss.foundation.singlephasefield@,bosss.foundation.grid.cellmask,system.boolean)) computes jump norms from this field


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.m_Coordinates0 <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.m_coordinates0"></a>
**Summary:** DG coordinates of original discontinuous representation


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.initialProjection0 <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.initialprojection0"></a>
**Summary:** DG representation of the initial (discontinuous) solution


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.diagnosticOutput <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.diagnosticoutput"></a>
**Summary:** hard-coded switch to turn some console output on/off (BAD PRACTICE)


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.diagOutputMatlab <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.diagoutputmatlab"></a>
**Summary:** hard-coded switch to turn debugging output for MATLAB on/off


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ProjectDGField(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.projectdgfield(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Projects some DG field 'orgDGField' onto the internal, continuous representation.
**Parameter:** `orgDGField` - input; unchanged on exit


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.SetDGCoordinatesOnce(BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.setdgcoordinatesonce(bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** sets the internal DG coordinates from 'orgDGField'

## Class: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal"></a>

**Summary:** Core routines, i.e. projection on a certain patch [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.Patch](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.patch)
This is implemented as a class, 
so that the factorization of the linear solver can be cached. (In the case of a direct solver)
Then the first call to **BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.PerformProjection** might be expensive,
but any subsequent call is comparatively cheap.


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.#ctor(BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.#ctor(bosss.foundation.constraineddgprojection.constraineddgfieldmk3,bosss.foundation.grid.cellmask,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Parameter:** `runOnlyLocal` -
- true: work on MPI SELF communicator
- false: work on MPI WORLD communicator
**Parameter:** `__patch` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.Patch](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.patch)
**Parameter:** `__domain` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.DomainLimit](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.domainlimit)
**Parameter:** `__owner` - 


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.Patch <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.patch"></a>
**Summary:** Cell mask on which the projection will be performed;
only cells within this mask will be updated.


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.DomainLimit <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.domainlimit"></a>
**Summary:** Optional domain limit, can be null;
on the boundary of this mask, no constraints will be enforced.
If not specified, only the boundaries of the grid are considered.


### Property: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.ConstrainNodes <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.constrainnodes"></a>
**Summary:** Nodes at which the continuity constrains are enforced.
- index: correlates with edge reference element index, [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeRefElements](#bosss.foundation.grid.igeometricaledgedata.edgerefelements), [BoSSS.Foundation.Grid.IGeometricalEdgeData.GetRefElementIndex(System.Int32)](#bosss.foundation.grid.igeometricaledgedata.getrefelementindex(system.int32))


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.AT <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.at"></a>
**Summary:** Transpose of [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.A](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.a)


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.A <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.a"></a>
**Summary:** Constraints matrix


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.solverAAT <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.solveraat"></a>
**Summary:** internal matrix used by the linear solver


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ConstrainedProjectionInternal.CheckSolutionResidual(ilPSP.Tracing.FuncTrace,System.Double[],System.Double[]) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.constrainedprojectioninternal.checksolutionresidual(ilpsp.tracing.functrace,system.double[],system.double[])"></a>
**Summary:** Verifies that the solution of the linear system is sufficiently good.


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.UpdateInternalProjection(MPI.Wrappers.MPI_Comm) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.updateinternalprojection(mpi.wrappers.mpi_comm)"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.CheckLocalProjection(BoSSS.Foundation.SinglePhaseField@,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.checklocalprojection(bosss.foundation.singlephasefield@,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Computes the norm of jumps on the interior edges of the 'mask'
L2-error norm of the projected field against the initial discontinuous field


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.CheckLocalProjection(BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.checklocalprojection(bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Computes the norm of jumps on the interior edges of the 'mask'


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.ScheissDrauf(BoSSS.Foundation.SinglePhaseField) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.scheissdrauf(bosss.foundation.singlephasefield)"></a>
**Summary:** A hack only used for testing


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.CheckLocalProjection(MPI.Wrappers.MPI_Comm,BoSSS.Foundation.SinglePhaseField@,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.checklocalprojection(mpi.wrappers.mpi_comm,bosss.foundation.singlephasefield@,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Computes the norm of jumps on the interior edges of the 'mask'


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.AccToDGField(System.Double,BoSSS.Foundation.ConventionalDGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfieldmk3.acctodgfield(system.double,bosss.foundation.conventionaldgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** Accumulate the internal continuous field to a DG Field
**Parameter:** `alpha` - Scaling factor
**Parameter:** `DGField` - output
**Parameter:** `mask` - 

## Class: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField_Global <a id="bosss.foundation.constraineddgprojection.constraineddgfield_global"></a>

**Summary:** Projection of a DG field onto a continuous subspace of the DG space:
Here, the projection onto a continuous sub-space by solving a global system;
This results in the best continuous approximation in the L2-sense, but might be expensive to compute
tan the patch-wise implementation [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise).


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField_Global.#ctor(BoSSS.Foundation.Basis,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.constraineddgfield_global.#ctor(bosss.foundation.basis,bosss.foundation.grid.cellmask)"></a>
**Parameter:** `b` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Basis](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.basis)
**Parameter:** `__domainLimit` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.domainLimit](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.domainlimit)


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField_Global.Dispose <a id="bosss.foundation.constraineddgprojection.constraineddgfield_global.dispose"></a>
**Summary:** Release of internal solver


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGField_Global.ProjectDGField(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.constraineddgprojection.constraineddgfield_global.projectdgfield(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Projects some DG field 'orgDGField' onto the internal, continuous representation.
**Parameter:** `orgDGField` - input; unchanged on exit

## Class: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise"></a>

**Summary:** Projection of a DG field onto a continuous subspace of the DG space:
Here, the projection operation is split up into local patches.
This scales much better with larger grids, but is only an approximation to the L2-projection 
and likely produce higher oscillations.


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.#ctor(BoSSS.Foundation.Basis,BoSSS.Foundation.Grid.CellMask,System.Int32) <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.#ctor(bosss.foundation.basis,bosss.foundation.grid.cellmask,system.int32)"></a>
**Parameter:** `b` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.Basis](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.basis)
**Parameter:** `__domainLimit` - [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDGFieldMk3.domainLimit](#bosss.foundation.constraineddgprojection.constraineddgfieldmk3.domainlimit)
**Parameter:** `NoOfPatchesPerProcess` - Number of patches which should be used on the current MPI process.
if 0 or negative, determined automatically.


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.Dispose <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.dispose"></a>
**Summary:** release of internal solvers


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.maxNoOfCoordinates <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.maxnoofcoordinates"></a>
**Summary:** Threshold for the patch-wise projection; patches are determined
that the size of the linear system stays below this number.


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField_patchwise_setup(System.Int32) <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield_patchwise_setup(system.int32)"></a>
**Parameter:** `NoOfPatchesPerProcess` - number of patches on current MPI process


## Method: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Projects some DG field 'orgDGField' onto the internal, continuous representation.
**Parameter:** `orgDGField` - input; unchanged on exit


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.MinIterations <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.miniterations"></a>
**Summary:** Minimum required iterations for [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield(bosss.foundation.conventionaldgfield))


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.MaxIterations <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.maxiterations"></a>
**Summary:** Maximum allowed iterations for [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield(bosss.foundation.conventionaldgfield))


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.RelTerminationThreshold <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.relterminationthreshold"></a>
**Summary:** Relative threshold for the termination of the iterations for [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield(bosss.foundation.conventionaldgfield))


### Field: BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.AbsTerminationThreshold <a id="bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.absterminationthreshold"></a>
**Summary:** Absolute threshold for the termination of the iterations for [BoSSS.Foundation.ConstrainedDGprojection.ConstrainedDgField_Patchwise.ProjectDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.constraineddgprojection.constraineddgfield_patchwise.projectdgfield(bosss.foundation.conventionaldgfield))

## Class: BoSSS.Foundation.ConstrainedDGprojection.BlockingStrategy <a id="bosss.foundation.constraineddgprojection.blockingstrategy"></a>

**Summary:** Abstract base class, template for different strategies


## Method: BoSSS.Foundation.ConstrainedDGprojection.BlockingStrategy.GetBlocking(BoSSS.Foundation.Grid.Classic.GridData,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.constraineddgprojection.blockingstrategy.getblocking(bosss.foundation.grid.classic.griddata,bosss.foundation.grid.cellmask)"></a>
**Summary:** Returns lists which form the blocks of the additive-Schwarz domain decomposition.
**Returns:**
- outer enumeration: corresponds to domain-decomposition blocks
- inner index: indices within the sub-blocks
- content: local cell indices which form the respective additive-Schwarz block


## Method: BoSSS.Foundation.ConstrainedDGprojection.BlockingStrategy.GetNoOfBlocks <a id="bosss.foundation.constraineddgprojection.blockingstrategy.getnoofblocks"></a>
**Summary:** Number of blocs returned by [BoSSS.Foundation.ConstrainedDGprojection.BlockingStrategy.GetBlocking(BoSSS.Foundation.Grid.Classic.GridData,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.constraineddgprojection.blockingstrategy.getblocking(bosss.foundation.grid.classic.griddata,bosss.foundation.grid.cellmask))

## Class: BoSSS.Foundation.ConstrainedDGprojection.METISBlockingStrategy <a id="bosss.foundation.constraineddgprojection.metisblockingstrategy"></a>

**Summary:** creates a fixed number of blocks by using METIS


### Field: BoSSS.Foundation.ConstrainedDGprojection.METISBlockingStrategy.NoOfPartsOnCurrentProcess <a id="bosss.foundation.constraineddgprojection.metisblockingstrategy.noofpartsoncurrentprocess"></a>
**Summary:** Number of parts/additive Schwarz blocks on current MPI process (can be different on other processors)


## Method: BoSSS.Foundation.ConstrainedDGprojection.METISBlockingStrategy.GetNoOfBlocks <a id="bosss.foundation.constraineddgprojection.metisblockingstrategy.getnoofblocks"></a>
**Summary:** %

## Class: BoSSS.Foundation.ConstrainedDGprojection.SolverUtils <a id="bosss.foundation.constraineddgprojection.solverutils"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.SolverUtils.GetLocalMatrix(ilPSP.LinSolvers.BlockMsrMatrix) <a id="bosss.foundation.constraineddgprojection.solverutils.getlocalmatrix(ilpsp.linsolvers.blockmsrmatrix)"></a>
**Summary:** convert global BlockMsrMatrix to local Msr matrix
**Parameter:** `Matrix` - 
**Returns:**



## Method: BoSSS.Foundation.ConstrainedDGprojection.SolverUtils.GlobalSolverFactory(System.Int64) <a id="bosss.foundation.constraineddgprojection.solverutils.globalsolverfactory(system.int64)"></a>
**Summary:** constructs solver depending on size of matrix (DOF). Acts on MPI_Comm.WORLD
**Parameter:** `DOF` - 
**Returns:**



## Method: BoSSS.Foundation.ConstrainedDGprojection.SolverUtils.PatchSolverFactory <a id="bosss.foundation.constraineddgprojection.solverutils.patchsolverfactory"></a>
**Summary:** constructs solver which acts on MPI_Comm.SELF
**Returns:**


## Class: BoSSS.Foundation.ConstrainedDGprojection.GeometricEdgeForProjection <a id="bosss.foundation.constraineddgprojection.geometricedgeforprojection"></a>


## Method: BoSSS.Foundation.ConstrainedDGprojection.GeometricEdgeForProjection.GetRefDirection(BoSSS.Foundation.Grid.Classic.GridData,System.Int32,System.Int32) <a id="bosss.foundation.constraineddgprojection.geometricedgeforprojection.getrefdirection(bosss.foundation.grid.classic.griddata,system.int32,system.int32)"></a>
**Returns:**


## Class: BoSSS.Foundation.ConventionalDGField <a id="bosss.foundation.conventionaldgfield"></a>

**Summary:** Base class for 'normal' DG fields ([BoSSS.Foundation.SinglePhaseField](#bosss.foundation.singlephasefield),
sparse fields planned, ...), i.e. fields that have a fixed number of
DOF per cell.


## Method: BoSSS.Foundation.ConventionalDGField.#ctor(BoSSS.Foundation.Basis,System.String) <a id="bosss.foundation.conventionaldgfield.#ctor(bosss.foundation.basis,system.string)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.ConventionalDGField.L2Norm(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.conventionaldgfield.l2norm(bosss.foundation.grid.cellmask)"></a>
**Summary:** computes the L2 - norm based on Parceval's equality
**Remark:**
exploiting Parcevals equality for orthonormal systems, this
function is (should be?) much faster than 
[BoSSS.Foundation.DGField.L2Norm(BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.l2norm(bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.ConventionalDGField.L2NormPerMode(System.Int32,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.conventionaldgfield.l2normpermode(system.int32,bosss.foundation.grid.cellmask)"></a>
**Summary:** computes the L2 - norm based on Parceval's equality, for a specific
polynomial degree 'deg'.
**Remark:**
exploiting Parcevals equality for orthonormal systems, this
function is (should be?) much faster than 
[BoSSS.Foundation.DGField.L2Norm(BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.l2norm(bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.ConventionalDGField.EvaluateMean(System.Int32,System.Int32,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.conventionaldgfield.evaluatemean(system.int32,system.int32,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** evaluates the mean value over a cell;
of course, the mean value doesn't depend on node set or anything like that,
so no information about that has to be provided.
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `result` - on exit, result of the evaluations are accumulated there;
the original content is scaled by 'ResultPreScale';
1st index: cell index minus 'j0';
**Parameter:** `ResultCellindexOffset` - an offset for the first index of 'result';
**Parameter:** `ResultPreScale` - see 'result'


## Method: BoSSS.Foundation.ConventionalDGField.FillMPISendBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.conventionaldgfield.fillmpisendbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.FillMPISendBuffer(System.Int32,System.Double[],System.Int32)](#bosss.foundation.dgfield.fillmpisendbuffer(system.int32,system.double[],system.int32));


## Method: BoSSS.Foundation.ConventionalDGField.GetMPISendBufferSize(System.Int32) <a id="bosss.foundation.conventionaldgfield.getmpisendbuffersize(system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.GetMPISendBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpisendbuffersize(system.int32));


## Method: BoSSS.Foundation.ConventionalDGField.GetMPIRecvBufferSize(System.Int32) <a id="bosss.foundation.conventionaldgfield.getmpirecvbuffersize(system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.GetMPIRecvBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpirecvbuffersize(system.int32));


## Method: BoSSS.Foundation.ConventionalDGField.CopyFromMPIrecvBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.conventionaldgfield.copyfrommpirecvbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.CopyFromMPIrecvBuffer(System.Int32,System.Double[],System.Int32)](#bosss.foundation.dgfield.copyfrommpirecvbuffer(system.int32,system.double[],system.int32));


## Method: BoSSS.Foundation.ConventionalDGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.conventionaldgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates the derivative of DG field 'f' 
(along the 'd'-th axis) times 'alpha'
to this field, i.e. 
this = this + 'alpha'* $\frac{\partial}{\partial x_d}$ 'f';
**Parameter:** `f` - 
**Parameter:** `d` - 0 for the x-derivative, 1 for the y-derivative, 2 for the z-derivative
**Parameter:** `alpha` - scaling of 'f';
**Parameter:** `em` - An optional restriction to the domain in which the derivative is computed (it may, e.g.
be only required in boundary cells, so a computation over the whole domain 
would be a waste of computation power. A proper execution mask for this case would be e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain


## Method: BoSSS.Foundation.ConventionalDGField.CloneAs <a id="bosss.foundation.conventionaldgfield.cloneas"></a>
**Summary:** guess what?

## Class: BoSSS.Foundation.CoordinateMapping <a id="bosss.foundation.coordinatemapping"></a>

**Summary:** This class provides bijective mappings:


First, between local field coordinate indices and local unique indices,
by the methods [BoSSS.Foundation.CoordinateMapping.LocalUniqueCoordinateIndex(BoSSS.Foundation.DGField,System.Int32,System.Int32)](#bosss.foundation.coordinatemapping.localuniquecoordinateindex(bosss.foundation.dgfield,system.int32,system.int32)) and [BoSSS.Foundation.CoordinateMapping.LocalFieldCoordinateIndex(System.Int32,BoSSS.Foundation.DGField@,System.Int32@,System.Int32@)](#bosss.foundation.coordinatemapping.localfieldcoordinateindex(system.int32,bosss.foundation.dgfield@,system.int32@,system.int32@)), 
and ...


second, between local unique indices and global unique indices,
by the methods [BoSSS.Foundation.UnsetteledCoordinateMapping.Global2LocalIndex(System.Int64)](#bosss.foundation.unsetteledcoordinatemapping.global2localindex(system.int64)) and [BoSSS.Foundation.UnsetteledCoordinateMapping.Local2GlobalIndex(System.Int32)](#bosss.foundation.unsetteledcoordinatemapping.local2globalindex(system.int32)).


In easy words, that means it mapps the DG coordinate from a list of fields into one long, one-dimensional vector
and it converts between indices that are valid only on the actual MPI process (local indices)
and indices that are valid amoung all MPI processes in the current MPI communicator (global indices).
In contrast to [BoSSS.Foundation.UnsetteledCoordinateMapping](#bosss.foundation.unsetteledcoordinatemapping), this is
a coordinate mapping that is bound to a specific list of fields
(instead a list of [BoSSS.Foundation.Basis](#bosss.foundation.basis)-objects);

**Remark:**
A "local index" is an index that is valid only on the actual MPI process,
while a "gloabl index" is an index that is valid among all MPI processes 
(in the corresponding MPI communicator).
A "local field coordinate index" is a tuple (f,j,n), where...

f is a [BoSSS.Foundation.DGField](#bosss.foundation.dgfield),
j is a local cell index and 
n is a polynomial index;

A "local unique index" is a single integer that is unique for every field in this mapping, 
for every local cell and for every polynomial;


## Method: BoSSS.Foundation.CoordinateMapping.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.coordinatemapping.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** Constructs an empty mapping.


## Method: BoSSS.Foundation.CoordinateMapping.Clear <a id="bosss.foundation.coordinatemapping.clear"></a>
**Summary:** clears all DG fields in the mapping


## Method: BoSSS.Foundation.CoordinateMapping.RenameFields(System.String[]) <a id="bosss.foundation.coordinatemapping.renamefields(system.string[])"></a>
**Summary:** Assigns a new [BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification) to each field


## Method: BoSSS.Foundation.CoordinateMapping.#ctor(BoSSS.Foundation.DGField[]) <a id="bosss.foundation.coordinatemapping.#ctor(bosss.foundation.dgfield[])"></a>
**Summary:** Constructs a new mapping from an ordered list of fields;
**Parameter:** `_fields` - the list of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s for this mapping.


## Method: BoSSS.Foundation.CoordinateMapping.#ctor(System.Collections.Generic.IList{BoSSS.Foundation.DGField}) <a id="bosss.foundation.coordinatemapping.#ctor(system.collections.generic.ilist{bosss.foundation.dgfield})"></a>
**Summary:** Constructs a new mapping from an ordered list of fields;
**Parameter:** `_fields` - the list of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s for this mapping.


### Field: BoSSS.Foundation.CoordinateMapping.m_Fields <a id="bosss.foundation.coordinatemapping.m_fields"></a>
**Summary:** the fields in this mapping;


### Property: BoSSS.Foundation.CoordinateMapping.Fields <a id="bosss.foundation.coordinatemapping.fields"></a>
**Summary:** the fields in this mapping;
**Remark:**
By this list, an field index for each field in this mapping is defined;


## Method: BoSSS.Foundation.CoordinateMapping.LocalUniqueCoordinateIndex(BoSSS.Foundation.DGField,System.Int32,System.Int32) <a id="bosss.foundation.coordinatemapping.localuniquecoordinateindex(bosss.foundation.dgfield,system.int32,system.int32)"></a>
**Summary:** computes a local unique coordinate index ("local" means local on this processor);
this index is unique over all fields (in this mapping), over all cells, over all basis functions, 
but it's only locally (on this processor) valid.
A local index in the update range (smaller than **ilPSP.Partitioning.LocalLength**) can be converted into 
a global index by adding **ilPSP.Partitioning.i0**.
**Parameter:** `f` - the field
**Parameter:** `j` - local cell index
**Parameter:** `n` - basis index.
**Returns:**
the local coordinate index for the given parameters.
**Remark:**
This method is not supported and will throw an exception 
if [BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields)==null.


## Method: BoSSS.Foundation.CoordinateMapping.GlobalUniqueCoordinateIndex(BoSSS.Foundation.DGField,System.Int32,System.Int32) <a id="bosss.foundation.coordinatemapping.globaluniquecoordinateindex(bosss.foundation.dgfield,system.int32,system.int32)"></a>
**Summary:** computes a global unique coordinate index ("global" means over all MPI processors);
this index is unique over all fields (in this mapping), over all cells, over all basis functions;
**Parameter:** `f` - the field
**Parameter:** `j` - local cell index
**Parameter:** `n` - basis index.
**Returns:**
the global DG coordinate index for the given parameters.


## Method: BoSSS.Foundation.CoordinateMapping.LocalFieldCoordinateIndex(System.Int32,BoSSS.Foundation.DGField@,System.Int32@,System.Int32@) <a id="bosss.foundation.coordinatemapping.localfieldcoordinateindex(system.int32,bosss.foundation.dgfield@,system.int32@,system.int32@)"></a>
**Summary:** inverse mapping of [BoSSS.Foundation.CoordinateMapping.LocalUniqueCoordinateIndex(BoSSS.Foundation.DGField,System.Int32,System.Int32)](#bosss.foundation.coordinatemapping.localuniquecoordinateindex(bosss.foundation.dgfield,system.int32,system.int32));
**Parameter:** `Index` - local unique coordinate index
**Parameter:** `f` - on exit, the field which 'Index' belongs to.
**Parameter:** `j` - on exit, the local cell index
**Parameter:** `n` - on exit, the basis function index
**Returns:**



## Method: BoSSS.Foundation.CoordinateMapping.Equals(System.Object) <a id="bosss.foundation.coordinatemapping.equals(system.object)"></a>
**Summary:** Two [BoSSS.Foundation.CoordinateMapping](#bosss.foundation.coordinatemapping) are equal if all entries of their [BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields)-properties are
equal in reference. Note that this is a very strict condition; if the mappings should be compared just on
[BoSSS.Foundation.UnsetteledCoordinateMapping](#bosss.foundation.unsetteledcoordinatemapping)-level, the [BoSSS.Foundation.UnsetteledCoordinateMapping.EqualsUnsetteled(BoSSS.Foundation.UnsetteledCoordinateMapping)](#bosss.foundation.unsetteledcoordinatemapping.equalsunsetteled(bosss.foundation.unsetteledcoordinatemapping))-comparison
should be used.


## Method: BoSSS.Foundation.CoordinateMapping.GetHashCode <a id="bosss.foundation.coordinatemapping.gethashcode"></a>
**Summary:** calls base implementation


## Method: BoSSS.Foundation.CoordinateMapping.IndexOf(BoSSS.Foundation.DGField) <a id="bosss.foundation.coordinatemapping.indexof(bosss.foundation.dgfield)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.CoordinateMapping.Insert(System.Int32,BoSSS.Foundation.DGField) <a id="bosss.foundation.coordinatemapping.insert(system.int32,bosss.foundation.dgfield)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**, but not supported


## Method: BoSSS.Foundation.CoordinateMapping.RemoveAt(System.Int32) <a id="bosss.foundation.coordinatemapping.removeat(system.int32)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**, but not supported


### Property: BoSSS.Foundation.CoordinateMapping.Item(System.Int32) <a id="bosss.foundation.coordinatemapping.item(system.int32)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**, setting is not supported


## Method: BoSSS.Foundation.CoordinateMapping.Add(BoSSS.Foundation.DGField) <a id="bosss.foundation.coordinatemapping.add(bosss.foundation.dgfield)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**, but not supported


## Method: BoSSS.Foundation.CoordinateMapping.Contains(BoSSS.Foundation.DGField) <a id="bosss.foundation.coordinatemapping.contains(bosss.foundation.dgfield)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.CoordinateMapping.CopyTo(BoSSS.Foundation.DGField[],System.Int32) <a id="bosss.foundation.coordinatemapping.copyto(bosss.foundation.dgfield[],system.int32)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


### Property: BoSSS.Foundation.CoordinateMapping.Count <a id="bosss.foundation.coordinatemapping.count"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


### Property: BoSSS.Foundation.CoordinateMapping.IsReadOnly <a id="bosss.foundation.coordinatemapping.isreadonly"></a>
**Summary:** true!


## Method: BoSSS.Foundation.CoordinateMapping.Remove(BoSSS.Foundation.DGField) <a id="bosss.foundation.coordinatemapping.remove(bosss.foundation.dgfield)"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**, but not supported


## Method: BoSSS.Foundation.CoordinateMapping.GetEnumerator <a id="bosss.foundation.coordinatemapping.getenumerator"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.CoordinateMapping.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.coordinatemapping.system#collections#ienumerable#getenumerator"></a>
**Summary:** as defined by interface **System.Collections.Generic.IList`1**.


## Method: BoSSS.Foundation.CoordinateMapping.op_Implicit(BoSSS.Foundation.CoordinateMapping)~BoSSS.Foundation.DGField[] <a id="bosss.foundation.coordinatemapping.op_implicit(bosss.foundation.coordinatemapping)~bosss.foundation.dgfield[]"></a>
**Summary:** implicit conversion

## Class: BoSSS.Foundation.CoordinateVector <a id="bosss.foundation.coordinatevector"></a>

**Summary:** By using a [BoSSS.Foundation.CoordinateMapping](#bosss.foundation.coordinatemapping), this class
presents the DG coordinates of a list of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)-objects
as one one-dimensional vector, without allocating additional memory.


### Property: BoSSS.Foundation.CoordinateVector.PresentExternal <a id="bosss.foundation.coordinatevector.presentexternal"></a>
**Summary:** if true, also the DG coordinates of external cells (aka. ghost cells) are
presented in this vector;
This property can only be set at construction time.


## Method: BoSSS.Foundation.CoordinateVector.Scale(System.Double) <a id="bosss.foundation.coordinatevector.scale(system.double)"></a>
**Summary:** scales all fields in this mapping (see [BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields)) by a factor 'a';
**Parameter:** `a` - scaling factor


## Method: BoSSS.Foundation.CoordinateVector.Acc``1(System.Double,``0) <a id="bosss.foundation.coordinatevector.acc``1(system.double,``0)"></a>
**Summary:** accumulates a vector to the coordinates of all fields in this mapping (see [BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields));
**Parameter:** `x` - Length of 'x' vector must be equal the update length ([BoSSS.Foundation.CoordinateVector.Count](#bosss.foundation.coordinatevector.count) or **ilPSP.Partitioning.LocalLength**);
**Parameter:** `alpha` - accumulation factor for 'x'.


### Field: BoSSS.Foundation.CoordinateVector.m_mapping <a id="bosss.foundation.coordinatevector.m_mapping"></a>
**Summary:** [BoSSS.Foundation.CoordinateVector.Mapping](#bosss.foundation.coordinatevector.mapping)


### Property: BoSSS.Foundation.CoordinateVector.Mapping <a id="bosss.foundation.coordinatevector.mapping"></a>
**Summary:** the mapping of this vector to the list of DG fields;


## Method: BoSSS.Foundation.CoordinateVector.#ctor(System.Boolean,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.coordinatevector.#ctor(system.boolean,bosss.foundation.dgfield[])"></a>
**Summary:** Constructs a new vector, based on the list of DG fields,
'fields';
**Parameter:** `fields` - 
**Parameter:** `presentExternal` - value for the [BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal)-property;


## Method: BoSSS.Foundation.CoordinateVector.#ctor(BoSSS.Foundation.DGField[]) <a id="bosss.foundation.coordinatevector.#ctor(bosss.foundation.dgfield[])"></a>
**Summary:** Constructs a new vector, based on the list of DG fields,
'fields';
**Remark:**
[BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal) is initialized to false.


## Method: BoSSS.Foundation.CoordinateVector.#ctor(System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.coordinatevector.#ctor(system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Constructs a new vector, based on the list of DG fields,
'fields';
**Remark:**
[BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal) is initialized to false.


## Method: BoSSS.Foundation.CoordinateVector.#ctor(BoSSS.Foundation.CoordinateMapping,System.Boolean) <a id="bosss.foundation.coordinatevector.#ctor(bosss.foundation.coordinatemapping,system.boolean)"></a>
**Summary:** Constructs a new vector, based on the mapping 'mapping';
**Parameter:** `mapping` - The mapping to transform indices; This parameter is
used to initialize [BoSSS.Foundation.CoordinateVector.Mapping](#bosss.foundation.coordinatevector.mapping).
**Parameter:** `presentExternal` - value for the [BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal)-property;


## Method: BoSSS.Foundation.CoordinateVector.#ctor(BoSSS.Foundation.CoordinateMapping) <a id="bosss.foundation.coordinatevector.#ctor(bosss.foundation.coordinatemapping)"></a>
**Summary:** Constructs a new vector, based on the mapping 'mapping';
**Parameter:** `mapping` - The mapping to transform indices; This parameter is
used to initialize [BoSSS.Foundation.CoordinateVector.Mapping](#bosss.foundation.coordinatevector.mapping).
**Remark:**
[BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal) is initialized to false.


## Method: BoSSS.Foundation.CoordinateVector.CopyFrom``1(``0,System.Int32) <a id="bosss.foundation.coordinatevector.copyfrom``1(``0,system.int32)"></a>
**Summary:** Copies the content of the vector 'array' into the 
[BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s in this mapping ([BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields));
External cells are also copied, but no network update occurs.
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - 


## Method: BoSSS.Foundation.CoordinateVector.axpy``1(``0,System.Double) <a id="bosss.foundation.coordinatevector.axpy``1(``0,system.double)"></a>
**Summary:** this = this + 'x'*'xScale';
using this function changes the coordinates of the fields in this mapping ([BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields));
Also external cells are affected;
**Parameter:** `x` - 
**Parameter:** `xScale` - 


## Method: BoSSS.Foundation.CoordinateVector.Copy``1(``0,System.Int32,System.Boolean) <a id="bosss.foundation.coordinatevector.copy``1(``0,system.int32,system.boolean)"></a>
**Summary:** implementation of the [BoSSS.Foundation.CoordinateVector.CopyTo(System.Double[],System.Int32)](#bosss.foundation.coordinatevector.copyto(system.double[],system.int32)) and [BoSSS.Foundation.CoordinateVector.CopyFrom``1(``0,System.Int32)](#bosss.foundation.coordinatevector.copyfrom``1(``0,system.int32))
function
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - 
**Parameter:** `direction` - true: [BoSSS.Foundation.CoordinateVector.CopyTo(System.Double[],System.Int32)](#bosss.foundation.coordinatevector.copyto(system.double[],system.int32))-mode; false: [BoSSS.Foundation.CoordinateVector.CopyFrom``1(``0,System.Int32)](#bosss.foundation.coordinatevector.copyfrom``1(``0,system.int32))-mode;


### Property: BoSSS.Foundation.CoordinateVector.Fields <a id="bosss.foundation.coordinatevector.fields"></a>
**Summary:** DG fields that are presented by this vector


## Method: BoSSS.Foundation.CoordinateVector.IndexOf(System.Double) <a id="bosss.foundation.coordinatevector.indexof(system.double)"></a>
**Summary:** implemented from interface, but not supported;
**Parameter:** `item` - 
**Returns:**



## Method: BoSSS.Foundation.CoordinateVector.Insert(System.Int32,System.Double) <a id="bosss.foundation.coordinatevector.insert(system.int32,system.double)"></a>
**Summary:** not supported - array is static;
**Parameter:** `index` - 
**Parameter:** `item` - 


## Method: BoSSS.Foundation.CoordinateVector.RemoveAt(System.Int32) <a id="bosss.foundation.coordinatevector.removeat(system.int32)"></a>
**Summary:** not supported - array is static;
**Parameter:** `index` - 


### Property: BoSSS.Foundation.CoordinateVector.Item(System.Int32) <a id="bosss.foundation.coordinatevector.item(system.int32)"></a>
**Summary:** access all coordinates of all [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s as a linear array


## Method: BoSSS.Foundation.CoordinateVector.Add(System.Double) <a id="bosss.foundation.coordinatevector.add(system.double)"></a>
**Summary:** not supported - array is static (i.e length cannot be changed);
**Parameter:** `item` - 


## Method: BoSSS.Foundation.CoordinateVector.Clear <a id="bosss.foundation.coordinatevector.clear"></a>
**Summary:** sets all entries to 0.0;


## Method: BoSSS.Foundation.CoordinateVector.Contains(System.Double) <a id="bosss.foundation.coordinatevector.contains(system.double)"></a>
**Summary:** not supported;
**Parameter:** `item` - 
**Returns:**



## Method: BoSSS.Foundation.CoordinateVector.CopyTo``1(``0,System.Int32) <a id="bosss.foundation.coordinatevector.copyto``1(``0,system.int32)"></a>
**Summary:** Copies the content of the [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s in this mapping ([BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields))
to a continuous region of memory;
External cells are also copied, but no network update occurs.
**Parameter:** `array` - the destination array
**Parameter:** `arrayIndex` - offset index into the destination array


## Method: BoSSS.Foundation.CoordinateVector.CopyTo(System.Double[],System.Int32) <a id="bosss.foundation.coordinatevector.copyto(system.double[],system.int32)"></a>
**Summary:** Copies the content of the [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)'s in this mapping ([BoSSS.Foundation.CoordinateMapping.Fields](#bosss.foundation.coordinatemapping.fields))
to a continuous region of memory;
External cells are also copied, but no network update occurs.
**Parameter:** `array` - the destination array
**Parameter:** `arrayIndex` - offset index into the destination array


## Method: BoSSS.Foundation.CoordinateVector.ToArray <a id="bosss.foundation.coordinatevector.toarray"></a>
**Summary:** allocates an array and copies all DG coordiantes into it;
**Returns:**



### Property: BoSSS.Foundation.CoordinateVector.Count <a id="bosss.foundation.coordinatevector.count"></a>
**Summary:** length of this vector, see [BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal)


### Property: BoSSS.Foundation.CoordinateVector.Length <a id="bosss.foundation.coordinatevector.length"></a>
**Summary:** Alias for this.Count
length of this vector, see [BoSSS.Foundation.CoordinateVector.PresentExternal](#bosss.foundation.coordinatevector.presentexternal)


### Property: BoSSS.Foundation.CoordinateVector.IsReadOnly <a id="bosss.foundation.coordinatevector.isreadonly"></a>
**Summary:** false


## Method: BoSSS.Foundation.CoordinateVector.Remove(System.Double) <a id="bosss.foundation.coordinatevector.remove(system.double)"></a>
**Summary:** not supported - array is static;
**Parameter:** `item` - 
**Returns:**


## Class: BoSSS.Foundation.CoordinateVector.MyGenericEnumerator <a id="bosss.foundation.coordinatevector.mygenericenumerator"></a>

**Summary:** returns an generic enumerator;


## Method: BoSSS.Foundation.CoordinateVector.GetEnumerator <a id="bosss.foundation.coordinatevector.getenumerator"></a>
**Summary:** returns an enumerator;
**Returns:**


## Class: BoSSS.Foundation.CoordinateVector.MyEnumerator <a id="bosss.foundation.coordinatevector.myenumerator"></a>

**Summary:** Implementation of the IEnumerator-Interface


## Method: BoSSS.Foundation.CoordinateVector.RenameFields(System.String[]) <a id="bosss.foundation.coordinatevector.renamefields(system.string[])"></a>
**Summary:** reset [BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)


## Method: BoSSS.Foundation.CoordinateVector.RenameFields(System.Func{System.Int32,System.String}) <a id="bosss.foundation.coordinatevector.renamefields(system.func{system.int32,system.string})"></a>
**Summary:** reset [BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)

## Class: BoSSS.Foundation.DGField <a id="bosss.foundation.dgfield"></a>

**Summary:** This class represents the base class of all DG fields.

This class encapsulates the evaluation of DG fields (value, gradient, mean-value,...)
in a way that it can be commonly used by the single-phase and the XDG framework.
The main purpose of this hack is to eliminate duplicate code and make performance optimizations available to 
all kinds of DG fields.
The methods are not intended for direct use outside of layer L2.


## Method: BoSSS.Foundation.DGField.#ctor(BoSSS.Foundation.Basis,System.String) <a id="bosss.foundation.dgfield.#ctor(bosss.foundation.basis,system.string)"></a>
**Summary:** constructs a new field.
**Parameter:** `__Basis` - The basis that is used for this field
**Parameter:** `__Identification` - identification string for this field;
This can be null or empty, 
however, if IO should be preformed for this object, the identification must be unique 
among the other fields which should be saved


### Property: BoSSS.Foundation.DGField.DOFLocal <a id="bosss.foundation.dgfield.doflocal"></a>
**Summary:** Degrees-of-freedom for storing this field.

## Class: BoSSS.Foundation.DGField.ProjectionQuadrature <a id="bosss.foundation.dgfield.projectionquadrature"></a>

**Summary:** projects a scalar function onto the DG-space;
It's used by
[BoSSS.Foundation.DGField.ProjectField(System.Double,BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.Quadrature.CellQuadratureScheme)](#bosss.foundation.dgfield.projectfield(system.double,bosss.foundation.scalarfunction,bosss.foundation.quadrature.cellquadraturescheme)).


## Method: BoSSS.Foundation.DGField.ProjectionQuadrature.#ctor(BoSSS.Foundation.DGField,System.Double,BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.projectionquadrature.#ctor(bosss.foundation.dgfield,system.double,bosss.foundation.scalarfunction,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Parameter:** `owner` - 
**Parameter:** `func` - 
**Parameter:** `alpha` - 
**Parameter:** `qr` - quad. rule to be used


## Method: BoSSS.Foundation.DGField.ProjectionQuadrature.#ctor(BoSSS.Foundation.DGField,System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.projectionquadrature.#ctor(bosss.foundation.dgfield,system.double,bosss.foundation.scalarfunctionex,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_Owner <a id="bosss.foundation.dgfield.projectionquadrature.m_owner"></a>


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_func <a id="bosss.foundation.dgfield.projectionquadrature.m_func"></a>
**Summary:** the function to project onto [BoSSS.Foundation.DGField.ProjectionQuadrature.m_Owner](#bosss.foundation.dgfield.projectionquadrature.m_owner)


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_func2 <a id="bosss.foundation.dgfield.projectionquadrature.m_func2"></a>
**Summary:** the function to project onto [BoSSS.Foundation.DGField.ProjectionQuadrature.m_Owner](#bosss.foundation.dgfield.projectionquadrature.m_owner)


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_alpha <a id="bosss.foundation.dgfield.projectionquadrature.m_alpha"></a>
**Summary:** a constant to multiply [BoSSS.Foundation.DGField.ProjectionQuadrature.m_func](#bosss.foundation.dgfield.projectionquadrature.m_func) or [BoSSS.Foundation.DGField.ProjectionQuadrature.m_func2](#bosss.foundation.dgfield.projectionquadrature.m_func2) with;


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_NodesTransformed <a id="bosss.foundation.dgfield.projectionquadrature.m_nodestransformed"></a>
**Summary:** Nodes in global coordinates
- 1st index: cell index (minus some offset);
- 2nd index: node index;
- 3rd index; spatial coordinate;


### Field: BoSSS.Foundation.DGField.ProjectionQuadrature.m_FunctionValues <a id="bosss.foundation.dgfield.projectionquadrature.m_functionvalues"></a>
**Summary:** results of function evaluation
- 1st index: cell index (minus some offset);
- 2nd index: node index;


## Method: BoSSS.Foundation.DGField.ProjectionQuadrature.AllocateBuffers(System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.dgfield.projectionquadrature.allocatebuffers(system.int32,bosss.foundation.nodeset)"></a>
**Summary:** Allocates memory for the global coordinates and the function values


## Method: BoSSS.Foundation.DGField.ProjectionQuadrature.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.Quadrature.QuadRule,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.projectionquadrature.evaluate(system.int32,system.int32,bosss.foundation.quadrature.quadrule,ilpsp.multidimensionalarray)"></a>
**Summary:** Integrand evaluation.


## Method: BoSSS.Foundation.DGField.ProjectionQuadrature.SaveIntegrationResults(System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.projectionquadrature.saveintegrationresults(system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** performs the accumulation (multiplication of
integration result by [BoSSS.Foundation.DGField.ProjectionQuadrature.m_alpha](#bosss.foundation.dgfield.projectionquadrature.m_alpha) and addition to)
the DG coordinates of [BoSSS.Foundation.DGField.ProjectionQuadrature.m_Owner](#bosss.foundation.dgfield.projectionquadrature.m_owner);
**Parameter:** `i0` - 
**Parameter:** `Length` - 
**Parameter:** `ResultsOfIntegration` - 


## Method: BoSSS.Foundation.DGField.ProjectField(BoSSS.Foundation.ScalarFunction) <a id="bosss.foundation.dgfield.projectfield(bosss.foundation.scalarfunction)"></a>
**Summary:** Initializes the field to be the projection of a 
given [BoSSS.Foundation.ScalarFunction](#bosss.foundation.scalarfunction) onto the Discontinuous Galerkin Space.
The original content of this field is cleared;
**Parameter:** `func` - 


## Method: BoSSS.Foundation.DGField.ProjectField(BoSSS.Foundation.ScalarFunctionEx) <a id="bosss.foundation.dgfield.projectfield(bosss.foundation.scalarfunctionex)"></a>
**Summary:** Initializes the field to be the projection of a 
given [BoSSS.Foundation.ScalarFunction](#bosss.foundation.scalarfunction) onto the Discontinuous Galerkin Space.
The original content of this field is cleared;
**Parameter:** `func` - 


## Method: BoSSS.Foundation.DGField.ProjectField(System.Double,BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.projectfield(system.double,bosss.foundation.scalarfunction,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `scheme` - 


## Method: BoSSS.Foundation.DGField.ProjectField(System.Double,BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.projectfield(system.double,bosss.foundation.scalarfunction,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `rule` - quadrature rule


## Method: BoSSS.Foundation.DGField.ProjectField(System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.projectfield(system.double,bosss.foundation.scalarfunctionex,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `rule` - quadrature rule


## Method: BoSSS.Foundation.DGField.ProjectField(System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.projectfield(system.double,bosss.foundation.scalarfunctionex,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `scheme` - 


## Method: BoSSS.Foundation.DGField.ProjectNodal(System.Double,BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.dgfield.projectnodal(system.double,bosss.foundation.scalarfunction,bosss.foundation.nodeset)"></a>
**Summary:** Performs a nodal projection, i.e. accumulates a DG field, defined by
\f[ 
\textrm{in each cell } K_j: \ u(\vec{\xi}_i) = \alpha f(\vec{\xi}_i) \quad \forall \vec{\xi}_i
\f]
to this field.
If the number of nodes is not equal to the degrees-of-freedom in a specific cell,
a least-square projection is performed.
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `func` - function to be projected
**Parameter:** `NodeSet` - cell-local coordinates $(\vec{xi}_1, \ldots , \vec{xi}_M)$


## Method: BoSSS.Foundation.DGField.ProjectNodal(System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.dgfield.projectnodal(system.double,bosss.foundation.scalarfunctionex,bosss.foundation.nodeset)"></a>
**Summary:** Performs a nodal projection, i.e. accumulates a DG field, defined by
\f[ 
\textrm{in each cell } K_j: \ u(\vec{\xi}_i) = \alpha f(\vec{\xi}_i) \quad \forall \vec{\xi}_i
\f]
to this field. If the number of nodes is not equal to the
degrees-of-freedom in a specific cell, a least-square projection is
performed.
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `func` - function to be projected
**Parameter:** `NodeSet` - cell-local coordinates $(\vec{xi}_1, \ldots , \vec{xi}_M)$


## Method: BoSSS.Foundation.DGField.ProjectNodalMultilinear(System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.dgfield.projectnodalmultilinear(system.double,bosss.foundation.scalarfunctionex,bosss.foundation.nodeset)"></a>
**Summary:** Similar to [BoSSS.Foundation.DGField.ProjectNodal(System.Double,BoSSS.Foundation.ScalarFunctionEx,BoSSS.Foundation.NodeSet)](#bosss.foundation.dgfield.projectnodal(system.double,bosss.foundation.scalarfunctionex,bosss.foundation.nodeset)),
but uses the DG coordinates associated with multi-linear basis functions
(i.e., constant and linear term in 1D; constant, linear and
bilinear terms in 2D; constant, linear, bilinear and trilinear
terms in 3D)
**Parameter:** `alpha` - 
**Parameter:** `func` - 
**Parameter:** `NodeSet` - 


## Method: BoSSS.Foundation.DGField.SetMeanValueTo(BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.setmeanvalueto(bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** Set mean value to mean value of field


## Method: BoSSS.Foundation.DGField.SetMeanValue(System.Int32,System.Double) <a id="bosss.foundation.dgfield.setmeanvalue(system.int32,system.double)"></a>
**Summary:** overwrites the mean value in one cell
**Parameter:** `j` - a local cell index
**Parameter:** `v` - the new mean value in this cell


## Method: BoSSS.Foundation.DGField.GetMeanValue(System.Int32) <a id="bosss.foundation.dgfield.getmeanvalue(system.int32)"></a>
**Summary:** evaluates the mean value of the DG field in one cell;
**Parameter:** `j` - a local cell index
**Returns:**
%


## Method: BoSSS.Foundation.DGField.GetMeanValueTotal(BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.dgfield.getmeanvaluetotal(bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** computes the mean value of this DG field.
**Parameter:** `cm` - optional restriction to computational domain
**Parameter:** `mean` - If false, the return value equals $\int_{\Omega} u \dV$, 
otherwise it equals $\frac{  \int_{\Omega} u \dV }{  \int_{\Omega} 1 \dV  }$.


## Method: BoSSS.Foundation.DGField.GetIntegral(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.getintegral(bosss.foundation.grid.cellmask)"></a>
**Summary:** computes the integral value of this DG field over the domain.
**Parameter:** `cm` - optional restriction to computational domain


## Method: BoSSS.Foundation.DGField.GetMeanDerivative(System.Int32,System.Int32) <a id="bosss.foundation.dgfield.getmeanderivative(system.int32,system.int32)"></a>
**Summary:** Currently not implemented.
**Remark:**
This method is not very performance-efficient and shouldn't be
used by performance-critical sections;


## Method: BoSSS.Foundation.DGField.SetGradient(System.Int32,System.Double[]) <a id="bosss.foundation.dgfield.setgradient(system.int32,system.double[])"></a>
**Summary:** Currently not implemented.
**Parameter:** `j` - 
**Parameter:** `gradVec` - 


## Method: BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Double) <a id="bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.double)"></a>
**Summary:** See [BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double)](#bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)).


## Method: BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** See [BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double)](#bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)).


## Method: BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** Evaluates the field;
**Parameter:** `ResultCellindexOffset` - An offset for the first index of 'result',
i.e. the first result will be written to
'result'['ResultCellindexOffset',*].
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `result` - The output: 
On exit, the value of the DG field at the given nodes are
accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 2-dimensional:


1st index: cell index j - 'j0';


2nd index: node index k, corresponds with 1st index of
the node set 'NodeSet';
**Parameter:** `ResultPreScale` - Scaling that is applied to 'result' before
the field evaluation is added
**Parameter:** `NodeSet` - nodes to evaluate at
**Remark:**
This method is vectorized: Here, it means that the Points at which
the DG field should be evaluated, are given for one cell in
reference coordinates, but the evaluation is performed for
'Len' cells at once.


## Method: BoSSS.Foundation.DGField.EvaluateEdge(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.dgfield.evaluateedge(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** Evaluates the field along edges.
**Parameter:** `ResultIndexOffset` - An offset for the first index of 'ValueIN' resp.
'ValueOUT', i.e. the first result will be written
to
'ValueIN'['ResultIndexOffset',*].
**Parameter:** `e0` - Index of the first edge to evaluate.
**Parameter:** `Len` - Number of edges to evaluate
**Parameter:** `NS` - nodes to evaluate at
**Parameter:** `ValueIN` - If not null, contains the following output: 
On exit, the value of the DG field at the given nodes are
accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 2-dimensional:


1st index: edge index j - 'e0';


2nd index: node index k, corresponds with 1st index of
the node set 'NS';
**Parameter:** `ValueOUT` - Same as 'ValueIN'.
**Parameter:** `MeanValueIN` - If not null, contains the following output: 
On exit, the mean values of the DG field at the given edges are
accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 2-dimensional:


1st index: edge index j - 'e0';


2nd index: node index k, corresponds with 1st index of
the node set 'NS';
**Parameter:** `MeanValueOT` - Same as 'MeanValueIN'.
**Parameter:** `GradientIN` - If not null, contains the following output: 
On exit, the value of the gradient of DG field at the given nodes
are accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 3-dimensional:


1st index: edge index j - 'e0';


2nd index: node index k, corresponds with 1st index of
the node set 'NS';


2rd index: spatial dimension;
**Parameter:** `GradientOT` - Same as 'GradientIN'.
**Parameter:** `ResultPreScale` - Scaling that is applied to 'ValueIN' and 'ValueOUT' before
the field evaluation is added


## Method: BoSSS.Foundation.DGField.EvaluateGradient(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.dgfield.evaluategradient(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** Evaluates the gradient of the field;
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `NodeSet` - as usual, the nodes to evaluate at;
**Parameter:** `result` - on exit, result of the evaluations are accumulated there;
the original content is scaled by 'ResultPreScale';
1st index: cell index minus 'j0';
2nd index: node index;
3rd index: spatial coordinate;
**Parameter:** `ResultCellindexOffset` - an offset for the first index of 'result';
**Parameter:** `ResultPreScale` - see 'result'


## Method: BoSSS.Foundation.DGField.EvaluateMean(System.Int32,System.Int32,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.dgfield.evaluatemean(system.int32,system.int32,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** evaluates the mean value over a cell;
of course, the mean value doesn't depend on node set or anything like that,
so no information about that has to be provided.
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `result` - on exit, result of the evaluations are accumulated there;
the original content is scaled by 'ResultPreScale';
1st index: cell index minus 'j0';
**Parameter:** `ResultCellindexOffset` - an offset for the first index of 'result';
**Parameter:** `ResultPreScale` - see 'result'


## Method: BoSSS.Foundation.DGField.ProbeAt(System.Double[]) <a id="bosss.foundation.dgfield.probeat(system.double[])"></a>
**Summary:** evaluates this field at a point given in global coordinates; this
function is very expensive, read remarks!!! This method is
MPI-collective.
**Parameter:** `_inp` - global (!!!) coordinates
**Returns:**

**Remark:**
This function is very expensive, and it should be only used for
probing (in post-processing or for debugging) at a handful of
points.


## Method: BoSSS.Foundation.DGField.EvaluateAlongCurve(System.Func{System.Double,System.Double[]},System.Int32,System.Double,System.Double) <a id="bosss.foundation.dgfield.evaluatealongcurve(system.func{system.double,system.double[]},system.int32,system.double,system.double)"></a>
**Parameter:** `parametrization` - 
**Parameter:** `nRef` - 
**Parameter:** `min` - 
**Parameter:** `max` - 
**Returns:**



## Method: BoSSS.Foundation.DGField.EvaluateAlongLine(System.Double[],System.Double[],System.Int32) <a id="bosss.foundation.dgfield.evaluatealongline(system.double[],system.double[],system.int32)"></a>
**Summary:** Evaluates along a line prescribed by two points
**Parameter:** `p1` - 
**Parameter:** `p2` - 
**Parameter:** `nRef` - 
**Returns:**



## Method: BoSSS.Foundation.DGField._Acc``1(System.Double,``0,System.Int32,System.Int32,System.Boolean) <a id="bosss.foundation.dgfield._acc``1(system.double,``0,system.int32,system.int32,system.boolean)"></a>
**Summary:** adds a vector to the coordinates vector of this field;
Extended Options version;
**Parameter:** `x` - vector which is added to the coordinates of this field.
**Parameter:** `xSkip` - Skip (offset) into vector 'x';
**Parameter:** `xStride` - Stride of vector 'x';
**Parameter:** `OnlyLocalUpdated` - if true, only coordinates of locally updated cells are changed; if
false, also external cells are affected.
**Parameter:** `alpha` - scaling of 'x'


## Method: BoSSS.Foundation.DGField.CopyFrom(BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.copyfrom(bosss.foundation.dgfield)"></a>
**Summary:** initializes this field to be a (non-shallow) copy the field
'other'; The basis of the 'other'
field must be contained in the basis of this field (see
[BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis));
**Parameter:** `other` - 


## Method: BoSSS.Foundation.DGField.ScaleAndAcc(BoSSS.Foundation.DGField,System.Double) <a id="bosss.foundation.dgfield.scaleandacc(bosss.foundation.dgfield,system.double)"></a>
**Summary:** set this field to be the (weighted) average with the field
'other'; The basis of the 'other'
'alpha'; Optional: The weighting factor. 0.5 (default) for average, 1 for copy of other 'alpha'
field must be contained in the basis of this field (see
[BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis));


## Method: BoSSS.Foundation.DGField.Clear <a id="bosss.foundation.dgfield.clear"></a>
**Summary:** sets all coordinates of this field to 0;


## Method: BoSSS.Foundation.DGField.Clear(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.clear(bosss.foundation.grid.cellmask)"></a>
**Summary:** sets all coordinates of cells in '_cellMask' of this field to 0;
**Parameter:** `_cellMask` - optional specification of cell mask; null corresponds to all cells.


### Field: BoSSS.Foundation.DGField.m_Basis <a id="bosss.foundation.dgfield.m_basis"></a>
**Summary:** [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)


### Field: BoSSS.Foundation.DGField.m_Identification <a id="bosss.foundation.dgfield.m_identification"></a>
**Summary:** identification string


### Property: BoSSS.Foundation.DGField.Mapping <a id="bosss.foundation.dgfield.mapping"></a>
**Summary:** creates a new [BoSSS.Foundation.CoordinateMapping](#bosss.foundation.coordinatemapping) which contains only this field


### Property: BoSSS.Foundation.DGField.CoordinateVector <a id="bosss.foundation.dgfield.coordinatevector"></a>
**Summary:** creates a new [BoSSS.Foundation.DGField.CoordinateVector](#bosss.foundation.dgfield.coordinatevector) which contains the DG
coordinates of this field as one column vector


### Property: BoSSS.Foundation.DGField.Coordinates <a id="bosss.foundation.dgfield.coordinates"></a>
**Summary:** DG coordinates of this field;
**Remark:**
Indices:

1st index/row index: local cell index;

2nd index/column index: basis function index, corresponds with the order 
of polynomials
in the associated [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis), [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis).


## Method: BoSSS.Foundation.DGField.SerializeDGcoords(System.Int32) <a id="bosss.foundation.dgfield.serializedgcoords(system.int32)"></a>
**Summary:** Used to store this field in database, not for direct user interaction
**Parameter:** `j` - local cell index


## Method: BoSSS.Foundation.DGField.DeserializeDGcoords(System.Int32,System.Double[]) <a id="bosss.foundation.dgfield.deserializedgcoords(system.int32,system.double[])"></a>
**Summary:** Used to load this field from database, not for direct user interaction
**Parameter:** `j` - local cell index
**Parameter:** `coords_j` - DG data for cell 'j'


### Property: BoSSS.Foundation.DGField.Identification <a id="bosss.foundation.dgfield.identification"></a>
**Summary:** User given string identification for this field;


### Property: BoSSS.Foundation.DGField.Basis <a id="bosss.foundation.dgfield.basis"></a>
**Summary:** the Basis assigned to this field


### Property: BoSSS.Foundation.DGField.GridDat <a id="bosss.foundation.dgfield.griddat"></a>
**Summary:** the grid on which this DG field is defined


## Method: BoSSS.Foundation.DGField.ToString <a id="bosss.foundation.dgfield.tostring"></a>
**Summary:** returns the identification string of this field
**Returns:**



## Method: BoSSS.Foundation.DGField.CheckForNanOrInf(System.Boolean,System.Boolean,System.Boolean) <a id="bosss.foundation.dgfield.checkfornanorinf(system.boolean,system.boolean,system.boolean)"></a>
**Summary:** checks whether NAS's or INF's are present in this field
**Parameter:** `CheckForInf` - 
**Parameter:** `CheckForNan` - 
**Parameter:** `ExceptionIfFound` - if this is true, an ArithmeticException is thrown in case of a
positive result
**Returns:**
The GlobalId of the first cell (depending on the actual
GlobalID-Permutation [BoSSS.Foundation.Grid.IGridData.CurrentGlobalIdPermutation](#bosss.foundation.grid.igriddata.currentglobalidpermutation))
within the actual MPI-process in which an 'illegal value'
(depending on 'CheckForInf' and
'CheckForNan') is found; otherwise, a negative
number;


## Method: BoSSS.Foundation.DGField.Clone <a id="bosss.foundation.dgfield.clone"></a>
**Summary:** Creates a new object that is a copy of the current instance.
See **System.ICloneable.Clone**


## Method: BoSSS.Foundation.DGField.CloneAs <a id="bosss.foundation.dgfield.cloneas"></a>
**Summary:** Creates a new object that is a copy of the current instance.
See **System.ICloneable.Clone**
**Returns:**
A new object that is a copy of this instance.


## Method: BoSSS.Foundation.DGField.GetMPISendBufferSize(System.Int32) <a id="bosss.foundation.dgfield.getmpisendbuffersize(system.int32)"></a>
**Summary:** For MPI communication; 
Determines the size of the receive buffer that some [BoSSS.Foundation.Comm.Transceiver](#bosss.foundation.comm.transceiver)
must allocate;
**Parameter:** `proc` - 
**Returns:**
number of double's in the send buffer for processor 'proc';
**Remark:**
Of course, the size of the send buffer on this process
must be equal to the size of the receive buffer ([BoSSS.Foundation.DGField.GetMPIRecvBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpirecvbuffersize(system.int32)))
on process 'proc'. However, this is not tested, and a 
violation of this rule will possibly result in an MPI error.


## Method: BoSSS.Foundation.DGField.GetMPIRecvBufferSize(System.Int32) <a id="bosss.foundation.dgfield.getmpirecvbuffersize(system.int32)"></a>
**Summary:** For MPI communication; 
Determines the size of the receive buffer that some [BoSSS.Foundation.Comm.Transceiver](#bosss.foundation.comm.transceiver)
must allocate;
**Parameter:** `proc` - MPI processor rank.
**Returns:**
number of double's in the receive buffer for processor 'proc';
**Remark:**
Of course, the size of the receive buffer on this process
must be equal to the size of the send buffer ([BoSSS.Foundation.DGField.GetMPISendBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpisendbuffersize(system.int32)))
on process 'proc'. However, this is not tested, and a 
violation of this rule will possibly result in an MPI error.


## Method: BoSSS.Foundation.DGField.FillMPISendBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.dgfield.fillmpisendbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** Copies the DG coordinates which must be send to process
'proc' to the send buffer
('Buffer'); This coordinates are those of the
cells (with local index)
[BoSSS.Foundation.Grid.IParallelization.SendCommLists](#bosss.foundation.grid.iparallelization.sendcommlists)['proc'];
**Parameter:** `Buffer` - send buffer; the first item to send must be inserted at
index 'i0';
**Parameter:** `i0` - index offset into to the send buffer;
**Parameter:** `proc` - MPI processor rank of the process to send data to.
**Returns:**
The number of double's that were copied to **System.Buffer**,
equal to the return value of
[BoSSS.Foundation.DGField.GetMPISendBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpisendbuffersize(system.int32))('proc',...).


## Method: BoSSS.Foundation.DGField.CopyFromMPIrecvBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.dgfield.copyfrommpirecvbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** Copies the DG coordinates which were received from processor 'proc'
to the internal storage of this DG field.
**Parameter:** `proc` - MPI processor rank of the process from which data was received;
**Parameter:** `Buffer` - receive buffer; the first received item, which belongs to this DG field is 
located at index 'i0';
**Parameter:** `i0` - index offset into the 'Buffer'
**Returns:**
The number of double's that were copied from **System.Buffer**,
equal to the return value of [BoSSS.Foundation.DGField.GetMPIRecvBufferSize(System.Int32)](#bosss.foundation.dgfield.getmpirecvbuffersize(system.int32))('proc',...).


## Method: BoSSS.Foundation.DGField.MPIExchange <a id="bosss.foundation.dgfield.mpiexchange"></a>
**Summary:** MPI update of this field


## Method: BoSSS.Foundation.DGField.Scale(System.Double) <a id="bosss.foundation.dgfield.scale(system.double)"></a>
**Summary:** multiplies all DG coordinates of this field with a factor 'a';
**Parameter:** `a` - 


## Method: BoSSS.Foundation.DGField.Scale(System.Double,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.scale(system.double,bosss.foundation.grid.cellmask)"></a>
**Summary:** multiplies all DG coordinates of this field,
within the cells in cell mask 'cm', 
by a factor 'a';


## Method: BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield)"></a>
**Summary:** see [BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));
**Remark:**
the accumulation is performed in all cells;


## Method: BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates an other field, 'a'*'mult' to this field;
**Parameter:** `a` - 
**Parameter:** `mult` - 
**Parameter:** `cm` - optional cell mask, null indicates the whole domain
**Remark:**
the basis of 'a' and of this field must be equal!


## Method: BoSSS.Foundation.DGField.AccLaidBack(System.Double,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.acclaidback(system.double,bosss.foundation.dgfield)"></a>
**Summary:** see [BoSSS.Foundation.DGField.AccLaidBack(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.acclaidback(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.AccLaidBack(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.acclaidback(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** 'laxly' accumulation of another DG field to this field.
**Parameter:** `mult` - 
**Parameter:** `a` - 
**Parameter:** `cm` - optional cell mask, null indicates the whole domain
**Remark:**
in comparison to [BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)), the DG
basis of 'a' and this basis are not required to match exactly.


## Method: BoSSS.Foundation.DGField.AccConstant(System.Double) <a id="bosss.foundation.dgfield.accconstant(system.double)"></a>
**Summary:** adds the constant 'a' to this field.
**Parameter:** `a` - 


## Method: BoSSS.Foundation.DGField.AccConstant(System.Double,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.accconstant(system.double,bosss.foundation.grid.cellmask)"></a>
**Summary:** adds the constant 'a' to this field, but only within the cells in 'cm'.
**Parameter:** `a` - 
**Parameter:** `cm` - optional cell-mask; if null, the operation is carried out in all cells


## Method: BoSSS.Foundation.DGField.op_Addition(BoSSS.Foundation.DGField,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.op_addition(bosss.foundation.dgfield,bosss.foundation.dgfield)"></a>
**Summary:** adds two fields;
**Parameter:** `a` - 
**Parameter:** `b` - 
**Returns:**

**Remark:**
Using this method will allocate a new Field;
to avoid memory allocation, use [BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField)](#bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield));


## Method: BoSSS.Foundation.DGField.op_Subtraction(BoSSS.Foundation.DGField,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.op_subtraction(bosss.foundation.dgfield,bosss.foundation.dgfield)"></a>
**Summary:** subtracts two field;
**Parameter:** `a` - 
**Parameter:** `b` - 
**Returns:**

**Remark:**
Using this method will allocate a new Field;
to avoid memory allocation, use [BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField)](#bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield));


## Method: BoSSS.Foundation.DGField.op_Multiply(System.Double,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.op_multiply(system.double,bosss.foundation.dgfield)"></a>
**Summary:** multiplies a dg field with a constant
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Returns:**

**Remark:**
Using this method will allocate a new Field;
to avoid memory allocation, use [BoSSS.Foundation.DGField.Scale(System.Double)](#bosss.foundation.dgfield.scale(system.double));


## Method: BoSSS.Foundation.DGField.op_Multiply(BoSSS.Foundation.DGField,System.Double) <a id="bosss.foundation.dgfield.op_multiply(bosss.foundation.dgfield,system.double)"></a>
**Summary:** multiplies a dg field with a constant
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Returns:**

**Remark:**
Using this method will allocate a new Field;
to avoid memory allocation, use [BoSSS.Foundation.DGField.Scale(System.Double)](#bosss.foundation.dgfield.scale(system.double));


## Method: BoSSS.Foundation.DGField.op_Division(BoSSS.Foundation.DGField,System.Double) <a id="bosss.foundation.dgfield.op_division(bosss.foundation.dgfield,system.double)"></a>
**Summary:** multiplies a dg field by 1 over 'alpha'
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Returns:**

**Remark:**
Using this method will allocate a new Field;
to avoid memory allocation, use [BoSSS.Foundation.DGField.Scale(System.Double)](#bosss.foundation.dgfield.scale(system.double));


## Method: BoSSS.Foundation.DGField.ProjectAbs``1(System.Double,BoSSS.Foundation.VectorField{``0}) <a id="bosss.foundation.dgfield.projectabs``1(system.double,bosss.foundation.vectorfield{``0})"></a>
**Summary:** see [BoSSS.Foundation.DGField.ProjectAbs(System.Double,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.DGField[])](#bosss.foundation.dgfield.projectabs(system.double,bosss.foundation.grid.cellmask,bosss.foundation.dgfield[]));


## Method: BoSSS.Foundation.DGField.ProjectAbs(System.Double,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.dgfield.projectabs(system.double,bosss.foundation.grid.cellmask,bosss.foundation.dgfield[])"></a>
**Summary:** accumulates the projection of some vector field to this field, i.e.
\f[ 
this = this + \alpha \cdot \| \vec{vec} \|.
\f]
**Parameter:** `alpha` - factor $\alpha$
**Parameter:** `vec` - vector field $\vec{vec}$
**Parameter:** `em` - An optional restriction to the domain in which the projection is computed (it may, e.g.
be only required in boundary cells, so a computation over the whole domain 
would be a waste of computation power. If null, the computation is carried out in the whole domain;

## Class: BoSSS.Foundation.DGField.AbsSource <a id="bosss.foundation.dgfield.abssource"></a>

**Summary:** a nonlinear source, which takes the absolute value of some DG fields
used by [BoSSS.Foundation.DGField.ProjectAbs(System.Double,BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.DGField[])](#bosss.foundation.dgfield.projectabs(system.double,bosss.foundation.grid.cellmask,bosss.foundation.dgfield[]));


## Method: BoSSS.Foundation.DGField.AbsSource.#ctor(System.String[]) <a id="bosss.foundation.dgfield.abssource.#ctor(system.string[])"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.DGField.ProjectPow(System.Double,BoSSS.Foundation.DGField,System.Double) <a id="bosss.foundation.dgfield.projectpow(system.double,bosss.foundation.dgfield,system.double)"></a>
**Summary:** Accumulates the DG-projection (with respect to the DG-basis
of this field, [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)) of 
'alpha'*'f'^'pow' to this field;
**Parameter:** `alpha` - scaling for accumulation
**Parameter:** `f` - operand
**Parameter:** `pow` - exponent


## Method: BoSSS.Foundation.DGField.ProjectPow(System.Double,BoSSS.Foundation.DGField,System.Double,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.projectpow(system.double,bosss.foundation.dgfield,system.double,bosss.foundation.grid.cellmask)"></a>
**Summary:** Accumulates the DG-projection (with respect to the DG-basis
of this field, [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)) of 
'alpha'*'f'^'pow' to this field;
**Parameter:** `alpha` - scaling for accumulation
**Parameter:** `f` - operand
**Parameter:** `pow` - exponent
**Parameter:** `em` - An optional restriction to the domain in which the projection is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computation
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain;

## Class: BoSSS.Foundation.DGField.PowSource <a id="bosss.foundation.dgfield.powsource"></a>

**Summary:** a nonlinear source, which takes the power of some DG field, 
used by [BoSSS.Foundation.DGField.ProjectPow(System.Double,BoSSS.Foundation.DGField,System.Double,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.projectpow(system.double,bosss.foundation.dgfield,system.double,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.PowSource.#ctor(System.Double) <a id="bosss.foundation.dgfield.powsource.#ctor(system.double)"></a>
**Summary:** no text.
**Parameter:** `pow` - exponent


## Method: BoSSS.Foundation.DGField.PowSource.Source(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.powsource.source(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** multiplication of 'U'[0] and 'U'[1].


### Property: BoSSS.Foundation.DGField.PowSource.ArgumentOrdering <a id="bosss.foundation.dgfield.powsource.argumentordering"></a>
**Summary:** always equal to { "a", "b" }, i.e. the variables that are multiplied.


### Property: BoSSS.Foundation.DGField.PowSource.ParameterOrdering <a id="bosss.foundation.dgfield.powsource.parameterordering"></a>
**Summary:** no parameters, always null.

## Class: BoSSS.Foundation.DGField.ProjectFunctionSource <a id="bosss.foundation.dgfield.projectfunctionsource"></a>

**Summary:** used by [BoSSS.Foundation.DGField.ProjectFunction(System.Double,System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double},BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.DGField[])](#bosss.foundation.dgfield.projectfunction(system.double,system.func{ilpsp.vector,system.double[],system.int32,system.double},bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.dgfield[]))


### Field: BoSSS.Foundation.DGField.ProjectFunctionSource.Dom <a id="bosss.foundation.dgfield.projectfunctionsource.dom"></a>
**Summary:** Domain variables


### Field: BoSSS.Foundation.DGField.ProjectFunctionSource.m_f <a id="bosss.foundation.dgfield.projectfunctionsource.m_f"></a>
**Summary:** The function to be applied.


## Method: BoSSS.Foundation.DGField.ProjectFunctionSource.#ctor(System.String[],System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double}) <a id="bosss.foundation.dgfield.projectfunctionsource.#ctor(system.string[],system.func{ilpsp.vector,system.double[],system.int32,system.double})"></a>
**Summary:** Constructs a new source
**Parameter:** `_Dom` - Domain variables.
**Parameter:** `f` - The function to be applied.


### Property: BoSSS.Foundation.DGField.ProjectFunctionSource.ArgumentOrdering <a id="bosss.foundation.dgfield.projectfunctionsource.argumentordering"></a>
**Summary:** The domain variables, see
[BoSSS.Foundation.DGField.ProjectFunctionSource.#ctor(System.String[],System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double})](#bosss.foundation.dgfield.projectfunctionsource.#ctor(system.string[],system.func{ilpsp.vector,system.double[],system.int32,system.double}))


### Property: BoSSS.Foundation.DGField.ProjectFunctionSource.ParameterOrdering <a id="bosss.foundation.dgfield.projectfunctionsource.parameterordering"></a>
**Summary:** Empty


## Method: BoSSS.Foundation.DGField.ProjectFunctionSource.Source(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.projectfunctionsource.source(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Applies the given in each evaluation point.
**Parameter:** `time` - 
**Parameter:** `_x` - 
**Parameter:** `_U` - 
**Parameter:** `IndexOffset` - 
**Parameter:** `j0` - 
**Parameter:** `Lenght` - 
**Parameter:** `Output` - 


## Method: BoSSS.Foundation.DGField.ProjectFunction(System.Double,System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double},BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.dgfield.projectfunction(system.double,system.func{ilpsp.vector,system.double[],system.int32,system.double},bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.dgfield[])"></a>
**Summary:** accumulates
'alpha'*'f'('U')
to this field;
**Parameter:** `alpha` - scaling
**Parameter:** `f` -
some function
- 1st argument: position in physical space
- 2nd argument: values of fields in 'U' at respective position
- 3rd argument: cell index
- return value: value of function that should be projected at the respective position
**Parameter:** `cqs` - cell quadrature scheme: domain and quadrature rule
**Parameter:** `U` - arguments for 'f'


## Method: BoSSS.Foundation.DGField.ProjectProduct(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.projectproduct(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield)"></a>
**Summary:** projects the product of DG fields 'a'
and 'b' onto this field;
**Parameter:** `a` - 1st multiplicand
**Parameter:** `b` - 2nd multiplicand
**Parameter:** `alpha` - scaling for 'a'*'b'


## Method: BoSSS.Foundation.DGField.ProjectProduct(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.projectproduct(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** Accumulates the DG-projection (with respect to the DG-basis
of this field, [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)) of 
'alpha'*'a'*'b' to this field;
**Parameter:** `a` - 1st multiplicand
**Parameter:** `b` - 2nd multiplicand
**Parameter:** `alpha` - scaling for 'a'*'b'
**Parameter:** `em` - An optional restriction to the domain in which the projection is computed (it may, e.g.
be only required in boundary cells, so a computation over the whole domain 
would be a waste of computation power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain;


## Method: BoSSS.Foundation.DGField.ProjectProduct(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.dgfield.projectproduct(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Calculates the DG-projection (with respect to the DG-basis
of this field, [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)) of 
'alpha'*'a'*'b'
and, depending on the value of 'accumulateResult',
either adds or assigns it to this field.
**Parameter:** `a` - 1st multiplicand
**Parameter:** `b` - 2nd multiplicand
**Parameter:** `alpha` - scaling for 'a'*'b'
**Parameter:** `em` - An optional restriction to the domain in which the projection is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain;
**Parameter:** `accumulateResult` - Tells this method whether to accumulate (true) or not (false)

## Class: BoSSS.Foundation.DGField.MultiplySource <a id="bosss.foundation.dgfield.multiplysource"></a>

**Summary:** a nonlinear source, which multiplies two DG fields, used by
[BoSSS.Foundation.DGField.ProjectProduct(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.projectproduct(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.MultiplySource.Source(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.multiplysource.source(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** multiplication of 'U'[0] and 'U'[1].


### Property: BoSSS.Foundation.DGField.MultiplySource.ArgumentOrdering <a id="bosss.foundation.dgfield.multiplysource.argumentordering"></a>
**Summary:** always equal to { "a", "b" }, i.e. the variables that are multiplied.


### Property: BoSSS.Foundation.DGField.MultiplySource.ParameterOrdering <a id="bosss.foundation.dgfield.multiplysource.parameterordering"></a>
**Summary:** no parameters, always null.


## Method: BoSSS.Foundation.DGField.ProjectQuotient(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.projectquotient(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield)"></a>
**Summary:** projects the quotient of DG fields 'a'
and 'b' times 'alpha' onto this field;
**Parameter:** `a` - 
**Parameter:** `b` - 
**Parameter:** `alpha` - scaling


## Method: BoSSS.Foundation.DGField.ProjectQuotient(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.dgfield.projectquotient(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Calculates the DG-projection (with respect to the DG-basis
of this field, [BoSSS.Foundation.DGField.Basis](#bosss.foundation.dgfield.basis)) of 
'alpha'*'a'/'b'
and, depending on the value of 'accumulateResult',
either adds or assigns it to this field.
**Parameter:** `a` - 1st multiplicand
**Parameter:** `b` - 2nd multiplicand
**Parameter:** `alpha` - scaling for 'a'*'b'
**Parameter:** `accumulateResult` - Tells this method whether to accumulate (true) or not (false)
**Parameter:** `cm` - optional restriction to computational domain

## Class: BoSSS.Foundation.DGField.QuotientSource <a id="bosss.foundation.dgfield.quotientsource"></a>

**Summary:** a nonlinear source, which multiplies tow DG fields, used by
[BoSSS.Foundation.DGField.ProjectProduct(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.projectproduct(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.QuotientSource.Source(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.quotientsource.source(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** 'U'[0] / 'U'[1]


### Property: BoSSS.Foundation.DGField.QuotientSource.ArgumentOrdering <a id="bosss.foundation.dgfield.quotientsource.argumentordering"></a>
**Summary:** always equal to { "a", "b" }, i.e. the variables form which the
fraction a/b is computed.


### Property: BoSSS.Foundation.DGField.QuotientSource.ParameterOrdering <a id="bosss.foundation.dgfield.quotientsource.parameterordering"></a>
**Summary:** no parameters, always null.


## Method: BoSSS.Foundation.DGField.Laplacian(System.Double,BoSSS.Foundation.DGField) <a id="bosss.foundation.dgfield.laplacian(system.double,bosss.foundation.dgfield)"></a>
**Summary:** accumulates the Laplacian of field 'f' times
'alpha' to this field.
**Remark:**
see [BoSSS.Foundation.DGField.Laplacian(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.laplacian(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.Laplacian(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.laplacian(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates the Laplacian of field 'f' times
'alpha' to this field.
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Parameter:** `em` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask for this case would be e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain
**Remark:**
This method is based on
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask)), i.e.
it calculates derivatives by analytic cell-by-cell derivation of
the DG polynomials; Note that of the Laplacian requires the
allocation of a temporary DG field.


## Method: BoSSS.Foundation.DGField.LaplacianByFlux(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfield.laplacianbyflux(system.double,bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** accumulates the Laplacian of field 'f' times
'alpha' to this field.
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Parameter:** `optionalSubGrid` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)

if null, the computation is carried out in the whole domain.
**Parameter:** `tmp` - temporary storage needed for the 1st derivatives of
'f'; If null, a clone of 'f'
is taken.
**Parameter:** `bndMode_1stDeriv` - 
**Parameter:** `bndMode_2ndDeriv` - 
**Remark:**
This method is based on [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)),
i.e. it calculates derivatives by central-difference fluxes;
Note that of the Laplacian requires the allocation of a temporary DG field.


## Method: BoSSS.Foundation.DGField.Divergence``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.divergence``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates the broken divergence of vector field 'vec'
times 'alpha' to this field.
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Parameter:** `em` - 
**Remark:**
This method is based on [BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask));


## Method: BoSSS.Foundation.DGField.DivergenceByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfield.divergencebyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** accumulates the central difference divergence of vector field 'vec'
times 'alpha'
to this field.
**Remark:**
This method is based on [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes));


## Method: BoSSS.Foundation.DGField.Curl2D``1(System.Double,BoSSS.Foundation.VectorField{``0}) <a id="bosss.foundation.dgfield.curl2d``1(system.double,bosss.foundation.vectorfield{``0})"></a>
**Summary:** accumulates the curl of 2D DG vector field 'vec' 
times 'alpha'
to this vector field, i.e. 
this = this + 'alpha'* Curl('vec')
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Remark:**
This method is based on
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32)), i.e. it
calculates derivatives by analytic cell-by-cell derivation of the
DG polynomials;


## Method: BoSSS.Foundation.DGField.Curl2D``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.curl2d``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates the curl of a 2D DG vector field 'vec' 
times 'alpha'
to this vector field, i.e. 
this = this + 'alpha'* Curl('vec')
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Parameter:** `em` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask for this case would be e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain
**Remark:**
This method is based on
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32)), i.e. it
calculates derivatives by analytic cell-by-cell derivation of the
DG polynomials;


## Method: BoSSS.Foundation.DGField.Curl2DByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfield.curl2dbyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** accumulates the curl of 2D DG vector field 'vec' 
times 'alpha'
to this vector field, i.e. 
this = this + 'alpha'* Curl('vec')
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Parameter:** `optionalSubGrid` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)

if null, the computation is carried out in the whole domain.
**Parameter:** `bndMode` - 
**Remark:**
This method is based on [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)), i.e.
it calculates derivatives by central-difference fluxes;


## Method: BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32) <a id="bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32)"></a>
**Summary:** accumulates the derivative of DG field 'f' 
(along the 'd'-th axis) times 'alpha'
to this field, i.e. 
this = this + 'alpha'* $\frac{\partial}{\partial x_d}$ 'f';
**Parameter:** `f` - 
**Parameter:** `d` - 0 for the x-derivative, 1 for the y-derivative, 2 for the z-derivative
**Parameter:** `alpha` - scaling of 'f';


## Method: BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask)"></a>
**Summary:** broken derivative, cell-by-cell;
accumulates the derivative of DG field 'f' 
(along the 'd'-th axis) times 'alpha'
to this field, i.e. 
this = this + 'alpha'
$\cdot \frac{\partial}{\partial x_d}$ 'f';
**Parameter:** `f` - 
**Parameter:** `d` - 0 for the x-derivative, 1 for the y-derivative, 2 for the
z-derivative
**Parameter:** `alpha` - scaling of 'f';
**Parameter:** `em` - An optional restriction to the domain in which the derivative is
computed; If null, the computation is carried out in the entire domain.

(it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask for this case would be e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
**Remark:**
The derivative is calculated by a cell-by-cell (symbolic)
derivation of the DG polynomials, therefor the (effective) DG
polynomial degree is one lower than the degree of
'f';
In comparison to [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)), this method should
be much faster, because no quadrature is involved;


## Method: BoSSS.Foundation.DGField.CreateDerivativeFlux(System.Int32,System.String) <a id="bosss.foundation.dgfield.createderivativeflux(system.int32,system.string)"></a>
**Summary:** used by [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)) to create an instance of
[BoSSS.Foundation.DGField.DerivativeFlux](#bosss.foundation.dgfield.derivativeflux); Override this method to use
[BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)) with your own flux implementation.
**Parameter:** `d` - spatial direction of the derivation: 0 for derivation in
x-direction, 1 for y-direction, ...
**Parameter:** `Identification` - not used
**Returns:**


## Class: BoSSS.Foundation.DGField.DerivativeFlux <a id="bosss.foundation.dgfield.derivativeflux"></a>

**Summary:** A flux to compute du/dx, used by [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes));


## Method: BoSSS.Foundation.DGField.DerivativeFlux.#ctor(System.Int32) <a id="bosss.foundation.dgfield.derivativeflux.#ctor(system.int32)"></a>
**Parameter:** `d` - spatial direction of the derivation: 0 for derivation in
x-direction, 1 for y-direction, ...


### Field: BoSSS.Foundation.DGField.DerivativeFlux.m_d <a id="bosss.foundation.dgfield.derivativeflux.m_d"></a>
**Summary:** spatial direction of the derivation: 0 for derivation in
x-direction, 1 for y-direction, ...


## Method: BoSSS.Foundation.DGField.DerivativeFlux.BorderEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Boolean,System.Byte[],System.Int32,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.derivativeflux.borderedgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.boolean,system.byte[],system.int32,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.INonlinearFlux.BorderEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Boolean,System.Byte[],System.Int32,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.inonlinearflux.borderedgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.boolean,system.byte[],system.int32,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.DGField.DerivativeFlux.InnerEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.derivativeflux.inneredgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** A central-difference flux for computing the
[BoSSS.Foundation.DGField.DerivativeFlux.m_d](#bosss.foundation.dgfield.derivativeflux.m_d)-th derivative;
see [BoSSS.Foundation.INonlinearFlux.InnerEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.inonlinearflux.inneredgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray))


## Method: BoSSS.Foundation.DGField.DerivativeFlux.Flux(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.derivativeflux.flux(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** see [BoSSS.Foundation.INonlinearFlux.Flux(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray)](#bosss.foundation.inonlinearflux.flux(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray))


### Property: BoSSS.Foundation.DGField.DerivativeFlux.ArgumentOrdering <a id="bosss.foundation.dgfield.derivativeflux.argumentordering"></a>
**Summary:** see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)


### Property: BoSSS.Foundation.DGField.DerivativeFlux.ParameterOrdering <a id="bosss.foundation.dgfield.derivativeflux.parameterordering"></a>
**Summary:** see [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering)


## Method: BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** accumulates the derivative of DG field 'f' 
(along the 'd'-th axis) times 'alpha'
to this field, i.e. 
this = this + 'alpha'* $\frac{\partial}{\partial x_d}$ 'f';
**Parameter:** `f` - 
**Parameter:** `d` - 0 for the x-derivative, 1 for the y-derivative, 2 for the
z-derivative
**Parameter:** `alpha` - scaling of 'f';
**Parameter:** `optionalSubGrid` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)

if null, the computation is carried out in the whole domain.
**Parameter:** `bndMode` - if a sub-grid is provided, this determines how the sub-grid
boundary should be treated.
**Remark:**
The derivative is calculated using Riemann flux functions
(central difference);

In comparison to
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask)), this method
should be slower, but produce more sane results, especially for
fields of low polynomial degree (0 or 1);


## Method: BoSSS.Foundation.DGField.EvaluateInternal(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,BoSSS.Foundation.Basis,ilPSP.MultidimensionalArray,System.Int32,ilPSP.MultidimensionalArray,System.Double) <a id="bosss.foundation.dgfield.evaluateinternal(system.int32,system.int32,bosss.foundation.nodeset,bosss.foundation.basis,ilpsp.multidimensionalarray,system.int32,ilpsp.multidimensionalarray,system.double)"></a>
**Summary:** evaluation of DG field; may be used in derived classes to implement [BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double)](#bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)).


## Method: BoSSS.Foundation.DGField.EvaluateGradientInternal(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,BoSSS.Foundation.Basis,ilPSP.MultidimensionalArray,System.Int32,ilPSP.MultidimensionalArray,System.Double) <a id="bosss.foundation.dgfield.evaluategradientinternal(system.int32,system.int32,bosss.foundation.nodeset,bosss.foundation.basis,ilpsp.multidimensionalarray,system.int32,ilpsp.multidimensionalarray,system.double)"></a>
**Summary:** evaluation of DG field gradient; may be used in derived classes to implement [BoSSS.Foundation.DGField.EvaluateGradient(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double)](#bosss.foundation.dgfield.evaluategradient(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)).


## Method: BoSSS.Foundation.DGField.CellExtrapolation``2(System.Int32[0:,0:],``0,``1) <a id="bosss.foundation.dgfield.cellextrapolation``2(system.int32[0:,0:],``0,``1)"></a>
**Summary:** Polynomial extrapolation between cells.
**Parameter:** `CellPairs` - A list of which cells should be extrapolated to which cells. 
1st index: enumeration;
2nd index, in the range of 0 to 1: 0: cell to extrapolate from (source), i.e. values in this cell remain unchanged.
1: cell to extrapolate to (target), the values in this cell will be the polynomial continuation of the "cell to extrapolate from".
**Parameter:** `scl` - optional scaling for the target cells
**Parameter:** `beta` - optional input scaling scaling for the target cells


## Method: BoSSS.Foundation.DGField.CellExtrapolation(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.cellextrapolation(bosss.foundation.grid.cellmask,bosss.foundation.grid.cellmask)"></a>
**Summary:** Polynomial extrapolation between cells.
**Parameter:** `ExtrapolateTo` - contains all cells for which extrapolated values should be computed
**Parameter:** `ExtrapolateFrom` - contains all cells with "known values"
**Returns:**
The number of cells (locally) for which the algorithm was not able to extrapolate a value


### Property: BoSSS.Foundation.DGField.Initializer <a id="bosss.foundation.dgfield.initializer"></a>
**Summary:** To support IO-architecture, NOT for direct user interaction. 
Note that it is essential that this member always returns the SAME
object (reference-equals)!

## Class: BoSSS.Foundation.DGField.FieldInitializer <a id="bosss.foundation.dgfield.fieldinitializer"></a>

**Summary:** Represents a set of information about a field that sufficient for
its recreation, i.e. during deserialization.


### Field: BoSSS.Foundation.DGField.FieldInitializer.BasisInfo <a id="bosss.foundation.dgfield.fieldinitializer.basisinfo"></a>
**Summary:** Information about the basis.


### Field: BoSSS.Foundation.DGField.FieldInitializer.Identification <a id="bosss.foundation.dgfield.fieldinitializer.identification"></a>
**Summary:** The name of the field


## Method: BoSSS.Foundation.DGField.FieldInitializer.Equals(BoSSS.Foundation.IO.Initializer{BoSSS.Foundation.DGField}) <a id="bosss.foundation.dgfield.fieldinitializer.equals(bosss.foundation.io.initializer{bosss.foundation.dgfield})"></a>
**Summary:** Must be overridden.


## Method: BoSSS.Foundation.DGField.FieldInitializer.GetHashCode <a id="bosss.foundation.dgfield.fieldinitializer.gethashcode"></a>
**Summary:** Must be overridden.


## Method: BoSSS.Foundation.DGField.LoadData(BoSSS.Foundation.IO.ITimestepInfo,System.Collections.Generic.IList{BoSSS.Foundation.IO.CellFieldDataSet},System.Collections.Generic.HashSet{System.Object}) <a id="bosss.foundation.dgfield.loaddata(bosss.foundation.io.itimestepinfo,system.collections.generic.ilist{bosss.foundation.io.cellfielddataset},system.collections.generic.hashset{system.object})"></a>
**Summary:** Supports the loading of DG fields from database, not intended for
direct user interaction.


## Method: BoSSS.Foundation.DGField.ReportDependentFields <a id="bosss.foundation.dgfield.reportdependentfields"></a>
**Summary:** To support the database loading architecture, not for direct user
interaction. Example use case: an XDG field reports the level sets
it depends on.


## Method: BoSSS.Foundation.DGField.InnerProduct(BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.innerproduct(bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** computes the inner product of fields 'a' and 'b'

## Class: BoSSS.Foundation.DGField.InnerProductQuadrature <a id="bosss.foundation.dgfield.innerproductquadrature"></a>

**Summary:** quadrature that calculates inner product of two fields, see [BoSSS.Foundation.DGField.InnerProduct(BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Quadrature.CellQuadratureScheme)](#bosss.foundation.dgfield.innerproduct(bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.quadrature.cellquadraturescheme))


## Method: BoSSS.Foundation.DGField.InnerProductQuadrature.#ctor(BoSSS.Foundation.DGField,BoSSS.Foundation.DGField,BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Int32) <a id="bosss.foundation.dgfield.innerproductquadrature.#ctor(bosss.foundation.dgfield,bosss.foundation.dgfield,bosss.foundation.quadrature.cellquadraturescheme,system.int32)"></a>
**Summary:** ctor
**Parameter:** `a` - 1st field
**Parameter:** `b` - 2nd field
**Parameter:** `quaddegree` - for the quadrature rule to chose, the 
the degree of a polynomial that can be exactly integrated;
**Parameter:** `quadScheme` - 


## Method: BoSSS.Foundation.DGField.GetExtremalValues(System.Double@,System.Double@) <a id="bosss.foundation.dgfield.getextremalvalues(system.double@,system.double@)"></a>
**Summary:** see [BoSSS.Foundation.DGField.GetExtremalValues(System.Double@,System.Double@,System.Int64@,System.Int64@,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.getextremalvalues(system.double@,system.double@,system.int64@,system.int64@,bosss.foundation.grid.cellmask));


### Field: BoSSS.Foundation.DGField.m_ExtremalProbeNS <a id="bosss.foundation.dgfield.m_extremalprobens"></a>
**Summary:** used by [BoSSS.Foundation.DGField.GetExtremalValues(System.Double@,System.Double@,System.Int64@,System.Int64@,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.getextremalvalues(system.double@,system.double@,system.int64@,system.int64@,bosss.foundation.grid.cellmask)) and [BoSSS.Foundation.DGField.GetExtremalValuesInCell(System.Double@,System.Double@,System.Int32)](#bosss.foundation.dgfield.getextremalvaluesincell(system.double@,system.double@,system.int32))
to find the extremal values in


## Method: BoSSS.Foundation.DGField.GetExtremalValuesInCell(System.Double@,System.Double@,System.Int32) <a id="bosss.foundation.dgfield.getextremalvaluesincell(system.double@,system.double@,system.int32)"></a>
**Summary:** Finds minimum and maximum value in cell 'jL'.
**Parameter:** `min` - On exit, the minimum value.
**Parameter:** `max` - On exit, the maximum value.
**Parameter:** `jL` - Local cell index.


## Method: BoSSS.Foundation.DGField.GetExtremalValues(System.Double@,System.Double@,System.Int64@,System.Int64@,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.getextremalvalues(system.double@,system.double@,system.int64@,system.int64@,bosss.foundation.grid.cellmask)"></a>
**Summary:** Returns the minimum and the maximum value of the DG field
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Parameter:** `max` - on all invoking MPI processes, the maximum value (over all processors) of
this field;
**Parameter:** `min` - on all invoking MPI processes, the minimum value (over all processors) of
this field;
**Parameter:** `cm` - optional domain restriction
**Parameter:** `jMaxGlob` - global cell index in which the maximum value 'max' was found
**Parameter:** `jMinGlob` - global cell index in which the maximum value 'min' was found
**Remark:**
to find the maximum value, this field is evaluated on each vertex and the center of the simplex.


## Method: BoSSS.Foundation.DGField.GetCellwiseExtremalValues``2(``0,``1,BoSSS.Foundation.Grid.CellMask,System.Func{System.Double,System.Double}) <a id="bosss.foundation.dgfield.getcellwiseextremalvalues``2(``0,``1,bosss.foundation.grid.cellmask,system.func{system.double,system.double})"></a>
**Summary:** Returns the minimum and the maximum value of 'mod'(this DG field), for each cell;
**Parameter:** `max` - Vector, with the same number of entries as the cell mask 'cm';
On exit, the approximate local maximum within the cell.
**Parameter:** `min` - Vector, with the same number of entries as the cell mask 'cm';
On exit, the approximate local minimum within the cell.
**Parameter:** `cm` - optional domain restriction
**Parameter:** `mod` - optimal modifier, which e.g. may select the absolute value; if null, the identity function;


## Method: BoSSS.Foundation.DGField.L2Error(BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask,System.Boolean) <a id="bosss.foundation.dgfield.l2error(bosss.foundation.dgfield,bosss.foundation.grid.cellmask,system.boolean)"></a>
**Summary:** Computes L2 distance between this field and
'other'
**Parameter:** `other` - 
**Parameter:** `cm` - Optional restriction of domain
**Parameter:** `overrideGridCheck` - If this parameter is set to true, the error will be computed even
though [BoSSS.Foundation.DGField.GridDat](#bosss.foundation.dgfield.griddat) is not identical for both
fields. Only do so if you are really sure that the grids are still
equivalent.


## Method: BoSSS.Foundation.DGField.L2Error(BoSSS.Foundation.ScalarFunction,System.Int32,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.l2error(bosss.foundation.scalarfunction,system.int32,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Computes L2 measure with default quadrature


## Method: BoSSS.Foundation.DGField.L2ErrorNoMean(BoSSS.Foundation.ScalarFunction,System.Int32,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.l2errornomean(bosss.foundation.scalarfunction,system.int32,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Computes L2 distance, **ignoring any constant offset** (e.g. for comparing floating pressures) with default quadrature


## Method: BoSSS.Foundation.DGField.L2Error(BoSSS.Foundation.ScalarFunction,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.dgfield.l2error(bosss.foundation.scalarfunction,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Computes L2 measure with default quadrature
**Parameter:** `function` - 
**Parameter:** `scheme` - 
**Returns:**



## Method: BoSSS.Foundation.DGField.LxError(BoSSS.Foundation.ScalarFunction,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},System.Int32) <a id="bosss.foundation.dgfield.lxerror(bosss.foundation.scalarfunction,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},system.int32)"></a>
**Summary:** This call computes an integral measure which may depend on 
this [BoSSS.Foundation.DGField](#bosss.foundation.dgfield) an the given 'function';
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Parameter:** `function` - Optional: Reference function for error computation. If null, zero
is taken as the reference function
**Parameter:** `rule` - composite quadrature rule.
**Parameter:** `Map` - Arbitrary mapping applied to the values of this field and
'function' at some point, which is finally integrated.
E.g., the mapping for an L2-error would be $(\vec{x},a,b) => (a - b)^2$, 
where $a$ is the value of this field at some point $\vec{x}$ and
$b$ is the value of 'function' at $\vec{x}$.
**Parameter:** `Quadrature_ChunkDataLimitOverride` - only for debugging purpose,
see [BoSSS.Foundation.Quadrature.Quadrature`2.ChunkDataLimitOverride](#bosss.foundation.quadrature.quadrature`2.chunkdatalimitoverride)
**Returns:**
on all invoking MPI processes, the L2 norm of
this field minus 'function', approximated by the
quadrature rule 'rule'


## Method: BoSSS.Foundation.DGField.LxError(BoSSS.Foundation.ScalarFunctionEx,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.lxerror(bosss.foundation.scalarfunctionex,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** This call computes an integral measure which may depend on 
this [BoSSS.Foundation.DGField](#bosss.foundation.dgfield) an the given 'function';
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Parameter:** `function` - 
**Parameter:** `rule` - composite quadrature rule.
**Parameter:** `Map` - Arbiter mapping applied to the values of this field and
'function' at some point, which is finally integrated.
E.g., the mapping for an L2-error would be $(\vec{x},a,b) => (a - b)^2$, 
where $a$ is the value of this field at some point $\vec{x}$ and
$b$ is the value of 'function' at $\vec{x}$.
**Returns:**
on all invoking MPI processes, the L2 norm of
this field minus 'function'


## Method: BoSSS.Foundation.DGField.LocalLxError(BoSSS.Foundation.ScalarFunction,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.locallxerror(bosss.foundation.scalarfunction,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Variant of
[BoSSS.Foundation.DGField.LxError(BoSSS.Foundation.ScalarFunction,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},System.Int32)](#bosss.foundation.dgfield.lxerror(bosss.foundation.scalarfunction,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},system.int32))
that computes the cell-local Lx norm (and does thus not include MPI
communication)
**Parameter:** `function` - Optional: Reference function for error computation. If null, zero
is taken as the reference function
**Parameter:** `quadRule` - composite quadrature rule.
**Parameter:** `Map` - Arbitrary mapping applied to the values of this field and
'function' at some point, which is finally
integrated. E.g., the mapping for an L2-error would be
$(a,b) => (a - b)^2$, where $a$ is the value of this
field at some point $\vec{x}$ and $b$ is the value of
'function' at $\vec{x}$.
**Returns:**
The cell-local Lx norm of this field minus
'function', approximated by the quadrature rule
'quadRule'


## Method: BoSSS.Foundation.DGField.JumpNorm(BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.dgfield.jumpnorm(bosss.foundation.grid.edgemask)"></a>
**Summary:** computes the jump norm of this field at edges in'innerEM'
**Parameter:** `innerEM` - if null full mask is chosen


## Method: BoSSS.Foundation.DGField.L2Norm <a id="bosss.foundation.dgfield.l2norm"></a>
**Summary:** L2 - norm of this field;
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;


## Method: BoSSS.Foundation.DGField.L2Norm(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.l2norm(bosss.foundation.grid.cellmask)"></a>
**Summary:** L2 - norm of this field;
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Parameter:** `CM` - optional cell mask
**Returns:**
on all invoking MPI processes, the L2 norm of
this field;


## Method: BoSSS.Foundation.DGField.L1Norm <a id="bosss.foundation.dgfield.l1norm"></a>
**Summary:** L1 - norm of this field;
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;


## Method: BoSSS.Foundation.DGField.L1Norm(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.l1norm(bosss.foundation.grid.cellmask)"></a>
**Summary:** L1 - norm of this field;
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Parameter:** `CM` - optional cell mask
**Returns:**
on all invoking MPI processes, the L1 norm of
this field;


## Method: BoSSS.Foundation.DGField.LinfNorm(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.linfnorm(bosss.foundation.grid.cellmask)"></a>
**Summary:** L-infinity - norm of this field;
This is a collective call, it must be invoked by all 
MPI processes within the communicator; internally, it invokes MPI_Allreduce;
**Returns:**
on all invoking MPI processes, the L-inv norm of
this field (over all processors);
**Remark:**
to find the maximum value, this field is evaluated on each vertex and the center of the simplex.

## Class: BoSSS.Foundation.DGField.LxNormQuadrature <a id="bosss.foundation.dgfield.lxnormquadrature"></a>

**Summary:** quadrature that calculates some norm such as the L2 norm


## Method: BoSSS.Foundation.DGField.LxNormQuadrature.#ctor(BoSSS.Foundation.DGField,BoSSS.Foundation.ScalarFunction,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.lxnormquadrature.#ctor(bosss.foundation.dgfield,bosss.foundation.scalarfunction,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** ctor.


## Method: BoSSS.Foundation.DGField.LxNormQuadrature.#ctor(BoSSS.Foundation.DGField,BoSSS.Foundation.ScalarFunctionEx,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.dgfield.lxnormquadrature.#ctor(bosss.foundation.dgfield,bosss.foundation.scalarfunctionex,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** ctor.


### Field: BoSSS.Foundation.DGField.LxNormQuadrature.m_NodesTransformed <a id="bosss.foundation.dgfield.lxnormquadrature.m_nodestransformed"></a>
**Summary:** 1st index: cell index (minus some offset);
2nd index: node index;
3rd index; spatial coordinate;


## Method: BoSSS.Foundation.DGField.LxNormQuadrature.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.Quadrature.QuadRule,ilPSP.MultidimensionalArray) <a id="bosss.foundation.dgfield.lxnormquadrature.evaluate(system.int32,system.int32,bosss.foundation.quadrature.quadrule,ilpsp.multidimensionalarray)"></a>
**Summary:** Integrand evaluation.


### Property: BoSSS.Foundation.DGField.LxNormQuadrature.LxNorm <a id="bosss.foundation.dgfield.lxnormquadrature.lxnorm"></a>
**Summary:** returns the L2 Norm to the power of 2

## Class: BoSSS.Foundation.DGField.LocalLxNormQuadrature <a id="bosss.foundation.dgfield.locallxnormquadrature"></a>

**Summary:** Quadrature for
[BoSSS.Foundation.DGField.LocalLxError(BoSSS.Foundation.ScalarFunction,System.Func{System.Double[],System.Double,System.Double,System.Double},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule})](#bosss.foundation.dgfield.locallxerror(bosss.foundation.scalarfunction,system.func{system.double[],system.double,system.double,system.double},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule}))


## Method: BoSSS.Foundation.DGField.IntegralOver(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfield.integralover(bosss.foundation.grid.cellmask)"></a>
**Summary:** integrates this field over the domain specified in 'volumemask'
**Parameter:** `volumemask` - an optional volume mask; if null, the whole grid is taken;

## Class: BoSSS.Foundation.DGField.IntegralOverExQuadrature <a id="bosss.foundation.dgfield.integraloverexquadrature"></a>

**Summary:** used by method [BoSSS.Foundation.DGField.IntegralOverEx(BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double},System.Int32,BoSSS.Foundation.DGField[])](#bosss.foundation.dgfield.integraloverex(bosss.foundation.quadrature.cellquadraturescheme,system.func{ilpsp.vector,system.double[],system.int32,system.double},system.int32,bosss.foundation.dgfield[]))


## Method: BoSSS.Foundation.DGField.IntegralOverEx(BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Func{ilPSP.Vector,System.Double[],System.Int32,System.Double},System.Int32,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.dgfield.integraloverex(bosss.foundation.quadrature.cellquadraturescheme,system.func{ilpsp.vector,system.double[],system.int32,system.double},system.int32,bosss.foundation.dgfield[])"></a>
**Summary:** integrates some arbitrary function 'f' (which
depends on DG fields 'Fields') over some domain
implied by 'scheme'
**Parameter:** `scheme` - specification of quadrature rule and integration domain
**Parameter:** `f` - integrand
**Parameter:** `Fields` - input arguments for function 'f'
**Parameter:** `OverIntegrationMultiplier` - Multiplier for Quadrature Order
**Returns:**
the integral of 'f' over the domain implied by
'scheme'

## Class: BoSSS.Foundation.DGFieldExtensions <a id="bosss.foundation.dgfieldextensions"></a>

**Summary:** Extension methods


## Method: BoSSS.Foundation.DGFieldExtensions.Evaluate(BoSSS.Foundation.DGField,BoSSS.Foundation.NodeSet,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.evaluate(bosss.foundation.dgfield,bosss.foundation.nodeset,bosss.foundation.grid.cellmask)"></a>
**Summary:** Utility function to evaluate DG fields together with global nodes.
**Parameter:** `f` - DG field to evaluate.
**Parameter:** `NS` - node set.
**Parameter:** `cm` - optional cell mask.
**Returns:**
Global nodes and function values at these nodes;
1st index: cell index;
2nd index: node index;
3rd index: spatial direction


## Method: BoSSS.Foundation.DGFieldExtensions.DivergenceByFlux``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.divergencebyflux``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference Divergence, [BoSSS.Foundation.DGField.DivergenceByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.divergencebyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Divergence``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.divergence``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken Divergence, [BoSSS.Foundation.DGField.Divergence``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.divergence``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.DivergenceByFlux``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.divergencebyflux``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference Divergence, [BoSSS.Foundation.DGField.DivergenceByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.divergencebyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Divergence``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.divergence``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken Divergence, [BoSSS.Foundation.DGField.Divergence``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.divergence``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl3DByFlux``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.curl3dbyflux``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference Curl, [BoSSS.Foundation.VectorField`1.Curl3DByFlux(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.vectorfield`1.curl3dbyflux(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl3D``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.curl3d``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken Curl, [BoSSS.Foundation.VectorField`1.Curl3D(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.vectorfield`1.curl3d(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl3DByFlux``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.curl3dbyflux``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference Curl, [BoSSS.Foundation.VectorField`1.Curl3DByFlux(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.vectorfield`1.curl3dbyflux(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl3D``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.curl3d``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken Curl, [BoSSS.Foundation.VectorField`1.Curl3D(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.vectorfield`1.curl3d(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl2DByFlux``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.curl2dbyflux``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference 2D Curl, [BoSSS.Foundation.DGField.Curl2DByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.curl2dbyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl2D``1(BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.curl2d``1(bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken 2D Curl, [BoSSS.Foundation.DGField.Curl2D``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.curl2d``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl2DByFlux``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.curl2dbyflux``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference 2D Curl, [BoSSS.Foundation.DGField.Curl2DByFlux``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.curl2dbyflux``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DGFieldExtensions.Curl2D``1(System.Collections.Generic.IEnumerable{``0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.curl2d``1(system.collections.generic.ienumerable{``0},bosss.foundation.grid.cellmask)"></a>
**Summary:** Broken 2D Curl, [BoSSS.Foundation.DGField.Curl2D``1(System.Double,BoSSS.Foundation.VectorField{``0},BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.curl2d``1(system.double,bosss.foundation.vectorfield{``0},bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.Derivative``1(``0,System.Int32,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.dgfieldextensions.derivative``1(``0,system.int32,bosss.foundation.grid.cellmask)"></a>
**Summary:** Central Difference Derivative, [BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask))


## Method: BoSSS.Foundation.DGFieldExtensions.DerivativeByFlux``1(``0,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.dgfieldextensions.derivativebyflux``1(``0,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Central Difference Derivative, [BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))

## Class: BoSSS.Foundation.SubGridBoundaryModes <a id="bosss.foundation.subgridboundarymodes"></a>

**Summary:** Options for the treatment of edges at the boundary of a
[BoSSS.Foundation.Grid.SubGrid](#bosss.foundation.grid.subgrid).


### Field: BoSSS.Foundation.SubGridBoundaryModes.BoundaryEdge <a id="bosss.foundation.subgridboundarymodes.boundaryedge"></a>
**Summary:** Treats the edge as a real boundary edge (i.e., will use the
boundary conditions defined by the flux function)


### Field: BoSSS.Foundation.SubGridBoundaryModes.InnerEdge <a id="bosss.foundation.subgridboundarymodes.inneredge"></a>
**Summary:** Treats the edge as a standard inner edge (i.e., the inner edge
flux will be evaluated as for any other inenr edge)


### Field: BoSSS.Foundation.SubGridBoundaryModes.OpenBoundary <a id="bosss.foundation.subgridboundarymodes.openboundary"></a>
**Summary:** Treats the edge as an open boundary of the domain (i.e.,
the inner edge flux will be used, but using the same values for
the variables at both sides of the edge).


### Field: BoSSS.Foundation.SubGridBoundaryModes.InnerEdgeLTS <a id="bosss.foundation.subgridboundarymodes.inneredgelts"></a>
**Summary:** Treats the edge as a standard inner edge (i.e., the inner edge
flux will be evaluated as for any other inenr edge), but saves 
also the fluxes across these edges (needed for LocalTimeStepping)

## Class: BoSSS.Foundation.DifferentialOperator <a id="bosss.foundation.differentialoperator"></a>

**Summary:** This class represents a spatial operator which maps
from (DG-) variables in the domain, identified and ordered by [BoSSS.Foundation.DifferentialOperator.DomainVar](#bosss.foundation.differentialoperator.domainvar)
to variables in the co-domain, identified and ordered by [BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar).


### Property: BoSSS.Foundation.DifferentialOperator.IsLinear <a id="bosss.foundation.differentialoperator.islinear"></a>
**Summary:** true, if the PDE defined by operator can entirely be solved by a linear solver


### Property: BoSSS.Foundation.DifferentialOperator.VectorFieldIndices <a id="bosss.foundation.differentialoperator.vectorfieldindices"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.VectorFieldIndices](#bosss.foundation.idifferentialoperator.vectorfieldindices)
**Remark:**
Note: two ore more domain variable names of [BoSSS.Foundation.DifferentialOperator.DomainVar](#bosss.foundation.differentialoperator.domainvar) are considered to be part of a vector field, 
if these names have the same length but differ by **exactly one character**.


### Property: BoSSS.Foundation.DifferentialOperator.SolverSafeguard <a id="bosss.foundation.differentialoperator.solversafeguard"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.SolverSafeguard](#bosss.foundation.idifferentialoperator.solversafeguard)


### Property: BoSSS.Foundation.DifferentialOperator.QuadOrderFunction <a id="bosss.foundation.differentialoperator.quadorderfunction"></a>
**Summary:** Function Mapping from Domain Variable Degrees, Parameter Degrees and CoDomain Variable Degrees to the Quadrature Order


### Property: BoSSS.Foundation.DifferentialOperator.EdgeQuadraturSchemeProvider <a id="bosss.foundation.differentialoperator.edgequadraturschemeprovider"></a>
**Summary:** User-customizable factory, to specify the edge quadrature, see also [BoSSS.Foundation.DifferentialOperator.QuadOrderFunction](#bosss.foundation.differentialoperator.quadorderfunction)


### Property: BoSSS.Foundation.DifferentialOperator.VolumeQuadraturSchemeProvider <a id="bosss.foundation.differentialoperator.volumequadraturschemeprovider"></a>
**Summary:** User-customizable factory, to specify the cell/volume quadrature, see also [BoSSS.Foundation.DifferentialOperator.QuadOrderFunction](#bosss.foundation.differentialoperator.quadorderfunction)


## Method: BoSSS.Foundation.DifferentialOperator.LegacySupport_ModifyQuadSchemProvider(BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.differentialoperator.legacysupport_modifyquadschemprovider(bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Dirty hack in order to support legacy interfaces: modify quad scheme providers after commit


## Method: BoSSS.Foundation.DifferentialOperator.LegacySupport_RestoreQuadSchemeProvider(System.ValueTuple{System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme},System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.CellQuadratureScheme}}) <a id="bosss.foundation.differentialoperator.legacysupport_restorequadschemeprovider(system.valuetuple{system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.edgequadraturescheme},system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.cellquadraturescheme}})"></a>
**Summary:** Dirty hack to support legacy interface


## Method: BoSSS.Foundation.DifferentialOperator.CompileQuadratureRules(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis}) <a id="bosss.foundation.differentialoperator.compilequadraturerules(system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis})"></a>
**Summary:** Employs [BoSSS.Foundation.DifferentialOperator.EdgeQuadraturSchemeProvider](#bosss.foundation.differentialoperator.edgequadraturschemeprovider), [BoSSS.Foundation.DifferentialOperator.VolumeQuadraturSchemeProvider](#bosss.foundation.differentialoperator.volumequadraturschemeprovider), [BoSSS.Foundation.QuadOrderFunc](#bosss.foundation.quadorderfunc)
to generate quadrature rules for the operator evaluation.


### Field: BoSSS.Foundation.DifferentialOperator.m_UserDefinedValues <a id="bosss.foundation.differentialoperator.m_userdefinedvalues"></a>
**Summary:** internal asses for hack in [BoSSS.Foundation.DependentTemporalOperator](#bosss.foundation.dependenttemporaloperator).


### Property: BoSSS.Foundation.DifferentialOperator.UserDefinedValues <a id="bosss.foundation.differentialoperator.userdefinedvalues"></a>
**Summary:** Modification of [BoSSS.Foundation.CoefficientSet.UserDefinedValues](#bosss.foundation.coefficientset.userdefinedvalues), **but only if** default setting for [BoSSS.Foundation.DifferentialOperator.OperatorCoefficientsProvider](#bosss.foundation.differentialoperator.operatorcoefficientsprovider) is used

## Class: BoSSS.Foundation.DifferentialOperator.DelOperatorCoefficientsProvider <a id="bosss.foundation.differentialoperator.deloperatorcoefficientsprovider"></a>

**Summary:** [BoSSS.Foundation.DifferentialOperator.OperatorCoefficientsProvider](#bosss.foundation.differentialoperator.operatorcoefficientsprovider)


### Property: BoSSS.Foundation.DifferentialOperator.OperatorCoefficientsProvider <a id="bosss.foundation.differentialoperator.operatorcoefficientsprovider"></a>
**Summary:** User-customizable factory, to modify single values (e.g. Reynolds numbers)
within the operator components (those implementing [BoSSS.Foundation.IEquationComponentCoefficient](#bosss.foundation.iequationcomponentcoefficient))
Auxiliary data passed to equation components which implement [BoSSS.Foundation.IEquationComponentCoefficient](#bosss.foundation.iequationcomponentcoefficient).


### Property: BoSSS.Foundation.DifferentialOperator.LinearizationHint <a id="bosss.foundation.differentialoperator.linearizationhint"></a>
**Summary:** A hint for implicit/nonlinear solvers, which linearization of the operator should be used


### Property: BoSSS.Foundation.DifferentialOperator.ParameterUpdates <a id="bosss.foundation.differentialoperator.parameterupdates"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.ParameterUpdates](#bosss.foundation.idifferentialoperator.parameterupdates)


### Property: BoSSS.Foundation.DifferentialOperator.ParameterFactories <a id="bosss.foundation.differentialoperator.parameterfactories"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.ParameterFactories](#bosss.foundation.idifferentialoperator.parameterfactories)


### Property: BoSSS.Foundation.DifferentialOperator.HomotopyUpdate <a id="bosss.foundation.differentialoperator.homotopyupdate"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.HomotopyUpdate](#bosss.foundation.idifferentialoperator.homotopyupdate)


### Property: BoSSS.Foundation.DifferentialOperator.CurrentHomotopyValue <a id="bosss.foundation.differentialoperator.currenthomotopyvalue"></a>
**Summary:** Can be used by a (most likely nonlinear) solver to walk along the homotopy path.
Setting (to a different value) fires all [BoSSS.Foundation.DifferentialOperator.HomotopyUpdate](#bosss.foundation.differentialoperator.homotopyupdate) events


## Method: BoSSS.Foundation.DifferentialOperator.#ctor(System.Int32,System.Int32,System.Func{System.Int32[],System.Int32[],System.Int32[],System.Int32},System.String[]) <a id="bosss.foundation.differentialoperator.#ctor(system.int32,system.int32,system.func{system.int32[],system.int32[],system.int32[],system.int32},system.string[])"></a>
**Summary:** ctor
**Parameter:** `NoOfDomFields` - number of domain fields
**Parameter:** `NoOfCodomFields` - number of codomain fields
**Parameter:** `QuadOrderFunc` - E.g., one of the members of [BoSSS.Foundation.QuadOrderFunc](#bosss.foundation.quadorderfunc).
**Parameter:** `__varnames` - names of domain variables 
(entries 0 to ('NoOfDomFields'-1)),
followed by the names of the codomain variables
(entries 'NoOfDomFields' to ('NoOfDomFields'+'NoOfCodomFields'-1));


## Method: BoSSS.Foundation.DifferentialOperator.#ctor(System.Int32,System.Int32,System.Int32,System.Func{System.Int32[],System.Int32[],System.Int32[],System.Int32},System.String[]) <a id="bosss.foundation.differentialoperator.#ctor(system.int32,system.int32,system.int32,system.func{system.int32[],system.int32[],system.int32[],system.int32},system.string[])"></a>
**Summary:** ctor.
**Parameter:** `NoOfDomFields` - 
**Parameter:** `NoOfCodomFields` - 
**Parameter:** `NoOfParameters` - 
**Parameter:** `QuadOrderFunc` - E.g., one of the members of [BoSSS.Foundation.QuadOrderFunc](#bosss.foundation.quadorderfunc).
**Parameter:** `__varnames` - names of domain variables, followed by the names of the parameter variables,
followed by the names of the codomain variables;


## Method: BoSSS.Foundation.DifferentialOperator.#ctor <a id="bosss.foundation.differentialoperator.#ctor"></a>
**Summary:** Empty constructor; Variable, Parameter, and Codomain/Equation names are specified by the 
order in which equation components are added.


## Method: BoSSS.Foundation.DifferentialOperator.#ctor(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Func{System.Int32[],System.Int32[],System.Int32[],System.Int32}) <a id="bosss.foundation.differentialoperator.#ctor(system.collections.generic.ilist{system.string},system.collections.generic.ilist{system.string},system.func{system.int32[],system.int32[],system.int32[],system.int32})"></a>
**Summary:** constructor;
**Parameter:** `__DomainVar` - variable names in the Domain of the spatial differential operator
**Parameter:** `__CoDomainVar` - variable names in the Codomain of the spatial differential operator
**Parameter:** `QuadOrderFunc` - E.g., one of the members of [BoSSS.Foundation.QuadOrderFunc](#bosss.foundation.quadorderfunc).


## Method: BoSSS.Foundation.DifferentialOperator.#ctor(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Func{System.Int32[],System.Int32[],System.Int32[],System.Int32}) <a id="bosss.foundation.differentialoperator.#ctor(system.collections.generic.ilist{system.string},system.collections.generic.ilist{system.string},system.collections.generic.ilist{system.string},system.func{system.int32[],system.int32[],system.int32[],system.int32})"></a>
**Summary:** constructor;
**Parameter:** `__DomainVar` - variable names in the Domain of the spatial differential operator
**Parameter:** `__ParameterVar` - variable names of the parameter variables; this list is optional, i.e. it 
can be null;
**Parameter:** `__CoDomainVar` - variable names in the Codomain of the spatial differential operator
**Parameter:** `QuadOrderFunc` - E.g., one of the members of [BoSSS.Foundation.QuadOrderFunc](#bosss.foundation.quadorderfunc).


## Method: BoSSS.Foundation.DifferentialOperator.Verify(System.Boolean) <a id="bosss.foundation.differentialoperator.verify(system.boolean)"></a>
**Summary:** verifies all equation components;
**Remark:**
if a component has an illegal configuration (e.g. it's arguments
([BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)) are not contained
in the domain variable list ([BoSSS.Foundation.DifferentialOperator.DomainVar](#bosss.foundation.differentialoperator.domainvar))), an 
exception is thrown, if 'allowVarAddition' is set true, see also [BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean)](#bosss.foundation.idifferentialoperator.commit(system.boolean))


## Method: BoSSS.Foundation.DifferentialOperator.GetOrderFromQuadOrderFunction(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis}) <a id="bosss.foundation.differentialoperator.getorderfromquadorderfunction(system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis})"></a>
**Summary:** Evaluation of the [BoSSS.Foundation.DifferentialOperator.QuadOrderFunction](#bosss.foundation.differentialoperator.quadorderfunction).


## Method: BoSSS.Foundation.DifferentialOperator.CollectDependentVariables(System.String) <a id="bosss.foundation.differentialoperator.collectdependentvariables(system.string)"></a>
**Summary:** for some codomain variable 'CodomVar',
this method collects 
all variables in the domain (see [BoSSS.Foundation.DifferentialOperator.DomainVar](#bosss.foundation.differentialoperator.domainvar))
on which 'CodomVar' depends on.
**Parameter:** `CodomVar` - 
**Returns:**
a sub-list of [BoSSS.Foundation.DifferentialOperator.DomainVar](#bosss.foundation.differentialoperator.domainvar);
**Remark:**
This method invokes [BoSSS.Foundation.DifferentialOperator.Verify(System.Boolean)](#bosss.foundation.differentialoperator.verify(system.boolean));
the returned list is in the same order as


### Field: BoSSS.Foundation.DifferentialOperator.m_EquationComponents <a id="bosss.foundation.differentialoperator.m_equationcomponents"></a>
**Summary:** [BoSSS.Foundation.DifferentialOperator.EquationComponents](#bosss.foundation.differentialoperator.equationcomponents)


### Property: BoSSS.Foundation.DifferentialOperator.EquationComponents <a id="bosss.foundation.differentialoperator.equationcomponents"></a>
**Summary:** for each variable in [BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar), a
collection of equation components that define the operator.


### Property: BoSSS.Foundation.DifferentialOperator.IsCommitted <a id="bosss.foundation.differentialoperator.iscommitted"></a>
**Summary:** indicates whether the equation-assembly has been finished (by calling [BoSSS.Foundation.DifferentialOperator.Commit(System.Boolean)](#bosss.foundation.differentialoperator.commit(system.boolean))) or not.


### Property: BoSSS.Foundation.DifferentialOperator.TotalNoOfComponents <a id="bosss.foundation.differentialoperator.totalnoofcomponents"></a>
**Summary:** total number of equation components, in all codomain variables


## Method: BoSSS.Foundation.DifferentialOperator.Commit(System.Boolean) <a id="bosss.foundation.differentialoperator.commit(system.boolean)"></a>
**Summary:** finalizes the assembly of the operator;
Can be called only once in the lifetime of this object.
After calling this method, no adding/removing of equation components is possible.

## Class: BoSSS.Foundation.DifferentialOperator._EquationComponents <a id="bosss.foundation.differentialoperator._equationcomponents"></a>

**Summary:** implementation of [BoSSS.Foundation.DifferentialOperator.EquationComponents](#bosss.foundation.differentialoperator.equationcomponents);


### Property: BoSSS.Foundation.DifferentialOperator._EquationComponents.Item(System.String) <a id="bosss.foundation.differentialoperator._equationcomponents.item(system.string)"></a>
**Summary:** Returns the collection of equation components for one variable in the codomain;
If the 'EqnName' is not known, and the operator is not committed yet ([BoSSS.Foundation.DifferentialOperator.Commit(System.Boolean)](#bosss.foundation.differentialoperator.commit(system.boolean))) a new 
equation/codomain name is appended.


## Method: BoSSS.Foundation.DifferentialOperator._EquationComponents.GetEnumerator <a id="bosss.foundation.differentialoperator._equationcomponents.getenumerator"></a>
**Summary:** Gets the enumerator over the equation components of the owner
**Returns:**
An enumerator


## Method: BoSSS.Foundation.DifferentialOperator._EquationComponents.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.differentialoperator._equationcomponents.system#collections#ienumerable#getenumerator"></a>
**Summary:** [BoSSS.Foundation.DifferentialOperator._EquationComponents.GetEnumerator](#bosss.foundation.differentialoperator._equationcomponents.getenumerator)
**Returns:**
[BoSSS.Foundation.DifferentialOperator._EquationComponents.GetEnumerator](#bosss.foundation.differentialoperator._equationcomponents.getenumerator)


### Property: BoSSS.Foundation.DifferentialOperator.DomainVar <a id="bosss.foundation.differentialoperator.domainvar"></a>
**Summary:** names of (DG-) variables that represent the domain of this  differential operator;
These names/strings should not be confused with field identification strings
([BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)), they have nothing to do with that.


### Property: BoSSS.Foundation.DifferentialOperator.CodomainVar <a id="bosss.foundation.differentialoperator.codomainvar"></a>
**Summary:** names of (DG-) variables that represent the Co-Domain of this differential operator
These names/strings should not be confused with field identification strings
([BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)), they have nothing to do with that.


### Property: BoSSS.Foundation.DifferentialOperator.ParameterVar <a id="bosss.foundation.differentialoperator.parametervar"></a>
**Summary:** names of (DG-) variables which act as parameters; 
Their role is pretty similar to those of the domain variables, and for nonlinear
fluxes, there is no difference.
However, for linear fluxes, they can be used to provide some 
space-depended properties as DG-fields, e.g. for providing boundary conditions
or if the linear operator is some linearization of some nonlinear operator.


## Method: BoSSS.Foundation.DifferentialOperator.ContainsLinear <a id="bosss.foundation.differentialoperator.containslinear"></a>
**Summary:** returns true, if this spatial differential operator contains any 
linear component,
otherwise returns false;
**Returns:**



### Property: BoSSS.Foundation.DifferentialOperator.ContainsNonlinear <a id="bosss.foundation.differentialoperator.containsnonlinear"></a>
**Summary:** returns true, if this spatial differential operator contains any 
nonlinear component,
otherwise returns false;


### Property: BoSSS.Foundation.DifferentialOperator.RequiresEdgeQuadrature <a id="bosss.foundation.differentialoperator.requiresedgequadrature"></a>
**Summary:** True, if this operator contains any edge term.


### Property: BoSSS.Foundation.DifferentialOperator.RequiresVolumeQuadrature <a id="bosss.foundation.differentialoperator.requiresvolumequadrature"></a>
**Summary:** True, if this operator contains any volume term.


## Method: BoSSS.Foundation.DifferentialOperator.ContainsLinearPerCodomainVar(System.String) <a id="bosss.foundation.differentialoperator.containslinearpercodomainvar(system.string)"></a>
**Summary:** returns true, if any of the equation components associated with 
variable 'CodomVar' is linear
These components are [BoSSS.Foundation.DifferentialOperator.EquationComponents](#bosss.foundation.differentialoperator.equationcomponents)['CodomVar'];
**Parameter:** `CodomVar` - identifies the codomain variable name, must be a member of
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar);
**Returns:**



## Method: BoSSS.Foundation.DifferentialOperator.ContainsNonlinearPerCodomainVar(System.String) <a id="bosss.foundation.differentialoperator.containsnonlinearpercodomainvar(system.string)"></a>
**Summary:** returns true, if any of the equation components associated with 
variable 'CodomVar' is nonlinear
**Parameter:** `CodomVar` - identifies the codomain variable name, must be a member of
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar);
**Returns:**



## Method: BoSSS.Foundation.DifferentialOperator.ReqNonlVolumeQuad_PerCodomainVar(System.String) <a id="bosss.foundation.differentialoperator.reqnonlvolumequad_percodomainvar(system.string)"></a>
**Summary:** returns true, if any of the equation components associated with 
variable 'CodomVar' contains nonlinear integrands
on edges (these are objects that implement [BoSSS.Foundation.INonlinearFlux](#bosss.foundation.inonlinearflux),
[BoSSS.Foundation.INonlinearFluxEx](#bosss.foundation.inonlinearfluxex) or [BoSSS.Foundation.INonlinearSource](#bosss.foundation.inonlinearsource));
**Parameter:** `CodomVar` - identifies the codomain variable name, must be a member of
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar);
**Returns:**



## Method: BoSSS.Foundation.DifferentialOperator.ReqNonlinEdgeQuad_PerCodomainVar(System.String) <a id="bosss.foundation.differentialoperator.reqnonlinedgequad_percodomainvar(system.string)"></a>
**Summary:** returns true, if any of the equation components associated with 
variable 'CodomVar' contains nonlinear integrands on edges.
**Parameter:** `CodomVar` - identifies the codomain variable name, must be a member of
[BoSSS.Foundation.DifferentialOperator.CodomainVar](#bosss.foundation.differentialoperator.codomainvar);
**Returns:**



## Method: BoSSS.Foundation.DifferentialOperator.ContainesComponentType_PerCodomainVar(System.String,System.Type[]) <a id="bosss.foundation.differentialoperator.containescomponenttype_percodomainvar(system.string,system.type[])"></a>
**Summary:** Returns true, if at least one of the equation components 
for codomain variable 'CodomVar'
is of some type in 't'.


## Method: BoSSS.Foundation.DifferentialOperator.ContainesComponentType(System.Type[]) <a id="bosss.foundation.differentialoperator.containescomponenttype(system.type[])"></a>
**Summary:** Returns true, if at least one of the equation components 
of this operator
is of some type in 't'.


## Method: BoSSS.Foundation.DifferentialOperator.GetEvaluatorEx(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.differentialoperator.getevaluatorex(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Constructs a new evaluator object for the explicit evaluation of this spatial operator.
**Parameter:** `CodomainVarMap` - used to compute indices into the result vector
**Parameter:** `DomainFields` - domains which are evaluated to compute fluxes, ...
**Parameter:** `ParameterMap` - The parameter variables (of this differential operator);
The number of elements in the list must match the parameter count of the differential operator
(see [BoSSS.Foundation.DifferentialOperator.ParameterVar](#bosss.foundation.differentialoperator.parametervar));
It is allowed to set an entry to 'null', in this case the values of the parameter field
are assumed to be 0.0;
If the differential operator contains no parameters, this argument can be null;
**Returns:**

**Remark:**
Before this method can be called,
the operator assembly must be finalized by calling [BoSSS.Foundation.DifferentialOperator.Commit(System.Boolean)](#bosss.foundation.differentialoperator.commit(system.boolean)) .


## Method: BoSSS.Foundation.DifferentialOperator.GetMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.differentialoperator.getmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Creator of a [BoSSS.Foundation.DifferentialOperator.EvaluatorLinear](#bosss.foundation.differentialoperator.evaluatorlinear) object.


### Field: BoSSS.Foundation.DifferentialOperator.onlyfordebugging_DoEdge <a id="bosss.foundation.differentialoperator.onlyfordebugging_doedge"></a>
**Summary:** Only for debugging;  can be used to turn all edge integration in spatial operators off.


### Field: BoSSS.Foundation.DifferentialOperator.onlyfordebugging_DoVolume <a id="bosss.foundation.differentialoperator.onlyfordebugging_dovolume"></a>
**Summary:** Only for debugging; can be used to turn all volume integration in spatial operators off.

## Class: BoSSS.Foundation.DifferentialOperator.EvaluatorBase <a id="bosss.foundation.differentialoperator.evaluatorbase"></a>

**Summary:** Container for the evaluation of nonlinear fluxes/sources


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.Owner <a id="bosss.foundation.differentialoperator.evaluatorbase.owner"></a>
**Summary:** the operator used to construct this object


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.#ctor(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.differentialoperator.evaluatorbase.#ctor(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** ctor


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.UpdateCoefficients <a id="bosss.foundation.differentialoperator.evaluatorbase.updatecoefficients"></a>
**Summary:** Sets the coefficients for all equation components of the operator which implement [BoSSS.Foundation.IEquationComponentCoefficient](#bosss.foundation.iequationcomponentcoefficient).


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.m_SubGrid_InCells <a id="bosss.foundation.differentialoperator.evaluatorbase.m_subgrid_incells"></a>


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.SubGridBoundaryTreatment <a id="bosss.foundation.differentialoperator.evaluatorbase.subgridboundarytreatment"></a>
**Summary:** State set by [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.ActivateSubgridBoundary(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.differentialoperator.evaluatorbase.activatesubgridboundary(bosss.foundation.grid.cellmask,bosss.foundation.subgridboundarymodes))


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.ActivateSubgridBoundary(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.differentialoperator.evaluatorbase.activatesubgridboundary(bosss.foundation.grid.cellmask,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Restricts the evaluation of the operator to a specific cell mask.
**Parameter:** `Mask` - cell mask where the operator should be evaluated
**Parameter:** `subGridBoundaryTreatment` - defines what is to be done at edges where one neighboring cell is part of the cell mask 'Mask', 
but the other neighboring cell is *not* part of the cell mask 'Mask'.


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.CodomainMapping <a id="bosss.foundation.differentialoperator.evaluatorbase.codomainmapping"></a>
**Summary:** coordinate mapping for the codomain variables;


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.m_Parameters <a id="bosss.foundation.differentialoperator.evaluatorbase.m_parameters"></a>
**Summary:** [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.Parameters](#bosss.foundation.differentialoperator.evaluatorbase.parameters)


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.Parameters <a id="bosss.foundation.differentialoperator.evaluatorbase.parameters"></a>
**Summary:** parameter mapping


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.DomainMapping <a id="bosss.foundation.differentialoperator.evaluatorbase.domainmapping"></a>
**Summary:** coordinate mapping for the domain variables;


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.GridData <a id="bosss.foundation.differentialoperator.evaluatorbase.griddata"></a>
**Summary:** Grid, on which this evaluator operates on.


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.time <a id="bosss.foundation.differentialoperator.evaluatorbase.time"></a>
**Summary:** Time passed e.g. to [BoSSS.Foundation.CommonParams.time](#bosss.foundation.commonparams.time), [BoSSS.Foundation.CommonParamsBnd.time](#bosss.foundation.commonparamsbnd.time) and [BoSSS.Foundation.CommonParamsVol.time](#bosss.foundation.commonparamsvol.time).


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.GetTrxFields <a id="bosss.foundation.differentialoperator.evaluatorbase.gettrxfields"></a>
**Summary:** Should return all DG fields which should be exchanged, see [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.m_TRX](#bosss.foundation.differentialoperator.evaluatorbase.m_trx).


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.MPITtransceive <a id="bosss.foundation.differentialoperator.evaluatorbase.mpittransceive"></a>
**Summary:** Turn MPI sending/receiving of parameters and domain fields on/off.


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorBase.m_TRX <a id="bosss.foundation.differentialoperator.evaluatorbase.m_trx"></a>
**Summary:** Transceiver for the fields within [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.DomainMapping](#bosss.foundation.differentialoperator.evaluatorbase.domainmapping)

## Class: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin <a id="bosss.foundation.differentialoperator.evaluatornonlin"></a>

**Summary:** evaluation of operators


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.GetTrxFields <a id="bosss.foundation.differentialoperator.evaluatornonlin.gettrxfields"></a>
**Summary:** Returns domain fields and parameters.


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.m_NonlinearEdge <a id="bosss.foundation.differentialoperator.evaluatornonlin.m_nonlinearedge"></a>
**Summary:** if the right-hand-side is present and contains nonlinear components, 
this is the corresponding edge quadrature;
otherwise, this member is null;


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.m_ComplicatedPeriodicEdge <a id="bosss.foundation.differentialoperator.evaluatornonlin.m_complicatedperiodicedge"></a>
**Summary:** If the grid contains some periodic boundaries which are not parallel (e.g. some cake-pie-subsection of a rotational domain)
periodicity required additional transformations/rotations of vectors for **both** sides of the periodic edge;
Furthermore, these rotations are different (inverse) for the in- and the out-edge, 
therefore the contribution to the out-cell is computed in a second pass, by this integrator.


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.m_NonlinearVolume <a id="bosss.foundation.differentialoperator.evaluatornonlin.m_nonlinearvolume"></a>
**Summary:** if the right-hand-side is present and contains nonlinear components, 
this is the corresponding volume quadrature;
otherwise, this member is null;


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.#ctor(BoSSS.Foundation.DifferentialOperator,System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.differentialoperator.evaluatornonlin.#ctor(bosss.foundation.differentialoperator,system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Not for direct user interaction


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.RestrictQr(BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Grid.EdgeMask) <a id="bosss.foundation.differentialoperator.evaluatornonlin.restrictqr(bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.grid.edgemask)"></a>
**Summary:** Removes all edes from a quadrature rule 'Qr' which are not contained in the mask 'Restriction'
**Remark:**
Brute-force implementation, not very sophisticated; should be ok for now.


### Property: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.DomainFields <a id="bosss.foundation.differentialoperator.evaluatornonlin.domainfields"></a>
**Summary:** DG fields which serve a input for the spatial operator.


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorNonLin.Evaluate``1(System.Double,System.Double,``0,System.Double[]) <a id="bosss.foundation.differentialoperator.evaluatornonlin.evaluate``1(system.double,system.double,``0,system.double[])"></a>
**Summary:** evaluates the differential operator ([BoSSS.Foundation.DifferentialOperator.EvaluatorBase.Owner](#bosss.foundation.differentialoperator.evaluatorbase.owner))
for the domain variables/fields in [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.DomainMapping](#bosss.foundation.differentialoperator.evaluatorbase.domainmapping), i.e.
performs the operation
'output' = 'output'*'beta' + Op(%)*'alpha'
**Parameter:** `output` - (output): 
The result of the operator evaluation,
multiplied by 'alpha',
is ACCUMULATED here;
It's up to the user to ensure that this array is initialized to 0.0,
if necessary;
Indices into this vector are computed according to [BoSSS.Foundation.DifferentialOperator.EvaluatorBase.CodomainMapping](#bosss.foundation.differentialoperator.evaluatorbase.codomainmapping);
**Parameter:** `outputBndEdge` - Some additional output vector for boundary fluxes, used only by the local time stepping
**Parameter:** `alpha` - scaling of the operator;
**Parameter:** `beta` - scaling applied to the accumulator;
**Remark:**
This operation invokes MPI communication if [BoSSS.Foundation.IEvaluator.MPITtransceive](#bosss.foundation.ievaluator.mpittransceive) is set to true: values of external cells are updated before
fluxes are evaluated;

## Class: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear <a id="bosss.foundation.differentialoperator.evaluatorlinear"></a>

**Summary:** matrix assembly for linear or linearized operators


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.#ctor(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule},BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.differentialoperator.evaluatorlinear.#ctor(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule},bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Not for direct user interaction


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.edgeRule <a id="bosss.foundation.differentialoperator.evaluatorlinear.edgerule"></a>
**Summary:** Quadrature rule used for edge integration


### Field: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.volRule <a id="bosss.foundation.differentialoperator.evaluatorlinear.volrule"></a>
**Summary:** quadrature rule used for volume integration


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.ComputeAffine``1(``0) <a id="bosss.foundation.differentialoperator.evaluatorlinear.computeaffine``1(``0)"></a>
**Summary:** For the operator linearization 
\f[
\mathcal{M} U + \mathcal{B}
\f]
this computes only the vector $\mathcal{B}$
**Parameter:** `AffineOffset` - 


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.ComputeMatrix``2(``0,``1,System.Double) <a id="bosss.foundation.differentialoperator.evaluatorlinear.computematrix``2(``0,``1,system.double)"></a>
**Summary:** computes a linearization of the operator in the form 
\f[
\mathcal{M} U + \mathcal{B}.
\f]
**Parameter:** `Matrix` - Output, the operator matrix, scaled by 'alpha', is accumulated here
**Parameter:** `AffineOffset` - Output, the affine part of the operator linearization, scaled by 'alpha', is accumulated here
**Parameter:** `alpha` - scaling factor


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.GetTrxFields <a id="bosss.foundation.differentialoperator.evaluatorlinear.gettrxfields"></a>
**Summary:** returns parameter fields


## Method: BoSSS.Foundation.DifferentialOperator.EvaluatorLinear.Internal_ComputeMatrixEx``2(``0,``1,System.Boolean,System.Double) <a id="bosss.foundation.differentialoperator.evaluatorlinear.internal_computematrixex``2(``0,``1,system.boolean,system.double)"></a>
**Summary:** matrix evaluation


## Method: BoSSS.Foundation.DifferentialOperator.GetFDJacobianBuilder(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.differentialoperator.getfdjacobianbuilder(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** constructs a [BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder](#bosss.foundation.differentialoperator.fdjacobianbuilder) object to linearize nonlinear operators


## Method: BoSSS.Foundation.DifferentialOperator.GetFDJacobianBuilder_(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,System.Action{System.Double,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}}) <a id="bosss.foundation.differentialoperator.getfdjacobianbuilder_(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,system.action{system.double,system.collections.generic.ienumerable{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield}})"></a>
**Summary:** Internal implementation and legacy API;
constructs a [BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder](#bosss.foundation.differentialoperator.fdjacobianbuilder) object to linearize nonlinear operators
**Parameter:** `CodomainVarMap` - 
**Parameter:** `DomainFields` - 
**Parameter:** `ParameterMap` - 
**Parameter:** `legayc_delParameterUpdate` - legacy: external delegate to update all parameters at once;
specifying this replaces all [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling) components and all [BoSSS.Foundation.DifferentialOperator.ParameterUpdates](#bosss.foundation.differentialoperator.parameterupdates) set for this operator
with the external update.

## Class: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder <a id="bosss.foundation.differentialoperator.fdjacobianbuilder"></a>

**Summary:** Computes the (approximate) Jacobian matrix of the spatial operator by finite differences.


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.#ctor(BoSSS.Foundation.IEvaluatorNonLin,System.Action{System.Double,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}}) <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.#ctor(bosss.foundation.ievaluatornonlin,system.action{system.double,system.collections.generic.ienumerable{bosss.foundation.dgfield},system.collections.generic.ienumerable{bosss.foundation.dgfield}})"></a>
**Summary:** Not for direct user interaction


### Field: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.eps <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.eps"></a>
**Summary:** Approximately the square root of the machine epsilon.


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.Eps <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.eps"></a>
**Summary:** Epsilon used for the finite difference


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.GridData <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.griddata"></a>
**Summary:** Grid


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.CodomainMapping <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.codomainmapping"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.DomainMapping <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.domainmapping"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.Parameters <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.parameters"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.SubGridBoundaryTreatment <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.subgridboundarytreatment"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.time <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.time"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.Owner <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.owner"></a>


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.MPITtransceive <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.mpittransceive"></a>
**Summary:** can be dangerous to turn off


### Property: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.Eval <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.eval"></a>
**Summary:** Internally used evaluation for finite differences


### Field: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ColorLists <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.colorlists"></a>
**Summary:** - 1st index: enumeration of color lists
- 2nd index: enumeration of cells in color list
- content: local cell index in which an Epsilon-distortion is applied


### Field: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ExternalColorLists <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.externalcolorlists"></a>
**Summary:** Cells which are distorted on an other processor, but influence the result on this processor
- 1st index: correlates to 1st index of [BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ColorLists](#bosss.foundation.differentialoperator.fdjacobianbuilder.colorlists)
- 2nd index: enumeration of cells
- content: some external cell index; this determines the column index of the finite difference result into the Jacobian matrix


### Field: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ExternalColorListsNeighbors <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.externalcolorlistsneighbors"></a>
**Summary:** - 1st index: correlates to 1st index of [BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ColorLists](#bosss.foundation.differentialoperator.fdjacobianbuilder.colorlists)
- 2nd index: correlates with 2nd index of [BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ExternalColorLists](#bosss.foundation.differentialoperator.fdjacobianbuilder.externalcolorlists)
- 3rd index: enumeration
- content: a local cell index of some cell which is affected by an epsilon-distortion on some other processor; this determines the row index of the finite difference result into the Jacobian matrix


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.BuildOptimizedGridColoring <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.buildoptimizedgridcoloring"></a>
**Summary:** coloring which exploits presumed locality of the DG operator


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.BuildOneByOneColoring <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.buildonebyonecoloring"></a>
**Summary:** coloring with one cell at a pass


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ComputeMatrix``2(``0,``1,System.Double) <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.computematrix``2(``0,``1,system.double)"></a>
**Summary:** computes a approximate linearization of the operator in the form 
\f[
\mathcal{M} U + \mathcal{B}.
\f]
**Parameter:** `Matrix` - Output, the approximate Jacobian matrix of the operator, scaled by 'alpha', is accumulated here
**Parameter:** `AffineOffset` - Output, the operator value in the linearization point, scaled by 'alpha'.
**Parameter:** `alpha` - scaling factor


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ComputeAffine``1(``0) <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.computeaffine``1(``0)"></a>
**Summary:** Evaluation at the linearization point


## Method: BoSSS.Foundation.DifferentialOperator.FDJacobianBuilder.ActivateSubgridBoundary(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.differentialoperator.fdjacobianbuilder.activatesubgridboundary(bosss.foundation.grid.cellmask,bosss.foundation.subgridboundarymodes)"></a>
**Parameter:** `sgrd` - 
**Parameter:** `subGridBoundaryTreatment` - 


## Method: BoSSS.Foundation.DifferentialOperator.GetJacobiOperator(System.Int32) <a id="bosss.foundation.differentialoperator.getjacobioperator(system.int32)"></a>
**Summary:** An operator which computes the Jacobian matrix of this operator.
All components in this operator need to implement the [BoSSS.Foundation.ISupportsJacobianComponent](#bosss.foundation.isupportsjacobiancomponent) interface in order to support this operation.


## Method: BoSSS.Foundation.DifferentialOperator._GetJacobiOperator(System.Int32) <a id="bosss.foundation.differentialoperator._getjacobioperator(system.int32)"></a>
**Summary:** An operator which computes the Jacobian matrix of this operator.
All components in this operator need to implement the [BoSSS.Foundation.ISupportsJacobianComponent](#bosss.foundation.isupportsjacobiancomponent) interface in order to support this operation.


## Method: BoSSS.Foundation.DifferentialOperator.IsValidDomainDegreeCombination(System.Int32[],System.Int32[]) <a id="bosss.foundation.differentialoperator.isvaliddomaindegreecombination(system.int32[],system.int32[])"></a>
**Summary:** [BoSSS.Foundation.IDifferentialOperator.IsValidDomainDegreeCombination(System.Int32[],System.Int32[])](#bosss.foundation.idifferentialoperator.isvaliddomaindegreecombination(system.int32[],system.int32[]))


## Method: BoSSS.Foundation.DifferentialOperator.GetAllParameterHandlers <a id="bosss.foundation.differentialoperator.getallparameterhandlers"></a>
**Summary:** Returns all equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling)

## Class: BoSSS.Foundation.DifferentialOperator.TemporalOperatorContainer <a id="bosss.foundation.differentialoperator.temporaloperatorcontainer"></a>

**Summary:** Used by [BoSSS.Foundation.DifferentialOperator._GetJacobiOperator(System.Int32)](#bosss.foundation.differentialoperator._getjacobioperator(system.int32)) to encalsulate the temporal operator
of this operator (because of the ownership, the temporal operator cannot be reused).


## Method: BoSSS.Foundation.DifferentialOperator.TemporalOperatorContainer.Commit <a id="bosss.foundation.differentialoperator.temporaloperatorcontainer.commit"></a>
**Summary:** locks the configuration of the operator


### Property: BoSSS.Foundation.DifferentialOperator.TemporalOperator <a id="bosss.foundation.differentialoperator.temporaloperator"></a>
**Summary:** %


### Property: BoSSS.Foundation.DifferentialOperator.FreeMeanValue <a id="bosss.foundation.differentialoperator.freemeanvalue"></a>
**Summary:** Notifies the solver that the mean value for a specific value is floating.
An example is e.g. the pressure in the incompressible Navier-Stokes equation with all-walls boundary condition.
- key: the name of some domain variable
- value: false, if the mean value of the solution  is defined, true if the mean value  of the solution is floating (i.e. for some solution u, u + constant is also a solution).


### Property: BoSSS.Foundation.DifferentialOperator.FluxesAreNOTMultithreadSafe <a id="bosss.foundation.differentialoperator.fluxesarenotmultithreadsafe"></a>
**Summary:** Set to true, if **all** fluxes must be synchronized in multi-threaded execution.
**This will come at a performance degeneration.**
This is some lazy option: the default value is false,
i.e., fluxes are not synchronized.

## Class: BoSSS.Foundation.DifferentialOperator.MyDict <a id="bosss.foundation.differentialoperator.mydict"></a>

**Summary:** Dictionary which prevents changing after [BoSSS.Foundation.DifferentialOperator.Commit(System.Boolean)](#bosss.foundation.differentialoperator.commit(system.boolean)) has been called;
I hate shit like this class - so many dumb lines of code.

## Class: BoSSS.Foundation.IEquationComponents <a id="bosss.foundation.iequationcomponents"></a>

**Summary:** see [BoSSS.Foundation.IDifferentialOperator.EquationComponents](#bosss.foundation.idifferentialoperator.equationcomponents)


### Property: BoSSS.Foundation.IEquationComponents.Item(System.String) <a id="bosss.foundation.iequationcomponents.item(system.string)"></a>
**Summary:** returns the collection of equation components for one variable in the 
codomain

## Class: BoSSS.Foundation.LinearizationHint <a id="bosss.foundation.linearizationhint"></a>

**Summary:** A hint for implicit solvers, which linearization of the operator should be used


### Field: BoSSS.Foundation.LinearizationHint.GetJacobiOperator <a id="bosss.foundation.linearizationhint.getjacobioperator"></a>
**Summary:** Employ the [BoSSS.Foundation.IDifferentialOperator.GetJacobiOperator(System.Int32)](#bosss.foundation.idifferentialoperator.getjacobioperator(system.int32))


### Field: BoSSS.Foundation.LinearizationHint.AdHoc <a id="bosss.foundation.linearizationhint.adhoc"></a>
**Summary:** Use the ad-hoc matrix builder (default)


### Field: BoSSS.Foundation.LinearizationHint.FDJacobi <a id="bosss.foundation.linearizationhint.fdjacobi"></a>
**Summary:** compute a finite-differnce Jacobian of the operator

## Class: BoSSS.Foundation.SolverSafeguard <a id="bosss.foundation.solversafeguard"></a>

**Summary:** User-defined validation of a solver step, e.g. to prevent the solver to iterate out-of-bounds, 
e.g. to avoid un-physical 'solutions' (e.g. negative density).
('safeguard' for the solver)

## Class: BoSSS.Foundation.IDifferentialOperator <a id="bosss.foundation.idifferentialoperator"></a>

**Summary:** Common interface for differential operators in the DG and the XDG context


### Property: BoSSS.Foundation.IDifferentialOperator.CodomainVar <a id="bosss.foundation.idifferentialoperator.codomainvar"></a>
**Summary:** names of (DG-) variables that represent the Co-Domain of this differential operator
These names/strings should not be confused with field identification strings
([BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)), they have nothing to do with that.


### Property: BoSSS.Foundation.IDifferentialOperator.DomainVar <a id="bosss.foundation.idifferentialoperator.domainvar"></a>
**Summary:** names of (DG-) variables that represent the domain of this  differential operator;
These names/strings should not be confused with field identification strings
([BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)), they have nothing to do with that.


### Property: BoSSS.Foundation.IDifferentialOperator.FreeMeanValue <a id="bosss.foundation.idifferentialoperator.freemeanvalue"></a>
**Summary:** Notifies the solver that the mean value for a specific value is floating.
An example is e.g. the pressure in the incompressible Navier-Stokes equation with all-walls boundary condition.
- key: the name of some domain variable
- value: false, if the mean value of the solution  is defined, true if the mean value  of the solution is floating (i.e. for some solution u, u + constant is also a solution).


### Property: BoSSS.Foundation.IDifferentialOperator.EquationComponents <a id="bosss.foundation.idifferentialoperator.equationcomponents"></a>
**Summary:** for each variable in [BoSSS.Foundation.IDifferentialOperator.CodomainVar](#bosss.foundation.idifferentialoperator.codomainvar), a
collection of equation components that define the operator.


### Property: BoSSS.Foundation.IDifferentialOperator.IsCommitted <a id="bosss.foundation.idifferentialoperator.iscommitted"></a>
**Summary:** indicates whether the equation-assembly has been finished (by calling [BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean)](#bosss.foundation.idifferentialoperator.commit(system.boolean)))
or not.


### Property: BoSSS.Foundation.IDifferentialOperator.FluxesAreNOTMultithreadSafe <a id="bosss.foundation.idifferentialoperator.fluxesarenotmultithreadsafe"></a>
**Summary:** Set to true, if **all** fluxes must be synchronized in multi-threaded execution.
**This will come at a performance degeneration.**
This is some lazy option: the default value is false,
i.e., fluxes are not synchronized.


### Property: BoSSS.Foundation.IDifferentialOperator.ParameterUpdates <a id="bosss.foundation.idifferentialoperator.parameterupdates"></a>
**Summary:** If set, used to update parameters before evaluation.
Keep in mind: Here, multiple handlers can be added so it is not necessary to 
put the update of all parameter fields for the operator into one big piece of spaghetti code.
Hence, it can be split among different handlers.
**Remark:**
Alternatively, equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling) can be used ([BoSSS.Foundation.IParameterHandling.MyParameterUpdate(BoSSS.Foundation.DGField[],BoSSS.Foundation.DGField[])](#bosss.foundation.iparameterhandling.myparameterupdate(bosss.foundation.dgfield[],bosss.foundation.dgfield[]))).


### Property: BoSSS.Foundation.IDifferentialOperator.ParameterFactories <a id="bosss.foundation.idifferentialoperator.parameterfactories"></a>
**Summary:** Can be used to implement the allocation of DG fields to store parameter values.
**Remark:**
Alternatively, equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling) can be used ([BoSSS.Foundation.IParameterHandling.MyParameterAlloc(BoSSS.Foundation.DGField[])](#bosss.foundation.iparameterhandling.myparameteralloc(bosss.foundation.dgfield[]))).


### Property: BoSSS.Foundation.IDifferentialOperator.ParameterVar <a id="bosss.foundation.idifferentialoperator.parametervar"></a>
**Summary:** names of (DG-) variables which act as parameters; 
Their role is pretty similar to those of the domain variables, and for nonlinear
fluxes, there is no difference.
However, for linear fluxes, they can be used to provide some 
space-depended properties as DG-fields, e.g. for providing boundary conditions
or if the linear operator is some linearization of some nonlinear operator.


## Method: BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean) <a id="bosss.foundation.idifferentialoperator.commit(system.boolean)"></a>
**Summary:** finalizes the assembly of the operator;
Can be called only once in the lifetime of this object.
After calling this method, no adding/removing of equation components is possible.
**Parameter:** `allowVarAddition` -
- false: domain and parameter variables of components ([BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering), [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering)) which are not in the [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar) list will cause an exception
- true: domain and parameter variables will be added during the commit-operation


### Property: BoSSS.Foundation.IDifferentialOperator.QuadOrderFunction <a id="bosss.foundation.idifferentialoperator.quadorderfunction"></a>
**Summary:** Function Mapping from Domain Variable Degrees, Parameter Degrees and CoDomain Variable Degrees to the Quadrature Order


## Method: BoSSS.Foundation.IDifferentialOperator.GetJacobiOperator(System.Int32) <a id="bosss.foundation.idifferentialoperator.getjacobioperator(system.int32)"></a>
**Summary:** An operator which computes the Jacobian matrix of this operator.
All components in this operator need to implement the [BoSSS.Foundation.ISupportsJacobianComponent](#bosss.foundation.isupportsjacobiancomponent) interface in order to support this operation.


### Property: BoSSS.Foundation.IDifferentialOperator.LinearizationHint <a id="bosss.foundation.idifferentialoperator.linearizationhint"></a>
**Summary:** A hint for implicit/nonlinear solvers, which linearization of the operator should be used
([BoSSS.Foundation.IDifferentialOperator.GetJacobiOperator(System.Int32)](#bosss.foundation.idifferentialoperator.getjacobioperator(system.int32)), [BoSSS.Foundation.IDifferentialOperator.GetMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)](#bosss.foundation.idifferentialoperator.getmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)), [BoSSS.Foundation.IDifferentialOperator.GetFDJacobianBuilder(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)](#bosss.foundation.idifferentialoperator.getfdjacobianbuilder(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping))),


## Method: BoSSS.Foundation.IDifferentialOperator.GetEvaluatorEx(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.idifferentialoperator.getevaluatorex(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Constructs a new evaluator object for the explicit evaluation of this spatial operator.
**Parameter:** `CodomainVarMap` - used to compute indices into the result vector
**Parameter:** `DomainFields` - domains which are evaluated to compute fluxes, ...
**Parameter:** `ParameterMap` - The parameter variables (of this differential operator);
The number of elements in the list must match the parameter count of the differential operator
(see [BoSSS.Foundation.DifferentialOperator.ParameterVar](#bosss.foundation.differentialoperator.parametervar));
It is allowed to set an entry to 'null', in this case the values of the parameter field
are assumed to be 0.0;
If the differential operator contains no parameters, this argument can be null;
**Returns:**

**Remark:**
Before this method can be called,
the operator assembly must be finalized by calling [BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean)](#bosss.foundation.idifferentialoperator.commit(system.boolean)) .


## Method: BoSSS.Foundation.IDifferentialOperator.GetFDJacobianBuilder(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.idifferentialoperator.getfdjacobianbuilder(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Computes the Jacobian matrix of the operator by finite differences.


## Method: BoSSS.Foundation.IDifferentialOperator.GetMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.idifferentialoperator.getmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Evaluation of the operator matrix
(only for linear operators or ad-hoc linearizations)


### Property: BoSSS.Foundation.IDifferentialOperator.TemporalOperator <a id="bosss.foundation.idifferentialoperator.temporaloperator"></a>
**Summary:** Specification of the temporal operator, i.e. the mass matrix.
Null defers to a steady-state system.
Setting is only available before calling [BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean)](#bosss.foundation.idifferentialoperator.commit(system.boolean)).


### Property: BoSSS.Foundation.IDifferentialOperator.HomotopyUpdate <a id="bosss.foundation.idifferentialoperator.homotopyupdate"></a>
**Summary:** A functionality which can be used to help a nonlinear solver to solve for "difficult" coefficients,
e.g. high Reynolds numbers. The principal idea is to start at coefficient values which are 
"easy" to solve, e.g. a low Reynolds number, and successively increase the respective value 
until the target is reached. The solution with easier coefficients is then used as an 
initial guess for the solution of more difficult coefficients.
This family of solutions are points on the so-called homotopy path.

In order to support such a solver strategy, the user has to define the 
coefficient-update along a homotopy path; the path itself is parameterized from 0 to 1.
At this member, the user has to specify delegates which handle the update of the coefficients
at the homotopy path.
- the input value for the delegate is a value between 0 and 1 (both including). 
- 0 should map to the most easy coefficient value, 1 maps to the target coefficient value.
- in the body of the method, the respective scalars can be updated.


### Property: BoSSS.Foundation.IDifferentialOperator.CurrentHomotopyValue <a id="bosss.foundation.idifferentialoperator.currenthomotopyvalue"></a>
**Summary:** Setting (to a different value) fires all [BoSSS.Foundation.IDifferentialOperator.HomotopyUpdate](#bosss.foundation.idifferentialoperator.homotopyupdate) events


### Property: BoSSS.Foundation.IDifferentialOperator.SolverSafeguard <a id="bosss.foundation.idifferentialoperator.solversafeguard"></a>
**Summary:** 'safeguard' for solvers to avoid unphysical solutions during the solution procedure;
An example would be to avoid e.g. negative denities, which might even cause NaNs,
during the solver run for implicit, nonlinear equations.


### Property: BoSSS.Foundation.IDifferentialOperator.IsLinear <a id="bosss.foundation.idifferentialoperator.islinear"></a>
**Summary:** true, if the PDE defined by operator can entirely be solved by a linear solver


## Method: BoSSS.Foundation.IDifferentialOperator.GetOrderFromQuadOrderFunction(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis}) <a id="bosss.foundation.idifferentialoperator.getorderfromquadorderfunction(system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis},system.collections.generic.ienumerable{bosss.foundation.basis})"></a>
**Summary:** Evaluation of the [BoSSS.Foundation.IDifferentialOperator.QuadOrderFunction](#bosss.foundation.idifferentialoperator.quadorderfunction) for a concrete basis
**Parameter:** `CodomainBasis` - 
**Parameter:** `ParameterBasis` - can be null
**Parameter:** `DomainBasis` - 


### Property: BoSSS.Foundation.IDifferentialOperator.VectorFieldIndices <a id="bosss.foundation.idifferentialoperator.vectorfieldindices"></a>
**Summary:** Identifies those domain variables which form vector fields:
E.g. if the [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar) list is `{ VelX, VelY, Pressure, TX, TY }` it will return ` { { 0, 1 } , { 4, 5} }`.


## Method: BoSSS.Foundation.IDifferentialOperator.IsValidDomainDegreeCombination(System.Int32[],System.Int32[]) <a id="bosss.foundation.idifferentialoperator.isvaliddomaindegreecombination(system.int32[],system.int32[])"></a>
**Summary:** Indicate whether a specific combination of DG degrees is a valid combination (e.g. with respect to numerical stability, a degree 0 is invalid for an SIP discretization)
**Parameter:** `DomainDegreesPerVariable` -
- index correlates with [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar)
- content: DG polynomial degree for respective variable
**Parameter:** `CodomainDegreesPerVariable` -
- index correlates with [BoSSS.Foundation.IDifferentialOperator.CodomainVar](#bosss.foundation.idifferentialoperator.codomainvar)
- content: DG polynomial degree for respective variable
**Returns:**
- true: combination of DG degrees is OK;
- false if not


## Method: BoSSS.Foundation.IDifferentialOperator.GetAllParameterHandlers <a id="bosss.foundation.idifferentialoperator.getallparameterhandlers"></a>
**Summary:** Returns all equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling)

## Class: BoSSS.Foundation.ITemporalOperator <a id="bosss.foundation.itemporaloperator"></a>

**Summary:** [BoSSS.Foundation.IDifferentialOperator.TemporalOperator](#bosss.foundation.idifferentialoperator.temporaloperator)


## Method: BoSSS.Foundation.ITemporalOperator.Commit <a id="bosss.foundation.itemporaloperator.commit"></a>
**Summary:** finalizes the assembly of the operator;
Can be called only once in the lifetime of this object.
After calling this method, no adding/removing of equation components is possible.


## Method: BoSSS.Foundation.ITemporalOperator.GetMassMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.itemporaloperator.getmassmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Evaluation of the temporal operator matrix (aka. mass matrix).


## Method: BoSSS.Foundation.ITemporalOperator.GetAllParameterHandlers <a id="bosss.foundation.itemporaloperator.getallparameterhandlers"></a>
**Summary:** Returns all equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling)

## Class: BoSSS.Foundation.IEquationComponent <a id="bosss.foundation.iequationcomponent"></a>

**Summary:** Properties that all kinds of objects that form equations have in common.


### Property: BoSSS.Foundation.IEquationComponent.ArgumentOrdering <a id="bosss.foundation.iequationcomponent.argumentordering"></a>
**Summary:** Defines the order in which numerical values are provided as Arguments for the
flux functions (domain variables).
E.g., if this property returns the array {"u","v","w"},
the values of u,v,w  are put into into the Uin,Uout-arguments 
of the flux function when they are called.


### Property: BoSSS.Foundation.IEquationComponent.ParameterOrdering <a id="bosss.foundation.iequationcomponent.parameterordering"></a>
**Summary:** Defines the order in which numerical values of the 
parameter variables are sorted for this flux;

## Class: BoSSS.Foundation.IMultitreadSafety <a id="bosss.foundation.imultitreadsafety"></a>

**Summary:** Some optional methods a flux could implement to help the quadrature kernel with thread synchronization in multi-thread-parallelization
- if some flux or source function (e.g. **],System.Double,System.Double[])** or **],System.Double,System.Double[])**) is typically safe in the following circumstances:
- for write/access it uses only local variables (i.e., declared within the function/method) 
- for member variables (i.e., declared within the class), it only makes read-access
- on the other hand, if a function makes **write access to class member variables it is not save** for multi-thread-execution.
In the latter case
- the component should inform the quadrature kernel that it is not save, by setting [BoSSS.Foundation.IMultitreadSafety.IsMultithreadSafe](#bosss.foundation.imultitreadsafety.ismultithreadsafe) to false.
in this case, synchronization is turned on.
- if [BoSSS.Foundation.IMultitreadSafety.CloneForThread](#bosss.foundation.imultitreadsafety.cloneforthread) returns non-null, the clone will be used for any thread and one clone will be used for every thread. 
For the sake of code readability and maybe for performance reasons, it is not recommended that flux function implement their own `lock`-statements for thread-synchronization.


### Property: BoSSS.Foundation.IMultitreadSafety.IsMultithreadSafe <a id="bosss.foundation.imultitreadsafety.ismultithreadsafe"></a>
**Summary:** Tells the integration kernel whether this component 
- (true) is safe to use in a multi-thread-parallelization or
- (false) requires synchronization. In this case, the quadrature kernels ensure, that the flux functions are only called one at a time.


## Method: BoSSS.Foundation.IMultitreadSafety.CloneForThread <a id="bosss.foundation.imultitreadsafety.cloneforthread"></a>
**Summary:** If [BoSSS.Foundation.IMultitreadSafety.IsMultithreadSafe](#bosss.foundation.imultitreadsafety.ismultithreadsafe) is false, then
- this method might return null; in this case, the calls to flux functions are synchronized across multiple threads
- to improve parallel performance, the method might return a clone; then a separate clone will be used for each thread and synchronization will be turned off.
**Returns:**



## Method: BoSSS.Foundation.IMultitreadSafety.GetPadlock <a id="bosss.foundation.imultitreadsafety.getpadlock"></a>
**Summary:** In the case of an equation component which requires thread synchronization, i.e.
- [BoSSS.Foundation.IMultitreadSafety.IsMultithreadSafe](#bosss.foundation.imultitreadsafety.ismultithreadsafe) is false and
- [BoSSS.Foundation.IMultitreadSafety.CloneForThread](#bosss.foundation.imultitreadsafety.cloneforthread) returns null
this method must return some object which can be used for an exclusive lock to perform the synchronization;
Typically, this can be the equation component object itself, i.e., the method might return the `this` reference.

## Class: BoSSS.Foundation.IDGdegreeConstraint <a id="bosss.foundation.idgdegreeconstraint"></a>

**Summary:** imposes constraints (e.g. DG polynomial degree grater than 0) on the DG polynomial degree of a discretization


## Method: BoSSS.Foundation.IDGdegreeConstraint.IsValidDomainDegreeCombination(System.Int32[],System.Int32) <a id="bosss.foundation.idgdegreeconstraint.isvaliddomaindegreecombination(system.int32[],system.int32)"></a>
**Summary:** Indicate wheter a specfic combination of DG degrees is a valid combination (e.g. with respect to numerical stability, a degree 0 is invalid for an SIP discretization)
**Parameter:** `DomainDegreesPerVariable` -
- index correlates with [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)
- content: DG polynomial degree for respective variable
**Parameter:** `CodomainDegree` - DG polynomial degree for codomain respective variable
**Returns:**
- true: combination of DG degrees is OK;
- false if not

## Class: BoSSS.Foundation.IParameterHandling <a id="bosss.foundation.iparameterhandling"></a>

**Summary:** Interface for equation components that require parameters which are based on the current state


## Method: BoSSS.Foundation.IParameterHandling.MyParameterUpdate(BoSSS.Foundation.DGField[],BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iparameterhandling.myparameterupdate(bosss.foundation.dgfield[],bosss.foundation.dgfield[])"></a>
**Summary:** Update of parameter fields used by this operator;
(alternatively, [BoSSS.Foundation.IDifferentialOperator.ParameterUpdates](#bosss.foundation.idifferentialoperator.parameterupdates) can be used.)
**Parameter:** `Arguments` - input, the current state of the approximate solution at which the operator should be evaluated or linearized.
sequence correlates with [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering).
**Parameter:** `Parameters` - output, sequence correlates with [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering).


## Method: BoSSS.Foundation.IParameterHandling.MyParameterAlloc(BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iparameterhandling.myparameteralloc(bosss.foundation.dgfield[])"></a>
**Summary:** Factory for the allocation of storage for storing the parameters for this component
(alternatively, [BoSSS.Foundation.IDifferentialOperator.ParameterFactories](#bosss.foundation.idifferentialoperator.parameterfactories) can be used.)
**Parameter:** `Arguments` - input, the currently used DG fields to store approximate solution.
(required if e.g. the DG degree of the parameters somehow should depend on the DG degree of the arguments/domain variables).
sequence correlates with [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering).
**Returns:**


## Class: BoSSS.Foundation.IEquationComponentChecking <a id="bosss.foundation.iequationcomponentchecking"></a>

**Summary:** Additional hints for checking the implementation


### Property: BoSSS.Foundation.IEquationComponentChecking.IgnoreVectorizedImplementation <a id="bosss.foundation.iequationcomponentchecking.ignorevectorizedimplementation"></a>
**Summary:** Only for performance measurements of the vectorized implementations (e.g. [BoSSS.Foundation.INonlinVolumeForm_V](#bosss.foundation.inonlinvolumeform_v), [BoSSS.Foundation.IVolumeForm_UxV](#bosss.foundation.ivolumeform_uxv), etc.)
against the base implementation ([BoSSS.Foundation.IVolumeForm](#bosss.foundation.ivolumeform), [BoSSS.Foundation.IEdgeForm](#bosss.foundation.iedgeform)):
If true, the base implementation will be used even if a vectorized version is provided.

## Class: BoSSS.Foundation.IEquationComponentCoefficient <a id="bosss.foundation.iequationcomponentcoefficient"></a>

**Summary:** Interface for equation components which require e.g. grid and/or problem-dependent coefficients,
e.g. cell length scales;


## Method: BoSSS.Foundation.IEquationComponentCoefficient.CoefficientUpdate(BoSSS.Foundation.CoefficientSet,System.Int32[],System.Int32) <a id="bosss.foundation.iequationcomponentcoefficient.coefficientupdate(bosss.foundation.coefficientset,system.int32[],system.int32)"></a>
**Summary:** Passes various coefficients to the equation component.
**Parameter:** `cs` - 
**Parameter:** `DomainDGdeg` - DG polynomial order of trial/domain variables/arguments; ordering corresponds with [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering);
**Parameter:** `TestDGdeg` - DG polynomial degree of test/codomain variable

## Class: BoSSS.Foundation.CoefficientSet <a id="bosss.foundation.coefficientset"></a>

**Summary:** Set of various custom resp. predefined coefficients,

**Remark:**
By encapsulation of the arguments of [BoSSS.Foundation.IEquationComponentCoefficient.CoefficientUpdate(BoSSS.Foundation.CoefficientSet,System.Int32[],System.Int32)](#bosss.foundation.iequationcomponentcoefficient.coefficientupdate(bosss.foundation.coefficientset,system.int32[],system.int32)) in a separate
class it is easy tho change/add variables without updating each and every interface implementation.


### Field: BoSSS.Foundation.CoefficientSet.GrdDat <a id="bosss.foundation.coefficientset.grddat"></a>
**Summary:** Reference to grid


### Field: BoSSS.Foundation.CoefficientSet.CellLengthScales <a id="bosss.foundation.coefficientset.celllengthscales"></a>
**Summary:** length scales for cells (e.g. for computing penalty parameters or local CFL numbers),
typically (in the DG case) the values from [BoSSS.Foundation.Grid.Classic.GridData.CellData.CellLengthScale](#bosss.foundation.grid.classic.griddata.celldata.celllengthscale)


### Field: BoSSS.Foundation.CoefficientSet.EdgeLengthScales <a id="bosss.foundation.coefficientset.edgelengthscales"></a>
**Summary:** length scales for edges (e.g. for computing penalty parameters)
typically (in the DG case) the values from [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.h_min_Edge](#bosss.foundation.grid.classic.griddata.edgedata.h_min_edge)


### Field: BoSSS.Foundation.CoefficientSet.HomotopyValue <a id="bosss.foundation.coefficientset.homotopyvalue"></a>
**Summary:** scalar on the homotopy path a nonlinear solver


### Field: BoSSS.Foundation.CoefficientSet.SpeciesSubGrdMask <a id="bosss.foundation.coefficientset.speciessubgrdmask"></a>
**Summary:** Species Subgrid


### Field: BoSSS.Foundation.CoefficientSet.UserDefinedValues <a id="bosss.foundation.coefficientset.userdefinedvalues"></a>
**Summary:** collection of user-defined objects

## Class: BoSSS.Foundation.ISupportsJacobianComponent <a id="bosss.foundation.isupportsjacobiancomponent"></a>

**Summary:** Interface for components that provide their derivative,
required for Newton solvers
(see [BoSSS.Foundation.DifferentialOperator.GetJacobiOperator(System.Int32)](#bosss.foundation.differentialoperator.getjacobioperator(system.int32))).


## Method: BoSSS.Foundation.ISupportsJacobianComponent.GetJacobianComponents(System.Int32) <a id="bosss.foundation.isupportsjacobiancomponent.getjacobiancomponents(system.int32)"></a>
**Summary:** A collection of components which in sum for the derivative of this component;
For (bi-) linear components, this is usually the flux itself.

## Class: BoSSS.Foundation.INonlinearSource <a id="bosss.foundation.inonlinearsource"></a>

**Summary:** defines a nonlinear source term.
\[
s(\vec{U},v) = \int_{\Omega} f(\vec{U}) v \ \mathrm{dV}
\]


## Method: BoSSS.Foundation.INonlinearSource.Source(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearsource.source(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** the point-wise source term f;
**Parameter:** `time` - 
**Parameter:** `x` - global coordinated of quadrature nodes for each cell
1st index: cell index
2nd index: quadrature node index
3rd index: spatial dimension
**Parameter:** `U` - 
**Parameter:** `IndexOffset` - 
**Parameter:** `Lenght` - 
**Parameter:** `Output` - 
**Parameter:** `FirstCellInd` - index of the first of the 'Lenght' cells to process

## Class: BoSSS.Foundation.INonlinearFlux <a id="bosss.foundation.inonlinearflux"></a>

**Summary:** specifies a nonlinear flux function; Equations 
containing that kind of flux can only be treated explicit.


## Method: BoSSS.Foundation.INonlinearFlux.BorderEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Boolean,System.Byte[],System.Int32,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearflux.borderedgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.boolean,system.byte[],system.int32,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Parameter:** `time` - actual time
**Parameter:** `x` -
1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial dimension index
**Parameter:** `normal` -
1st index: edge index;
2nd index: quadrature nodes index
3rd index: spatial dimension index;
**Parameter:** `Uin` -
1st index: edge index, with some offset;
2nd index: node index;
**Parameter:** `IndexOffset` - an index offset into the first dimension of 
'Output', 'x' and each 'Uin'-entry;
**Parameter:** `Lenght` - number of edges to process
**Parameter:** `Output` - accumulator (!) for output values;
1st index: local edge index, with some offset;
2nd index: node index;
**Parameter:** `EdgeTags` - 
**Parameter:** `EdgeTagsOffset` - 
**Parameter:** `normalFliped` - 
**Parameter:** `jEdge` - index of first edge


## Method: BoSSS.Foundation.INonlinearFlux.InnerEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearflux.inneredgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Parameter:** `time` - 
**Parameter:** `x` - 
**Parameter:** `normal` - edge normal's;
1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial dimension index
**Parameter:** `Uin` - 
**Parameter:** `Uout` - 
**Parameter:** `Offset` - 
**Parameter:** `Lenght` - 
**Parameter:** `Output` - 
**Parameter:** `jEdge` - index of first edge


## Method: BoSSS.Foundation.INonlinearFlux.Flux(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearflux.flux(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Parameter:** `time` - 
**Parameter:** `x` - nodes position in global space;
1st index: cell index with some offset;
2nd index: node index within cell;
3rd index: spatial dimension;
**Parameter:** `U` -
1st index: Field index as defined by 
2nd index: cell index with some offset;
3rd index: node index within cell;
**Parameter:** `Offset` - 1st cell index into 'x' that must be evaluated.
Evaluation has to be done only for the cells from index 'Offset' to 
'Offset'+'Length'-1;
**Parameter:** `Length` - Number of cells to evaluate; NOT EQUAL to the 1st length of 'x' or 'Output'!!!
**Parameter:** `Output` - On exit, the flux vector field value for the corresponding nodes in 'x' should be 
accumulated here;
1st index: cell index with some offset;
2nd index: node index;
3rd index: spatial dimension;
All indices correspond with 'x';

## Class: BoSSS.Foundation.INonlinearFluxEx <a id="bosss.foundation.inonlinearfluxex"></a>

**Summary:** specifies a nonlinear flux function; Equations 
containing that kind of flux can only be treated explicit.
It differs from [BoSSS.Foundation.INonlinearFlux](#bosss.foundation.inonlinearflux)


## Method: BoSSS.Foundation.INonlinearFluxEx.BorderEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Boolean,System.Byte[],System.Int32,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearfluxex.borderedgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.boolean,system.byte[],system.int32,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** Numerical flux at edges on the boundary of the physical domain
**Parameter:** `time` - actual time
**Parameter:** `x` -
1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial dimension index
**Parameter:** `normal` -
1st index: local edge index, with some offset;
2nd index: node index;
3rd index: spatial dimension index
**Parameter:** `Uin` -
1st index: edge index, with some offset;
2nd index: node index;
**Parameter:** `UinMean` - 
**Parameter:** `IndexOffset` - an index offset into the first dimension of 
'Output', 'x' and each 'Uin'-entry;
**Parameter:** `Lenght` - number of edges to process
**Parameter:** `Output` - accumulator (!) for output values;
1st index: local edge index, with some offset;
2nd index: node index;
**Parameter:** `jEdge` - local edge index of first edge to process
**Parameter:** `EdgeTags` - 
**Parameter:** `EdgeTagsOffset` - 
**Parameter:** `normalFliped` - 


## Method: BoSSS.Foundation.INonlinearFluxEx.InnerEdgeFlux(System.Double,System.Int32,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinearfluxex.inneredgeflux(system.double,system.int32,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Parameter:** `time` - 
**Parameter:** `x` - 
**Parameter:** `normal` - 
**Parameter:** `Uin` - 
**Parameter:** `Uout` - 
**Parameter:** `UinMean` - 
**Parameter:** `UoutMean` - 
**Parameter:** `Offset` - 
**Parameter:** `Lenght` - 
**Parameter:** `Output` - 
**Parameter:** `jEdge` - local edge index of first edge to process


## Method: BoSSS.Foundation.INonlinearFluxEx.Flux(System.Double,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray[],System.Int32,System.Int32,ilPSP.MultidimensionalArray,System.Int32) <a id="bosss.foundation.inonlinearfluxex.flux(system.double,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray[],system.int32,system.int32,ilpsp.multidimensionalarray,system.int32)"></a>
**Parameter:** `time` - 
**Parameter:** `x` - 
**Parameter:** `U` - 
**Parameter:** `Offset` - 
**Parameter:** `Length` - 
**Parameter:** `Output` - 
**Parameter:** `jCell` - local cell index of the first (vectorized evaluation !) cell

## Class: BoSSS.Foundation.InParams <a id="bosss.foundation.inparams"></a>


### Field: BoSSS.Foundation.InParams.X <a id="bosss.foundation.inparams.x"></a>
**Summary:** spatial position in space, at which flux should be evaluated


### Field: BoSSS.Foundation.InParams.normal <a id="bosss.foundation.inparams.normal"></a>
**Summary:** normal vector, pointing from IN- to OUT-cell;
index: spatial direction.


### Field: BoSSS.Foundation.InParams.h_min_edge <a id="bosss.foundation.inparams.h_min_edge"></a>
**Summary:** minimum length of any line within edge simplex


### Field: BoSSS.Foundation.InParams.h_max_edge <a id="bosss.foundation.inparams.h_max_edge"></a>
**Summary:** maximum length of any line within edge simplex


### Field: BoSSS.Foundation.InParams.h_min_in <a id="bosss.foundation.inparams.h_min_in"></a>
**Summary:** minimum length of any line within in IN - cell;


### Field: BoSSS.Foundation.InParams.h_max_in <a id="bosss.foundation.inparams.h_max_in"></a>
**Summary:** maximum length of any line within in IN - cell;


### Field: BoSSS.Foundation.InParams.h_min_out <a id="bosss.foundation.inparams.h_min_out"></a>
**Summary:** minimum length of any line within in OUT - cell;
(invalid for border edges);


### Field: BoSSS.Foundation.InParams.h_max_out <a id="bosss.foundation.inparams.h_max_out"></a>
**Summary:** maximum length of any line within in OUT - cell;
(invalid for border edges);


### Field: BoSSS.Foundation.InParams.VolumeIn <a id="bosss.foundation.inparams.volumein"></a>
**Summary:** volume (to be more exact: D - dimensional measure) of the IN - cell


### Field: BoSSS.Foundation.InParams.VolumeOut <a id="bosss.foundation.inparams.volumeout"></a>
**Summary:** volume (to be more exact: D - dimensional measure) of the OUT - cell


### Field: BoSSS.Foundation.InParams.SurfaceAreaIn <a id="bosss.foundation.inparams.surfaceareain"></a>
**Summary:** area (to be more exact: (D-1) - dimensional measure) of boundary the IN - cell


### Field: BoSSS.Foundation.InParams.SurfaceAreaOut <a id="bosss.foundation.inparams.surfaceareaout"></a>
**Summary:** area (to be more exact: (D-1) - dimensional measure) of boundary the OUT - cell


### Field: BoSSS.Foundation.InParams.EdgeArea <a id="bosss.foundation.inparams.edgearea"></a>
**Summary:** area (to be more exact: (D-1) - dimensional measure) of the edge


### Field: BoSSS.Foundation.InParams.jCellIn <a id="bosss.foundation.inparams.jcellin"></a>
**Summary:** local cell index for IN - cell;


### Field: BoSSS.Foundation.InParams.jCellOut <a id="bosss.foundation.inparams.jcellout"></a>
**Summary:** local cell index for OUT - cell;
(invalid for border edges);


### Field: BoSSS.Foundation.InParams.jEdge <a id="bosss.foundation.inparams.jedge"></a>
**Summary:** local edge index


### Field: BoSSS.Foundation.InParams.EdgeTag <a id="bosss.foundation.inparams.edgetag"></a>
**Summary:** edge tag


### Field: BoSSS.Foundation.InParams.ParameterValuesIn <a id="bosss.foundation.inparams.parametervaluesin"></a>
**Summary:** values of parameters in IN - cell; values are sorted according to [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering);


### Field: BoSSS.Foundation.InParams.ParameterValuesOut <a id="bosss.foundation.inparams.parametervaluesout"></a>
**Summary:** values of parameters in OUT - cell; values are sorted according to [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering);


### Field: BoSSS.Foundation.InParams.SubGridBoundary <a id="bosss.foundation.inparams.subgridboundary"></a>
**Summary:** true if integrating over an edge that is on the boundary of the subgrid

## Class: BoSSS.Foundation.TermActivationFlags <a id="bosss.foundation.termactivationflags"></a>

**Summary:** These Flags Control, whether Certain Terms are evaluated during quadrature of the Forms
Multiple Flags can be Defined by using "bitwise and" i.e. "|".
E.g.
TermActivationFlags.UxV | TermActivationFlags.GradUxV | TermActivationFlags.UxGradV


### Field: BoSSS.Foundation.TermActivationFlags.None <a id="bosss.foundation.termactivationflags.none"></a>
**Summary:** Don't evaluate Anything


### Field: BoSSS.Foundation.TermActivationFlags.UxV <a id="bosss.foundation.termactivationflags.uxv"></a>
**Summary:** Trial- x TestFunction


### Field: BoSSS.Foundation.TermActivationFlags.GradUxV <a id="bosss.foundation.termactivationflags.graduxv"></a>
**Summary:** Gradient of TrialFunction x TestFunction


### Field: BoSSS.Foundation.TermActivationFlags.UxGradV <a id="bosss.foundation.termactivationflags.uxgradv"></a>
**Summary:** TrialFunction Gradient of TestFunction


### Field: BoSSS.Foundation.TermActivationFlags.GradUxGradV <a id="bosss.foundation.termactivationflags.graduxgradv"></a>
**Summary:** Gradient of TrialFunction x Gradient of TestFunction


### Field: BoSSS.Foundation.TermActivationFlags.V <a id="bosss.foundation.termactivationflags.v"></a>
**Summary:** TestFunction Only
This is required e.g. for SourceTerms and BoundaryValues


### Field: BoSSS.Foundation.TermActivationFlags.GradV <a id="bosss.foundation.termactivationflags.gradv"></a>
**Summary:** Gradient of TestFunction Only
This is required e.g. for SourceTerms and BoundaryValues


### Field: BoSSS.Foundation.TermActivationFlags.AllOn <a id="bosss.foundation.termactivationflags.allon"></a>
**Summary:** All flags are activated

## Class: BoSSS.Foundation.CommonParams <a id="bosss.foundation.commonparams"></a>

**Summary:** parameter value structure for interior edges.


### Field: BoSSS.Foundation.CommonParams.Normal <a id="bosss.foundation.commonparams.normal"></a>
**Summary:** normal vector


### Field: BoSSS.Foundation.CommonParams.X <a id="bosss.foundation.commonparams.x"></a>
**Summary:** Quadrature node in global coordinates


### Field: BoSSS.Foundation.CommonParams.Parameters_IN <a id="bosss.foundation.commonparams.parameters_in"></a>
**Summary:** parameter values on IN-cell


### Field: BoSSS.Foundation.CommonParams.Parameters_OUT <a id="bosss.foundation.commonparams.parameters_out"></a>
**Summary:** parameter values on OUT-cell


### Field: BoSSS.Foundation.CommonParams.iEdge <a id="bosss.foundation.commonparams.iedge"></a>
**Summary:** edge index (local on current MPI rank), i.e. 0th index into [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices);
- the IN-cell is: [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)[iEdge, 0] == [BoSSS.Foundation.CommonParams.jCellIn](#bosss.foundation.commonparams.jcellin)
- the OUT-cell is: [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)[iEdge, 1] == [BoSSS.Foundation.CommonParams.jCellOut](#bosss.foundation.commonparams.jcellout)
- access via [BoSSS.Foundation.CommonParams.GridDat](#bosss.foundation.commonparams.griddat), [BoSSS.Foundation.Grid.IGridData.iLogicalEdges](#bosss.foundation.grid.igriddata.ilogicaledges), [BoSSS.Foundation.Grid.ILogicalEdgeData.CellIndices](#bosss.foundation.grid.ilogicaledgedata.cellindices)


### Field: BoSSS.Foundation.CommonParams.jCellIn <a id="bosss.foundation.commonparams.jcellin"></a>
**Summary:** Index of IN-cell (local geometrical index).


### Field: BoSSS.Foundation.CommonParams.jCellOut <a id="bosss.foundation.commonparams.jcellout"></a>
**Summary:** Index of OUT-cell (local geometrical index).


### Field: BoSSS.Foundation.CommonParams.GridDat <a id="bosss.foundation.commonparams.griddat"></a>
**Summary:** reference to grid data structure.


### Property: BoSSS.Foundation.CommonParams.D <a id="bosss.foundation.commonparams.d"></a>
**Summary:** spatial dimension


### Field: BoSSS.Foundation.CommonParams.time <a id="bosss.foundation.commonparams.time"></a>
**Summary:** Physical time.


### Field: BoSSS.Foundation.CommonParams.EdgeTag <a id="bosss.foundation.commonparams.edgetag"></a>
**Summary:** edge tag for the respective edge (see [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags](#bosss.foundation.grid.igeometricaledgedata.edgetags))
For interior edges, this is 
- equal to 0 on ordinary edges
- greater or equal to [BoSSS.Foundation.Grid.Classic.GridCommons.FIRST_PERIODIC_BC_TAG](#bosss.foundation.grid.classic.gridcommons.first_periodic_bc_tag) on periodic edges

## Class: BoSSS.Foundation.CommonParamsBnd <a id="bosss.foundation.commonparamsbnd"></a>

**Summary:** parameter value structure for boundary edges.


### Field: BoSSS.Foundation.CommonParamsBnd.Normal <a id="bosss.foundation.commonparamsbnd.normal"></a>
**Summary:** normal vector


### Field: BoSSS.Foundation.CommonParamsBnd.X <a id="bosss.foundation.commonparamsbnd.x"></a>
**Summary:** Quadrature node in global coordinates


### Field: BoSSS.Foundation.CommonParamsBnd.Parameters_IN <a id="bosss.foundation.commonparamsbnd.parameters_in"></a>
**Summary:** parameter values on IN-cell


### Field: BoSSS.Foundation.CommonParamsBnd.EdgeTag <a id="bosss.foundation.commonparamsbnd.edgetag"></a>
**Summary:** edge tag for the respective edge (see [BoSSS.Foundation.Grid.IGeometricalEdgeData.EdgeTags](#bosss.foundation.grid.igeometricaledgedata.edgetags)).


### Field: BoSSS.Foundation.CommonParamsBnd.iEdge <a id="bosss.foundation.commonparamsbnd.iedge"></a>
**Summary:** edge index (local on current MPI rank)


### Property: BoSSS.Foundation.CommonParamsBnd.jCellIn <a id="bosss.foundation.commonparamsbnd.jcellin"></a>
**Summary:** Index of IN-cell (local geometrical index).


### Field: BoSSS.Foundation.CommonParamsBnd.time <a id="bosss.foundation.commonparamsbnd.time"></a>
**Summary:** Physical time.


### Field: BoSSS.Foundation.CommonParamsBnd.GridDat <a id="bosss.foundation.commonparamsbnd.griddat"></a>
**Summary:** reference to grid data structure.


### Property: BoSSS.Foundation.CommonParamsBnd.D <a id="bosss.foundation.commonparamsbnd.d"></a>
**Summary:** spatial dimension

## Class: BoSSS.Foundation.IInnerEdgeForm <a id="bosss.foundation.iinneredgeform"></a>

**Summary:** Defines a general _edge term_, i.e. a form
\[
a(\vec{U},v) = \int_{\partial K} f(\vec{U}) g(v) n  \mathrm{dS} .
\]


## Method: BoSSS.Foundation.IInnerEdgeForm.InnerEdgeForm(BoSSS.Foundation.CommonParams@,System.Double[],System.Double[],System.Double[0:,0:],System.Double[0:,0:],System.Double,System.Double,System.Double[],System.Double[]) <a id="bosss.foundation.iinneredgeform.inneredgeform(bosss.foundation.commonparams@,system.double[],system.double[],system.double[0:,0:],system.double[0:,0:],system.double,system.double,system.double[],system.double[])"></a>
**Summary:** The form which is integrated over interior edges
**Parameter:** `inp` - 
**Parameter:** `_uIN` - value of trial function on IN-cell
**Parameter:** `_Grad_uIN` - gradient of trial function on IN-cell
**Parameter:** `_vIN` - value of test function on IN-cell
**Parameter:** `_Grad_vIN` - gradient of test function on IN-cell
**Parameter:** `_uOUT` - value of trial function on OUT-cell
**Parameter:** `_Grad_uOUT` - gradient of trial function on OUT-cell
**Parameter:** `_vOUT` - value of test function on OUT-cell
**Parameter:** `_Grad_vOUT` - gradient of test function on OUT-cell
**Returns:**


## Class: BoSSS.Foundation.IBoundaryEdgeForm <a id="bosss.foundation.iboundaryedgeform"></a>

**Summary:** Defines a general _edge term_, i.e. a form
\[ 
a(\vec{U},v) = \int_{\partial K} f(\vec{U}) g(v) n  \mathrm{dS} .
\]


## Method: BoSSS.Foundation.IBoundaryEdgeForm.BoundaryEdgeForm(BoSSS.Foundation.CommonParamsBnd@,System.Double[],System.Double[0:,0:],System.Double,System.Double[]) <a id="bosss.foundation.iboundaryedgeform.boundaryedgeform(bosss.foundation.commonparamsbnd@,system.double[],system.double[0:,0:],system.double,system.double[])"></a>
**Summary:** The form which is integrated over boundary edges.
**Parameter:** `inp` - 
**Parameter:** `_uA` - value of trial function on IN-cell
**Parameter:** `_Grad_uA` - gradient of trial function on IN-cell
**Parameter:** `_vA` - value of test function on IN-cell
**Parameter:** `_Grad_vA` - gradient of test function on IN-cell
**Returns:**


## Class: BoSSS.Foundation.IEdgeForm <a id="bosss.foundation.iedgeform"></a>

**Summary:** Defines a general complete _edge term_ consisting of boundary and internal component, i.e. a form
\[ 
a(\vec{U},v) = \int_{\partial K} f(\vec{U}) g(v) n  \mathrm{dS} .
\]


### Property: BoSSS.Foundation.IEdgeForm.BoundaryEdgeTerms <a id="bosss.foundation.iedgeform.boundaryedgeterms"></a>
**Summary:** Activation Flags For Boundary Edges
[BoSSS.Foundation.TermActivationFlags](#bosss.foundation.termactivationflags)


### Property: BoSSS.Foundation.IEdgeForm.InnerEdgeTerms <a id="bosss.foundation.iedgeform.inneredgeterms"></a>
**Summary:** Activation Flags for Inner Edges 
[BoSSS.Foundation.TermActivationFlags](#bosss.foundation.termactivationflags)

## Class: BoSSS.Foundation.CommonParamsVol <a id="bosss.foundation.commonparamsvol"></a>

**Summary:** parameter value structure for interior edges.


### Field: BoSSS.Foundation.CommonParamsVol.jCell <a id="bosss.foundation.commonparamsvol.jcell"></a>
**Summary:** cell index.


### Field: BoSSS.Foundation.CommonParamsVol.GridDat <a id="bosss.foundation.commonparamsvol.griddat"></a>
**Summary:** reference to grid data structure.


### Field: BoSSS.Foundation.CommonParamsVol.time <a id="bosss.foundation.commonparamsvol.time"></a>
**Summary:** Physical time.


### Field: BoSSS.Foundation.CommonParamsVol.Parameters <a id="bosss.foundation.commonparamsvol.parameters"></a>
**Summary:** value of parameter fields.


### Field: BoSSS.Foundation.CommonParamsVol.Xglobal <a id="bosss.foundation.commonparamsvol.xglobal"></a>
**Summary:** node in global coordinates


### Property: BoSSS.Foundation.CommonParamsVol.D <a id="bosss.foundation.commonparamsvol.d"></a>
**Summary:** Spatial dimension.

## Class: BoSSS.Foundation.IVolumeForm <a id="bosss.foundation.ivolumeform"></a>

**Summary:** defines a volume term.
\[ 
a(\vec{U},v) = \int_{\Omega} f(\vec{U}) g(v)   \mathrm{dX}
\]


### Property: BoSSS.Foundation.IVolumeForm.VolTerms <a id="bosss.foundation.ivolumeform.volterms"></a>
**Summary:** [BoSSS.Foundation.TermActivationFlags](#bosss.foundation.termactivationflags)


## Method: BoSSS.Foundation.IVolumeForm.VolumeForm(BoSSS.Foundation.CommonParamsVol@,System.Double[],System.Double[0:,0:],System.Double,System.Double[]) <a id="bosss.foundation.ivolumeform.volumeform(bosss.foundation.commonparamsvol@,system.double[],system.double[0:,0:],system.double,system.double[])"></a>
**Summary:** bilinear form on volume integrals.
**Parameter:** `cpv` - 
**Parameter:** `GradU` - gradient of trial function
**Parameter:** `GradV` - gradient of test function
**Parameter:** `U` - value of trial function
**Parameter:** `V` - value of test function
**Returns:**


## Class: BoSSS.Foundation.VolumFormParams <a id="bosss.foundation.volumformparams"></a>

**Summary:** parameters on which volume forms 
(e.g. [BoSSS.Foundation.IVolumeForm_UxV](#bosss.foundation.ivolumeform_uxv), [BoSSS.Foundation.IVolumeForm_GradUxV](#bosss.foundation.ivolumeform_graduxv), [BoSSS.Foundation.IVolumeForm_UxGradV](#bosss.foundation.ivolumeform_uxgradv), [BoSSS.Foundation.IVolumeForm_GradUxGradV](#bosss.foundation.ivolumeform_graduxgradv))
may depend.


### Field: BoSSS.Foundation.VolumFormParams.j0 <a id="bosss.foundation.volumformparams.j0"></a>
**Summary:** first cell


### Field: BoSSS.Foundation.VolumFormParams.Len <a id="bosss.foundation.volumformparams.len"></a>
**Summary:** number of cells


### Field: BoSSS.Foundation.VolumFormParams.GridDat <a id="bosss.foundation.volumformparams.griddat"></a>
**Summary:** reference to the current grid


### Field: BoSSS.Foundation.VolumFormParams.time <a id="bosss.foundation.volumformparams.time"></a>
**Summary:** Physical time.


### Field: BoSSS.Foundation.VolumFormParams.ParameterVars <a id="bosss.foundation.volumformparams.parametervars"></a>
**Summary:** Values of parameter fields at quadrature nodes
array index: parameter variable, as specified by the parameter mapping (see [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering)); 
for each multidimensional array: 
- 1st index: cell 
- 2nd index: node


### Field: BoSSS.Foundation.VolumFormParams.Xglobal <a id="bosss.foundation.volumformparams.xglobal"></a>
**Summary:** quadrature nodes in global coordinates
- 1st index: cell 
- 2nd index: quad node 
- 3rd index: spatial direction

## Class: BoSSS.Foundation.IVolumeForm_UxV <a id="bosss.foundation.ivolumeform_uxv"></a>

**Summary:** a bi-linear form of the type
\[ 
a(U,v) = \sum_{l} \int_{\Gamma_{\mathrm{int}}} 
u_l  {f}_{l}(\vec{x}) v
\ \mathrm{dV}
\].
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$ denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.IVolumeForm_UxV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumeform_uxv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of ${f}_{l}(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `UxV` -
Output: the values of $f_l(\vec{x})$ 
- 1st index: cell index 
- 2nd index: quadrature node 
- 3rd index: correlates with argument ordering, i.e. index $l$, of trial function; see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)

## Class: BoSSS.Foundation.IVolumeForm_GradUxV <a id="bosss.foundation.ivolumeform_graduxv"></a>

**Summary:** a bi-linear form of the type
\[
a(U,v) = \sum_{l} \int_{\Gamma_{\mathrm{int}}} 
v \vec{f}_{l}(\vec{x}) \cdot \nabla u_l
\ \mathrm{dV}
\].
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$ denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.IVolumeForm_GradUxV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumeform_graduxv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{l}(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `GradUxV` -
Output: the values of $\vec{f}_{l}(\vec{x})$ 
- 1st index: cell index 
- 2nd index: quadrature node 
- 3rd index: correlates with argument ordering, i.e. index $l$, of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
- 4th index: component index of $\vec{f}_{l}(\vec{x})$, i.e. correlates with 
component index of trial function gradient $\nabla u_l$

## Class: BoSSS.Foundation.IVolumeForm_UxGradV <a id="bosss.foundation.ivolumeform_uxgradv"></a>

**Summary:** a bi-linear form of the type
\[ 
a(U,v) = \sum_{l} \int_{\Gamma_{\mathrm{int}}} 
\nabla v \cdot \vec{f}_{l}(\vec{x}) u_l
\ \mathrm{dV}
\].
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$ denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.IVolumeForm_UxGradV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumeform_uxgradv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{l}(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `UxGradV` -
- Output: the values of $\vec{f}_{l}(\vec{x})$ 
- 1st index: cell index 
- 2nd index: quadrature node 
- 3rd index: correlates with argument ordering, i.e. index $l$, of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
- 4th index: component index of $\vec{f}_{l}(\vec{x})$, i.e. correlates with 
component index of test function gradient $\nabla v$

## Class: BoSSS.Foundation.IVolumeForm_GradUxGradV <a id="bosss.foundation.ivolumeform_graduxgradv"></a>

**Summary:** a bi-linear form of the type
\[ 
a(U,v) = \sum_{l} \int_{\Gamma_{\mathrm{int}}} 
\nabla v^T \cdot \vec{\vec{f}}_{l}(\vec{x}) \cdot \nabla u_l
\ \mathrm{dV}
\].
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$ denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.IVolumeForm_GradUxGradV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumeform_graduxgradv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{\vec{f}}_{l}(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `GradUxGradV` - Output: the values of $\vec{\vec{f}}_{l}(\vec{x})$ 
1st index: cell index 
2nd index: quadrature node 
3rd index: correlates with argument ordering, i.e. index $l$, of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
4th index: row index of $\vec{\vec{f}}_{l}(\vec{x})$, i.e. correlates with 
component index of test function gradient $\nabla v$
5th index: column index of $\vec{\vec{f}}_{l}(\vec{x})$, i.e. correlates with 
component index of trial function gradient $\nabla u_l$

## Class: BoSSS.Foundation.IVolumeSource_V <a id="bosss.foundation.ivolumesource_v"></a>

**Summary:** a linear form of the type
\[ 
a(v) = \int_{\Gamma_{\mathrm{int}}} 
v \ f(\vec{x})
\ \mathrm{dV}
\]
where v denotes the test function (corresponds to co-domain variable).


## Method: BoSSS.Foundation.IVolumeSource_V.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumesource_v.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $f(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `V` - Output: the values of $f(\vec{x})$ 
1st index: cell index 
2nd index: quadrature node

## Class: BoSSS.Foundation.IVolumeSource_GradV <a id="bosss.foundation.ivolumesource_gradv"></a>

**Summary:** a linear form of the type
\[ 
a(v) = \int_{\Gamma_{\mathrm{int}}} 
\nabla v^T \cdot \vec{f}(\vec{x})
\ \mathrm{dV}
\]
where v denotes the test function (corresponds to co-domain variable).


## Method: BoSSS.Foundation.IVolumeSource_GradV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.ivolumesource_gradv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}(\vec{x})$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `GradV` - Output: the values of $\vec{f}(\vec{x})$ 
1st index: cell index 
2nd index: quadrature node 
3rd index: component index/spatial direction
of $\vec{f}(\vec{x})$, i.e. correlates with 
component index of test function gradient $\nabla v$

## Class: BoSSS.Foundation.INonlinVolumeForm_V <a id="bosss.foundation.inonlinvolumeform_v"></a>

**Summary:** a non-linear form of the type
\[ 
a(U,v) = \int_{\Gamma_{\mathrm{int}}} 
u_l  {f}(\vec{x},U) v
\ \mathrm{dV}
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$ denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.INonlinVolumeForm_V.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinvolumeform_v.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray)"></a>
**Summary:** the function ${f}(\vec{x},U,\nabla U)$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `f` - Output: the values of ${f}(\vec{x},U,\nabla U)$
1st index: cell index 
2nd index: quadrature node
**Parameter:** `U` - Input: the values of $U$
1st index: correlates with argument ordering, i.e. index $l$, of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
2nd index: cell index 
3rd index: quadrature node
**Parameter:** `GradU` - Input: the values of $\nabla U$ 
1st index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
2nd index: cell index 
3rd index: quadrature node 
4th index: spatial direction of derivative

## Class: BoSSS.Foundation.INonlinVolumeForm_GradV <a id="bosss.foundation.inonlinvolumeform_gradv"></a>

**Summary:** a non-linear form of the type
\[ 
a(U,v) = \int_{\Gamma_{\mathrm{int}}} 
\nabla v^T \cdot \vec{f}(\vec{x},U,\nabla U)
\ \mathrm{dV}
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).


## Method: BoSSS.Foundation.INonlinVolumeForm_GradV.Form(BoSSS.Foundation.VolumFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinvolumeform_gradv.form(bosss.foundation.volumformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}(\vec{x},U,\nabla U)$
**Parameter:** `prm` - parameters on which the form may depend
**Parameter:** `U` - Input: the values of $U$ 
1st index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
2nd index: cell index 
3rd index: quadrature node
**Parameter:** `GradU` - Input: the values of $\nabla U$ 
1st index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
2nd index: cell index 
3rd index: quadrature node 
4th index: spatial direction of derivative
**Parameter:** `f` - Output: the values of $\vec{f}(\vec{x},U,\nabla U)$  
1st index: cell index 
2nd index: quadrature node 
3rd index: vector-component of $\vec{f}$

## Class: BoSSS.Foundation.EdgeFormParams <a id="bosss.foundation.edgeformparams"></a>

**Summary:** parameters on which edge forms (e.g. [BoSSS.Foundation.IEdgeForm_UxV](#bosss.foundation.iedgeform_uxv), [BoSSS.Foundation.IEdgeform_GradUxV](#bosss.foundation.iedgeform_graduxv), [BoSSS.Foundation.IEdgeform_UxGradV](#bosss.foundation.iedgeform_uxgradv), [BoSSS.Foundation.IEdgeSource_V](#bosss.foundation.iedgesource_v), [BoSSS.Foundation.IEdgeSource_GradV](#bosss.foundation.iedgesource_gradv))
may depend.


### Field: BoSSS.Foundation.EdgeFormParams.Nodes <a id="bosss.foundation.edgeformparams.nodes"></a>
**Summary:** Quadrature nodes in global coordinates. 
- 1st index: edge
- 2nd index: quadrature node
- 3rd index: spatial direction


### Field: BoSSS.Foundation.EdgeFormParams.Normals <a id="bosss.foundation.edgeformparams.normals"></a>
**Summary:** Edge normals at quadrature nodes. 
- 1st index: edge
- 2nd index: quadrature node
- 3rd index: spatial direction


### Field: BoSSS.Foundation.EdgeFormParams.ParameterVars_IN <a id="bosss.foundation.edgeformparams.parametervars_in"></a>
**Summary:** Values of parameter fields at quadrature nodes, for the IN-cell:
array index: parameter variable, as specified by the parameter mapping (see [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering)); 
for each multidimensional array: 
- 1st index: cell
- 2nd index: node


### Field: BoSSS.Foundation.EdgeFormParams.ParameterVars_OUT <a id="bosss.foundation.edgeformparams.parametervars_out"></a>
**Summary:** Values of parameter fields at quadrature nodes, for the OUT-cell:
array index: parameter variable, as specified by the parameter mapping (see [BoSSS.Foundation.IEquationComponent.ParameterOrdering](#bosss.foundation.iequationcomponent.parameterordering)); 
for each multidimensional array:
- 1st index: cell
- 2nd index: node


### Field: BoSSS.Foundation.EdgeFormParams.e0 <a id="bosss.foundation.edgeformparams.e0"></a>
**Summary:** first edge


### Field: BoSSS.Foundation.EdgeFormParams.Len <a id="bosss.foundation.edgeformparams.len"></a>
**Summary:** number of edges


### Field: BoSSS.Foundation.EdgeFormParams.time <a id="bosss.foundation.edgeformparams.time"></a>
**Summary:** Physical time.


### Field: BoSSS.Foundation.EdgeFormParams.GridDat <a id="bosss.foundation.edgeformparams.griddat"></a>
**Summary:** reference to the current grid

## Class: BoSSS.Foundation.IInnerEdgeform_UxV <a id="bosss.foundation.iinneredgeform_uxv"></a>

**Summary:** Inner edge integrand of [BoSSS.Foundation.IEdgeForm_UxV](#bosss.foundation.iedgeform_uxv)


## Method: BoSSS.Foundation.IInnerEdgeform_UxV.InternalEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgeform_uxv.internaledge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of ${f}_{i \ j \ l}(\vec{x})$   on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `UxV` -
output: the values of ${f}_{i \ j \ l}(\vec{x})$:
- 1st index: edge index
- 2nd index: quadrature node
- 3rd index: in and out - coefficients with respect to trial function, i.e. index $i$ 
('U': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
- 4th index: in and out - coefficients with respect to test function, i.e. index $j$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
- 5th index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)

## Class: BoSSS.Foundation.IBoundaryEdgeform_UxV <a id="bosss.foundation.iboundaryedgeform_uxv"></a>

**Summary:** Boundary edge integrand of [BoSSS.Foundation.IEdgeForm_UxV](#bosss.foundation.iedgeform_uxv)


## Method: BoSSS.Foundation.IBoundaryEdgeform_UxV.BoundaryEdge_UxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgeform_uxv.boundaryedge_uxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of ${f}_{0 \ 0 \ l}(\vec{x})$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `UxV` - output: the values of ${f}_{0 \ 0 \ l}(\vec{x})$ :
1st index: edge index
2nd index: quadrature node
3rd index: correlates with argument ordering (of trial function; see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)

## Class: BoSSS.Foundation.IEdgeForm_UxV <a id="bosss.foundation.iedgeform_uxv"></a>

**Summary:** a bi-linear form of the type
\[
a(U,v) = \sum_{l} \oint_{\Gamma_{\mathrm{int}}} 
u^\mathrm{in}_l  {f}_{0 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
+ u^\mathrm{in}_l  {f}_{0 \ 1 \ l}(\vec{x}) v^\mathrm{out} 
+ u^\mathrm{out}_l {f}_{1 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
+ u^\mathrm{out}_l {f}_{1 \ 1 \ l}(\vec{x}) v^\mathrm{out} 
\ \mathrm{dS}
+
\sum_{l} \oint_{\partial \Omega} 
u^\mathrm{in}_\gamma {f}_{0 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.IEdgeform_GradUxV <a id="bosss.foundation.iedgeform_graduxv"></a>

**Summary:** a bi-linear form of the type
\[
a(U,v) = \sum_{l} \oint_{\Gamma_{\mathrm{int}}} 
\nabla u^\mathrm{in}_l  \cdot \vec{f}_{0 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
+ \nabla u^\mathrm{in}_l  \cdot \vec{f}_{0 \ 1 \ l}(\vec{x}) v^\mathrm{out} 
+ \nabla u^\mathrm{out}_l \cdot \vec{f}_{1 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
+ \nabla u^\mathrm{out}_l \cdot \vec{f}_{1 \ 1 \ l}(\vec{x}) v^\mathrm{out} 
\ \mathrm{dS}
+
\sum_{l} \oint_{\partial \Omega} 
\nabla u^\mathrm{in}_\gamma \cdot \vec{f}_{0 \ 0 \ l}(\vec{x}) v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.IInnerEdgeform_GradUxV <a id="bosss.foundation.iinneredgeform_graduxv"></a>

**Summary:** Inner part of [BoSSS.Foundation.IEdgeform_GradUxV](#bosss.foundation.iedgeform_graduxv)


## Method: BoSSS.Foundation.IInnerEdgeform_GradUxV.InternalEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgeform_graduxv.internaledge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{i \ j \ l}(\vec{x})$   on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `GradUxV` - output: the values of $\vec{f}_{i \ j \ l}(\vec{x})$ :
1st index: edge index
2nd index: quadrature node
3rd index: in and out - coefficients with respect to trial function, i.e. index $i$ 
('U': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
4th index: in and out - coefficients with respect to test function, i.e. index $j$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
5th index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
6th index: spatial direction of trial ('U') function gradient

## Class: BoSSS.Foundation.IBoundaryEdgeform_GradUxV <a id="bosss.foundation.iboundaryedgeform_graduxv"></a>

**Summary:** Boundary part of [BoSSS.Foundation.IEdgeform_GradUxV](#bosss.foundation.iedgeform_graduxv)


## Method: BoSSS.Foundation.IBoundaryEdgeform_GradUxV.BoundaryEdge_GradUxV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgeform_graduxv.boundaryedge_graduxv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `GradUxV` - output: the values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$ :
1st index: edge index
2nd index: quadrature node
3rd index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
4th index: spatial direction of trial function gradient

## Class: BoSSS.Foundation.IEdgeform_UxGradV <a id="bosss.foundation.iedgeform_uxgradv"></a>

**Summary:** a bi-linear form of the type
\[ 
a(U,v) = \sum_{l} \oint_{\Gamma_{\mathrm{int}}} 
u^\mathrm{in}_l  \vec{f}_{0 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
+ u^\mathrm{in}_l  \vec{f}_{0 \ 1 \ l}(\vec{x}) \cdot \nabla v^\mathrm{out} 
+ u^\mathrm{out}_l \vec{f}_{1 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
+ u^\mathrm{out}_l \vec{f}_{1 \ 1 \ l}(\vec{x}) \cdot \nabla v^\mathrm{out} 
\ \mathrm{dS}
+
\sum_{l} \oint_{\partial \Omega} 
u^\mathrm{in}_\gamma \vec{f}_{0 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.IInnerEdgeform_UxGradV <a id="bosss.foundation.iinneredgeform_uxgradv"></a>

**Summary:** [BoSSS.Foundation.IInnerEdgeform_UxGradV](#bosss.foundation.iinneredgeform_uxgradv)


## Method: BoSSS.Foundation.IInnerEdgeform_UxGradV.InternalEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgeform_uxgradv.internaledge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{i \ j \ l}(\vec{x})$   on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `UxGradV` - Output: the value of $\vec{f}_{i \ j \ l}(\vec{x})$  
1st index: edge index
2nd index: quadrature node
3rd index: in and out - coefficients with respect to trial function, i.e. index $i$ 
('U': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
4th index: in and out - coefficients with respect to test function, i.e. index $j$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
5th index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
6th index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.IBoundaryEdgeform_UxGradV <a id="bosss.foundation.iboundaryedgeform_uxgradv"></a>

**Summary:** [BoSSS.Foundation.IEdgeform_UxGradV](#bosss.foundation.iedgeform_uxgradv)


## Method: BoSSS.Foundation.IBoundaryEdgeform_UxGradV.BoundaryEdge_UxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgeform_uxgradv.boundaryedge_uxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `UxGradV` - Output: values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$ .
1st index: edge index
2nd index: quadrature node
3rd index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
4th index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.IEdgeform_GradUxGradV <a id="bosss.foundation.iedgeform_graduxgradv"></a>

**Summary:** a bi-linear form of the type
\[ 
a(U,v) = \sum_{l} \oint_{\Gamma_{\mathrm{int}}} 
(u^\mathrm{in}_l)^T   \cdot \vec{\vec{f}}_{0 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
+ (u^\mathrm{in}_l)^T   \cdot \vec{\vec{f}}_{0 \ 1 \ l}(\vec{x}) \cdot \nabla v^\mathrm{out} 
+ (u^\mathrm{out}_l)^T  \cdot \vec{\vec{f}}_{1 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
+ (u^\mathrm{out}_l)^T  \cdot \vec{\vec{f}}_{1 \ 1 \ l}(\vec{x}) \cdot \nabla v^\mathrm{out} 
\ \mathrm{dS}
+
\sum_{l} \oint_{\partial \Omega} 
u^\mathrm{in}_\gamma \vec{f}_{0 \ 0 \ l}(\vec{x}) \cdot \nabla v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.IInnerEdgeform_GradUxGradV <a id="bosss.foundation.iinneredgeform_graduxgradv"></a>

**Summary:** Inner part of [BoSSS.Foundation.IEdgeform_GradUxGradV](#bosss.foundation.iedgeform_graduxgradv)


## Method: BoSSS.Foundation.IInnerEdgeform_GradUxGradV.InternalEdge_GradUxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgeform_graduxgradv.internaledge_graduxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{i \ j \ l}(\vec{x})$   on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `GradUxGradV` - Output: the value of $\vec{f}_{i \ j \ l}(\vec{x})$  
1st index: edge index
2nd index: quadrature node
3rd index: in and out - coefficients with respect to trial function, i.e. index $i$ 
('U': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
4th index: in and out - coefficients with respect to test function, i.e. index $j$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell). 
5th index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
6th index: spatial direction of test function ('U') gradient  
7th index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.IBoundaryEdgeform_GradUxGradV <a id="bosss.foundation.iboundaryedgeform_graduxgradv"></a>

**Summary:** Boundary part of [BoSSS.Foundation.IEdgeform_GradUxGradV](#bosss.foundation.iedgeform_graduxgradv)


## Method: BoSSS.Foundation.IBoundaryEdgeform_GradUxGradV.BoundaryEdge_GradUxGradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgeform_graduxgradv.boundaryedge_graduxgradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `GradUxGradV` - Output: values of $\vec{f}_{0 \ 0 \ l}(\vec{x})$ .
1st index: edge index
2nd index: quadrature node
3rd index: correlates with argument ordering, i.e. index $l$ , of trial function; 
see [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering) 
4th index: spatial direction of test function ('U') gradient 
5th index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.IEdgeSource_V <a id="bosss.foundation.iedgesource_v"></a>

**Summary:** a linear form of the type
\[
a(v) = 
\oint_{\Gamma_{\mathrm{int}}} f_{0}(\vec{x}) v^\mathrm{in} + f_{1}(\vec{x}) v^\mathrm{out}  \ \mathrm{dS}
+ \oint_{\partial \Omega} f_{0}(\vec{x}) v^\mathrm{in}  \ \mathrm{dS}
\]
where v denotes the test function.

## Class: BoSSS.Foundation.IInnerEdgeSource_V <a id="bosss.foundation.iinneredgesource_v"></a>

**Summary:** [BoSSS.Foundation.IEdgeSource_V](#bosss.foundation.iedgesource_v)


## Method: BoSSS.Foundation.IInnerEdgeSource_V.InternalEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgesource_v.internaledge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the point-wise source term $f_{i}(\vec{x})$  on interior edges $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - parameters on which  $f$  may depend on.
**Parameter:** `V` - Output: the value of $f(\vec{x})$ , which will be multiplied with the test function gradient. 
1st index: edge index
2nd index: quadrature node
3rd index: in and out - coefficients with respect to test function, i.e. index $i$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell).

## Class: BoSSS.Foundation.IBoundaryEdgeSource_V <a id="bosss.foundation.iboundaryedgesource_v"></a>

**Summary:** [BoSSS.Foundation.IEdgeSource_V](#bosss.foundation.iedgesource_v)


## Method: BoSSS.Foundation.IBoundaryEdgeSource_V.BoundaryEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgesource_v.boundaryedge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the point-wise source term $f_{0}(\vec{x})$ on boundary edges $\partial \Omega$ .
**Parameter:** `efp` - parameters on which $f$ may depend on.
**Parameter:** `V` - Output: the value of $f(\vec{x})$ , which will be multiplied with the test function gradient. 
The value of the test function.
1st index: edge index
2nd index: quadrature node

## Class: BoSSS.Foundation.IEdgeSource_GradV <a id="bosss.foundation.iedgesource_gradv"></a>

**Summary:** a linear form of the type
\[
a(v) = \oint_{\Gamma_{\mathrm{int}}} 
\vec{f}_{0}(\vec{x}) \cdot \nabla v^\mathrm{in} 
+ \vec{f}_{1}(\vec{x}) \cdot \nabla v^\mathrm{out} \ \mathrm{dS}
+ \oint_{\partial \Omega} \vec{f}_{0}(\vec{x}) \cdot \nabla v^\mathrm{in} \ \mathrm{dS}
\]
where v denotes the test function.

## Class: BoSSS.Foundation.IInnerEdgeSource_GradV <a id="bosss.foundation.iinneredgesource_gradv"></a>

**Summary:** [BoSSS.Foundation.IEdgeSource_GradV](#bosss.foundation.iedgesource_gradv)


## Method: BoSSS.Foundation.IInnerEdgeSource_GradV.InternalEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iinneredgesource_gradv.internaledge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the point-wise source term $\vec{f}_{i}(\vec{x})$  on interior edges $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - parameters on which $\vec{f}$ may depend on.
**Parameter:** `GradV` -
Output: the value of $\vec{f}_{i}(\vec{x})$ , which will be multiplied with the test function gradient.
- 1st index: edge index
- 2nd index: quadrature node
- 3rd index: in and out - coefficients with respect to test function, i.e. index $i$ 
('V': index 0 corresponds to IN-cell, index 1 corresponds to OUT-cell).
- 4th index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.IBoundaryEdgeSource_GradV <a id="bosss.foundation.iboundaryedgesource_gradv"></a>

**Summary:** [BoSSS.Foundation.IEdgeSource_GradV](#bosss.foundation.iedgesource_gradv)


## Method: BoSSS.Foundation.IBoundaryEdgeSource_GradV.BoundaryEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray) <a id="bosss.foundation.iboundaryedgesource_gradv.boundaryedge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray)"></a>
**Summary:** the point-wise source term $\vec{f}_{0}(\vec{x})$  on boundary edges $\partial \Omega$ .
**Parameter:** `efp` - parameters on which $\vec{f}$  may depend on.
**Parameter:** `GradV` - Output: the value of $\vec{f}_{0}(\vec{x})$ , which will be multiplied with the test function gradient. 
1st index: edge index
2nd index: quadrature node
3rd index: spatial direction of test function ('V') gradient

## Class: BoSSS.Foundation.INonlinEdgeForm_V <a id="bosss.foundation.inonlinedgeform_v"></a>

**Summary:** a form of the type
\[ 
a(U,v) = \oint_{\Gamma_{\mathrm{int}}} 
{f}^\mathrm{in} (\vec{x}, U^\mathrm{in}, U^\mathrm{out}, \nabla U^\mathrm{in}, \nabla U^\mathrm{out}) v^\mathrm{in} 
+ {f}^\mathrm{out}(\vec{x}, U^\mathrm{in}, U^\mathrm{out}, \nabla U^\mathrm{in}, \nabla U^\mathrm{out}) v^\mathrm{out} 
\ \mathrm{dS}
+
\oint_{\partial \Omega} 
{f}_{0}(\vec{x}, U^\mathrm{in}, \nabla U^\mathrm{in}) v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.INonlinInnerEdgeForm_V <a id="bosss.foundation.inonlininneredgeform_v"></a>

**Summary:** [BoSSS.Foundation.INonlinEdgeForm_V](#bosss.foundation.inonlinedgeform_v)


## Method: BoSSS.Foundation.INonlinInnerEdgeForm_V.NonlinInternalEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlininneredgeform_v.nonlininternaledge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of ${f}^{*}(\ldots)$ on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `fin` -
- output: the values of ${f}^\mathrm{in}(\ldots)$ :
- 1st index: edge index
- 2nd index: quadrature node
**Parameter:** `fot` - output: the values of ${f}^\mathrm{out}(\ldots)$
**Parameter:** `Uin` -
- input: the values of $U^\mathrm{in}$ 
- 1st index: component index of $U$
- 2nd index: edge index
- 3rd index: quadrature node
**Parameter:** `Uout` - analog to 'Uin', for 'out'-values.
**Parameter:** `GradUin` - input: the values of $\nabla U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
4th index: spatial direction of derivative
**Parameter:** `GradUout` - analog to 'GradUin', for 'out'-values.

## Class: BoSSS.Foundation.INonlinBoundaryEdgeForm_V <a id="bosss.foundation.inonlinboundaryedgeform_v"></a>

**Summary:** [BoSSS.Foundation.INonlinEdgeForm_V](#bosss.foundation.inonlinedgeform_v)


## Method: BoSSS.Foundation.INonlinBoundaryEdgeForm_V.NonlinBoundaryEdge_V(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinboundaryedgeform_v.nonlinboundaryedge_v(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray)"></a>
**Summary:** the values of ${f}^\mathrm{in}(\ldots)$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `fin` - output: the values of ${f}^\mathrm{in}(\ldots)$ :
1st index: edge index
2nd index: quadrature node
**Parameter:** `Uin` - input: the values of $U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
**Parameter:** `GradUin` - input: the values of $\nabla U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
4th index: spatial direction of derivative

## Class: BoSSS.Foundation.INonlinEdgeForm_GradV <a id="bosss.foundation.inonlinedgeform_gradv"></a>

**Summary:** a form of the type
\[
a(U,v) = \oint_{\Gamma_{\mathrm{int}}} 
\vec{f}^\mathrm{in}  (\vec{x}, U^\mathrm{in}, U^\mathrm{out}, \nabla U^\mathrm{in}, \nabla U^\mathrm{out}) \cdot \nabla v^\mathrm{in} 
+ \vec{f}^\mathrm{out} (\vec{x}, U^\mathrm{in}, U^\mathrm{out}, \nabla U^\mathrm{in}, \nabla U^\mathrm{out}) \cdot \nabla v^\mathrm{out} 
\ \mathrm{dS}
+
\oint_{\partial \Omega} 
\vec{f}^\mathrm{in}  (\vec{x}, U^\mathrm{in}, \nabla U^\mathrm{in}) \cdot \nabla v^\mathrm{in} 
\ \mathrm{dS}          
\]
where v denotes the test function (corresponds to co-domain variable) and 
$U = (u_0, \ldots, u_{L-1} )$  denotes the trial functions (correspond to domain variable, defined by the 
argument ordering [BoSSS.Foundation.IEquationComponent.ArgumentOrdering](#bosss.foundation.iequationcomponent.argumentordering)).

## Class: BoSSS.Foundation.INonlinInnerEdgeForm_GradV <a id="bosss.foundation.inonlininneredgeform_gradv"></a>

**Summary:** [BoSSS.Foundation.INonlinEdgeForm_GradV](#bosss.foundation.inonlinedgeform_gradv)


## Method: BoSSS.Foundation.INonlinInnerEdgeForm_GradV.NonlinInternalEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlininneredgeform_gradv.nonlininternaledge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray,ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}^{*}(\ldots)$   on interior edges on $\Gamma_{\mathrm{int}}$ .
**Parameter:** `efp` - 
**Parameter:** `fIN` - output: the values of ${f}^\mathrm{in}(\ldots)$ :
1st index: edge index
2nd index: quadrature node
3rd index: component index of $\vec{f}^\mathrm{in}(\ldots)$ .
**Parameter:** `fOT` - like 'fIN', for OUT-cells.
**Parameter:** `Uin` - input: the values of $U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
**Parameter:** `Uout` - analog to 'Uin', for 'out'-values.
**Parameter:** `GradUin` - input: the values of $\nabla U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
4th index: spatial direction of derivative
**Parameter:** `GradUout` - analog to 'GradUin', for 'out'-values.

## Class: BoSSS.Foundation.INonlinBoundaryEdgeForm_GradV <a id="bosss.foundation.inonlinboundaryedgeform_gradv"></a>

**Summary:** [BoSSS.Foundation.INonlinEdgeForm_GradV](#bosss.foundation.inonlinedgeform_gradv)


## Method: BoSSS.Foundation.INonlinBoundaryEdgeForm_GradV.NonlinBoundaryEdge_GradV(BoSSS.Foundation.EdgeFormParams@,ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray[],ilPSP.MultidimensionalArray) <a id="bosss.foundation.inonlinboundaryedgeform_gradv.nonlinboundaryedge_gradv(bosss.foundation.edgeformparams@,ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray[],ilpsp.multidimensionalarray)"></a>
**Summary:** the values of $\vec{f}_{0}(\ldots)$   on boundary edges on $\partial \Omega$ .
**Parameter:** `efp` - 
**Parameter:** `f` - output: the values of ${f}_{0}(\ldots)$ :
1st index: edge index
2nd index: quadrature node
3rd index: component index of $\vec{f}_{i}(\ldots)$ .
**Parameter:** `Uin` - input: the values of $U^\mathrm{in}$ 
1st index: component index of $U$ 
2nd index: edge index
3rd index: quadrature node
**Parameter:** `GradUin` -
input: the values of $\nabla U^\mathrm{in}$ 
- 1st index: component index of $U$ 
- 2nd index: edge index
- 3rd index: quadrature node
- 4th index: spatial direction of derivative

## Class: BoSSS.Foundation.IEquationComponentExtension <a id="bosss.foundation.iequationcomponentextension"></a>

**Summary:** extension methods for the [BoSSS.Foundation.IEquationComponent](#bosss.foundation.iequationcomponent)-interface


## Method: BoSSS.Foundation.IEquationComponentExtension.Operator(BoSSS.Foundation.IEquationComponent,System.Int32,System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme},System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.CellQuadratureScheme},System.Boolean) <a id="bosss.foundation.iequationcomponentextension.operator(bosss.foundation.iequationcomponent,system.int32,system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.edgequadraturescheme},system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.cellquadraturescheme},system.boolean)"></a>
**Summary:** creates the spatial operator that consists only of component 'c'


## Method: BoSSS.Foundation.IEquationComponentExtension.Operator(BoSSS.Foundation.IEquationComponent,System.Func{System.Int32[],System.Int32[],System.Int32[],System.Int32},System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme},System.Func{BoSSS.Foundation.Grid.IGridData,BoSSS.Foundation.Quadrature.CellQuadratureScheme},System.Boolean) <a id="bosss.foundation.iequationcomponentextension.operator(bosss.foundation.iequationcomponent,system.func{system.int32[],system.int32[],system.int32[],system.int32},system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.edgequadraturescheme},system.func{bosss.foundation.grid.igriddata,bosss.foundation.quadrature.cellquadraturescheme},system.boolean)"></a>
**Summary:** creates the spatial operator that consists only of component 'c'


## Method: BoSSS.Foundation.IEquationComponentExtension.ComputeMatrixEx``2(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,``0,``1,System.Boolean,System.Double,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Collections.BitArray,System.Boolean) <a id="bosss.foundation.iequationcomponentextension.computematrixex``2(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,``0,``1,system.boolean,system.double,bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme,system.collections.bitarray,system.boolean)"></a>
**Summary:** computes the affine offset and/or matrix of the operator, expert
version;
**Parameter:** `DomainMap` - the mapping which is used to compute column indices into
'Matrix';
**Parameter:** `Parameters` - The parameter variables (of this differential operator);
The number of elements in the list must match the parameter count
of the differential operator (see
[BoSSS.Foundation.DifferentialOperator.ParameterVar](#bosss.foundation.differentialoperator.parametervar));  It is allowed to set
an entry to 'null', in this case the values of the parameter field
are assumed to be 0.0; If the differential operator contains no
parameters, this argument can be null;
**Parameter:** `CodomainMap` - the mapping which is used to compute row indices into
'Matrix' and 'AffineOffset'.
**Parameter:** `Matrix` - Acc output: the matrix which represents the linear part of this
operator, according to the mapping given by
'DomainMap' and 'CodomainMap',
is ACCUMULATED here; 
Setting all matrix entries to 0.0 is left to the user;
**Parameter:** `AffineOffset` - Acc output: the vector which represents the affine part of this
operator, according to the mapping given by
'DomainMap' and 'CodomainMap',
is ACCUMULATED here; 
Setting all vector entries to 0.0 is left to the user;
**Parameter:** `OnlyAffine` - If true, only the 'AffineOffset' is computed, and
the 'Matrix' is not touched (can be null);
**Parameter:** `edgeQuadScheme` - Quadrature scheme for edge integration;
**Parameter:** `volQuadScheme` - Quadrature scheme for volume integration;
**Parameter:** `SubGridBoundaryMask` - 
**Parameter:** `ParameterMPIExchange` - Determines whether parameter fields have to exchange ghost cell
data before the assembly of the operator.
**Parameter:** `time` - 
**Parameter:** `op` - 
**Remark:**
The operator assembly must be finalized before by calling
[BoSSS.Foundation.IDifferentialOperator.Commit(System.Boolean)](#bosss.foundation.idifferentialoperator.commit(system.boolean)) before this method can be called.


## Method: BoSSS.Foundation.IEquationComponentExtension.ComputeAffine``1(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,``0,System.Boolean,System.Double,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.iequationcomponentextension.computeaffine``1(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,``0,system.boolean,system.double,bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** another legacy interface


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,System.Double,System.Double,BoSSS.Foundation.CoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.CoordinateMapping,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme,BoSSS.Foundation.SubGridBoundaryModes,System.Double) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,system.double,system.double,bosss.foundation.coordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.coordinatemapping,bosss.foundation.grid.subgrid,bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme,bosss.foundation.subgridboundarymodes,system.double)"></a>
**Summary:** Evaluates this operator for given DG fields;
**Parameter:** `op` - 
**Parameter:** `time` - 
**Parameter:** `DomainMapping` - the domain variables, or "input data" for the operator; the number
of elements must be equal to the number of elements in the [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar)-list;
**Parameter:** `Params` - List of parameter fields; May be null
**Parameter:** `CodomainMapping` - the co-domain variables, or "output" for the evaluation of the
operator; the number of elements must be equal to the number of elements in the [BoSSS.Foundation.IDifferentialOperator.CodomainVar](#bosss.foundation.idifferentialoperator.codomainvar)-list;
**Parameter:** `alpha` - scaling of the operator
**Parameter:** `beta` - scaling of the accumulator ('CodomainMapping');
**Parameter:** `sgrd` - subgrid, for restricted evaluation; null indicates evaluation on
the full grid.
**Parameter:** `bndMode` - Treatment of subgrid boundaries, if 'sgrd' is not null. See [BoSSS.Foundation.IEvaluator.SubGridBoundaryTreatment](#bosss.foundation.ievaluator.subgridboundarytreatment)
**Parameter:** `qInsEdge` - Optional definition of the edge quadrature scheme. Since this
already implies a domain of integration, must be null if
'sgrd' is not null.
**Parameter:** `qInsVol` - Optional definition of the volume quadrature scheme. Since this
already implies a domain of integration, must be null if
'sgrd' is not null.
**Remark:**
If some of the input data, 'DomainMapping', is
contained in the  output data, 'CodomainMapping',
these DG fields will be cloned to ensure correct operation of the
operator evaluation.


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Double) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},system.double)"></a>
**Summary:** Another wrapper for operator evaluation
**Parameter:** `DomainFields` - the domain variables; the number of elements
must be equal to the number of elements in the [BoSSS.Foundation.IDifferentialOperator.DomainVar](#bosss.foundation.idifferentialoperator.domainvar)-list;
**Parameter:** `CodomainFields` - the codomain variables; the number of elements
must be equal to the number of elements in the [BoSSS.Foundation.IDifferentialOperator.CodomainVar](#bosss.foundation.idifferentialoperator.codomainvar)-list;
**Parameter:** `op` - 
**Parameter:** `time` - 
**Remark:**
If some of the input field, i.e. some element of 'DomainFields', is contained in the 
output fields, i.e. in the list 'CodomainFields', these DG fields will be cloned to ensure 
correct operation of the operator evaluation.
It is not a good choice to use this 
function if this operator should be evaluated multiple times
and 
contains linear components (i.e. [BoSSS.Foundation.IDifferentialOperator.IsLinear](#bosss.foundation.idifferentialoperator.islinear) returns true);
If the later one is the case, the matrix which represents
the linear components of the operator must be computed first, which is computational- and
memory - intensive;
After execution of this method, the matrix will be lost;
If multiple evaluation is desired, the [BoSSS.Foundation.IDifferentialOperator.GetEvaluatorEx(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)](#bosss.foundation.idifferentialoperator.getevaluatorex(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping))-method should be used.


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,bosss.foundation.dgfield[])"></a>
**Summary:** And another wrapper.


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,System.Double,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,system.double,bosss.foundation.dgfield[])"></a>
**Summary:** And another wrapper.


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,System.Double,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,system.double,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes,bosss.foundation.dgfield[])"></a>
**Summary:** And another wrapper.


## Method: BoSSS.Foundation.IEquationComponentExtension.Evaluate(BoSSS.Foundation.DifferentialOperator,System.UInt32,System.UInt32,System.Double,BoSSS.Foundation.DGField[]) <a id="bosss.foundation.iequationcomponentextension.evaluate(bosss.foundation.differentialoperator,system.uint32,system.uint32,system.double,bosss.foundation.dgfield[])"></a>
**Summary:** And another wrapper.


## Method: BoSSS.Foundation.IEquationComponentExtension.ComputeMatrix``2(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,``0,``1,System.Boolean,System.Double,BoSSS.Foundation.Grid.SubGrid) <a id="bosss.foundation.iequationcomponentextension.computematrix``2(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,``0,``1,system.boolean,system.double,bosss.foundation.grid.subgrid)"></a>
**Summary:** simplified version of 
[BoSSS.Foundation.IEquationComponentExtension.ComputeMatrixEx``2(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,``0,``1,System.Boolean,System.Double,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Collections.BitArray,System.Boolean)](#bosss.foundation.iequationcomponentextension.computematrixex``2(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,``0,``1,system.boolean,system.double,bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme,system.collections.bitarray,system.boolean));


## Method: BoSSS.Foundation.IEquationComponentExtension.ComputeMatrix(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,System.Double,BoSSS.Foundation.Grid.SubGrid) <a id="bosss.foundation.iequationcomponentextension.computematrix(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,system.double,bosss.foundation.grid.subgrid)"></a>
**Summary:** simplified version of 
[BoSSS.Foundation.IEquationComponentExtension.ComputeMatrixEx``2(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,``0,``1,System.Boolean,System.Double,BoSSS.Foundation.Quadrature.EdgeQuadratureScheme,BoSSS.Foundation.Quadrature.CellQuadratureScheme,System.Collections.BitArray,System.Boolean)](#bosss.foundation.iequationcomponentextension.computematrixex``2(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,``0,``1,system.boolean,system.double,bosss.foundation.quadrature.edgequadraturescheme,bosss.foundation.quadrature.cellquadraturescheme,system.collections.bitarray,system.boolean));


## Method: BoSSS.Foundation.IEquationComponentExtension.ComputeAffine(BoSSS.Foundation.DifferentialOperator,BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping,System.Double) <a id="bosss.foundation.iequationcomponentextension.computeaffine(bosss.foundation.differentialoperator,bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping,system.double)"></a>
**Summary:** legacy interface

## Class: BoSSS.Foundation.IEvaluator <a id="bosss.foundation.ievaluator"></a>

**Summary:** Evaluation and matrix assembly of Spatial operators


### Property: BoSSS.Foundation.IEvaluator.GridData <a id="bosss.foundation.ievaluator.griddata"></a>
**Summary:** Grid, on which this evaluator operates on.


### Property: BoSSS.Foundation.IEvaluator.CodomainMapping <a id="bosss.foundation.ievaluator.codomainmapping"></a>
**Summary:** coordinate mapping for the co-domain variables (test functions, row mapping for matrix assembly, output of operator).


### Property: BoSSS.Foundation.IEvaluator.DomainMapping <a id="bosss.foundation.ievaluator.domainmapping"></a>
**Summary:** coordinate mapping for the domain variables (trial functions, column mapping for matrix assembly, input of operator).


### Property: BoSSS.Foundation.IEvaluator.Parameters <a id="bosss.foundation.ievaluator.parameters"></a>
**Summary:** List of parameter fields, correlates with [BoSSS.Foundation.DifferentialOperator.ParameterVar](#bosss.foundation.differentialoperator.parametervar).


## Method: BoSSS.Foundation.IEvaluator.ActivateSubgridBoundary(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.ievaluator.activatesubgridboundary(bosss.foundation.grid.cellmask,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Turns on  the sub-grid thing uses for local-time-stepping.


### Property: BoSSS.Foundation.IEvaluator.SubGridBoundaryTreatment <a id="bosss.foundation.ievaluator.subgridboundarytreatment"></a>
**Summary:** Actual value set by [BoSSS.Foundation.IEvaluator.ActivateSubgridBoundary(BoSSS.Foundation.Grid.CellMask,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.ievaluator.activatesubgridboundary(bosss.foundation.grid.cellmask,bosss.foundation.subgridboundarymodes))


### Property: BoSSS.Foundation.IEvaluator.time <a id="bosss.foundation.ievaluator.time"></a>
**Summary:** Time passed e.g. to [BoSSS.Foundation.CommonParams.time](#bosss.foundation.commonparams.time), [BoSSS.Foundation.CommonParamsBnd.time](#bosss.foundation.commonparamsbnd.time) and [BoSSS.Foundation.CommonParamsVol.time](#bosss.foundation.commonparamsvol.time).


### Property: BoSSS.Foundation.IEvaluator.MPITtransceive <a id="bosss.foundation.ievaluator.mpittransceive"></a>
**Summary:** Turn MPI sending/receiving of parameters and domain fields on/off.


### Property: BoSSS.Foundation.IEvaluator.Owner <a id="bosss.foundation.ievaluator.owner"></a>
**Summary:** The pointer to a owner object, which totally contradicts the original idea of object-orientation. Hehe.

## Class: BoSSS.Foundation.IEvaluatorNonLin <a id="bosss.foundation.ievaluatornonlin"></a>

**Summary:** Explicit operator evaluation


### Property: BoSSS.Foundation.IEvaluatorNonLin.DomainFields <a id="bosss.foundation.ievaluatornonlin.domainfields"></a>
**Summary:** Values for trial variables


## Method: BoSSS.Foundation.IEvaluatorNonLin.Evaluate``1(System.Double,System.Double,``0,System.Double[]) <a id="bosss.foundation.ievaluatornonlin.evaluate``1(system.double,system.double,``0,system.double[])"></a>
**Summary:** Evaluation call
**Parameter:** `alpha` - result scaling
**Parameter:** `beta` - scaling of accumulator
**Parameter:** `output` - accumulation buffer
**Parameter:** `outputBndEdge` - temporary hack, introduced for Compressible Local-Timestepping solver

## Class: BoSSS.Foundation.IEvaluatorLinear <a id="bosss.foundation.ievaluatorlinear"></a>

**Summary:** Evaluation of linear/linearized spatial operators, i.e. matrix assembly.


## Method: BoSSS.Foundation.IEvaluatorLinear.ComputeMatrix``2(``0,``1,System.Double) <a id="bosss.foundation.ievaluatorlinear.computematrix``2(``0,``1,system.double)"></a>
**Summary:** Computation of matrix $\mathcal{M}$ *and* affine offset $\tilde{b}$; the
DG operator [BoSSS.Foundation.IEvaluator.Owner](#bosss.foundation.ievaluator.owner) is discretized as
\[
\mathcal{M} \cdot \tilde{U} + \tilde{b}
\]
where $\tilde{U}$ are the DG coordinates of the trial function.
**Parameter:** `Matrix` -
On entry, some pre-allocated matrix; on exit, the operator matrix, scaled by 'alpha', will be accumulated.
- **ilPSP.LinSolvers.ISparseMatrix.RowPartitioning** correlates with [BoSSS.Foundation.IEvaluator.CodomainMapping](#bosss.foundation.ievaluator.codomainmapping).
- **ilPSP.LinSolvers.ISparseMatrix.ColPartition** correlates with [BoSSS.Foundation.IEvaluator.DomainMapping](#bosss.foundation.ievaluator.domainmapping)
**Parameter:** `AffineOffset` - On entry, some pre-allocated vector; on exit, the affine vector, scaled by 'alpha', will be accumulated.
Length correlates with [BoSSS.Foundation.IEvaluator.CodomainMapping](#bosss.foundation.ievaluator.codomainmapping).
**Parameter:** `alpha` - scaling factor


## Method: BoSSS.Foundation.IEvaluatorLinear.ComputeAffine``1(``0) <a id="bosss.foundation.ievaluatorlinear.computeaffine``1(``0)"></a>
**Summary:** only the affine part of [BoSSS.Foundation.IEvaluatorLinear.ComputeMatrix``2(``0,``1,System.Double)](#bosss.foundation.ievaluatorlinear.computematrix``2(``0,``1,system.double))

## Class: BoSSS.Foundation.XDG.ILevelSet <a id="bosss.foundation.xdg.ilevelset"></a>

**Summary:** This interface defines which methods any level set must
provide to be used by BoSSS. The level-set itself may be calculated
by BoSSS or come from some external object which implements this
interface.


## Method: BoSSS.Foundation.XDG.ILevelSet.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.xdg.ilevelset.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Evaluates the level set 
at nodes 'NS'
in all cells from 'j0' to
'j0'+'Len'-1.
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `result` - Output: 
On exit, the value of the level set.
The array is 2-dimensional:

1st index: cell index j - 'j0';
2nd index: node index k, corresponds with 1st index of the node set;
**Parameter:** `NS` - nodes at wihich to evaluate.
**Remark:**
This method is vectorized: Here, it means that the Points at which the level set should be evaluated,
are given for one cell in reference coordinates, but
the evaluation is performed for 'Len' cells at once.


## Method: BoSSS.Foundation.XDG.ILevelSet.EvaluateGradient(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.xdg.ilevelset.evaluategradient(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Evaluates the gradient of the level set 
at nodes  'NS'
in all cells from 'j0' to
'j0'+'Len'-1.
**Remark:**
The returned vectors don't need to be of unit length;


## Method: BoSSS.Foundation.XDG.ILevelSet.EvaluateHessian(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.xdg.ilevelset.evaluatehessian(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Evaluates all 2nd derivatives (by cell-local analytic derivation of the basis polynomials) of this field;
this method my move to the [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)-class in future;
**Parameter:** `j0` - 
**Parameter:** `Len` - 
**Parameter:** `NS` - 
**Parameter:** `result` -
1st index: cell index j
2nd index: node index m into nodeset 'NS'
3rd index: spatial direction of 1st derivation, k
4th index: spatial direction of 2nd derivation, l

So, the entry [j,m,k,l] = $\frac{\partial}{\partial x_k} \frac{\partial}{\partial x_l} \varphi (\vec{\xi}_m)$ 
where $\vec{xi}_m$  is the m-th vector in the nodeset 'NS',
in the j-th cell.
**Remark:**
Because of 2 derivatives taken, this field needs to be at least of DG degree 2 to get a non-zero result
from this method.


## Method: BoSSS.Foundation.XDG.ILevelSet.EvaluateTotalCurvature(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.xdg.ilevelset.evaluatetotalcurvature(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Evaluates the total curvature of this field, i.e.
$\mathrm{div} \left( \frac{ \varphi }{ \nabla_h \varphi } \right)$.
**Parameter:** `j0` - 
**Parameter:** `Len` - 
**Parameter:** `NodeSet` - 
**Parameter:** `result` -
1st index: cell index j
2nd index: node index m into nodeset 'NodeSet'
3rd index: spatial direction of 1st derivation, k
4th index: spatial direction of 2nd derivation, l

So, the entry [j,m,k,l] = $\frac{\partial}{\partial x_k} \frac{\partial}{\partial x_l} \varphi (\vec{\xi}_m)$ 
where $\vec{xi}_m$  is the m-th vector in the nodeset 'NodeSet',
in the j-th cell.
**Remark:**
Because of 2 derivatives taken, this field needs to be at least of DG degree 2 to get a non-zero result
from this method.


## Method: BoSSS.Foundation.XDG.ILevelSet.CopyFrom(BoSSS.Foundation.XDG.ILevelSet) <a id="bosss.foundation.xdg.ilevelset.copyfrom(bosss.foundation.xdg.ilevelset)"></a>
**Summary:** Sets this level-set to be equal to 'other'

## Class: BoSSS.Foundation.DelPartialParameterUpdate <a id="bosss.foundation.delpartialparameterupdate"></a>

**Summary:** Update of parameter fields (e.g. when computing finite difference Jacobian, see e.g. [BoSSS.Foundation.DifferentialOperator.GetFDJacobianBuilder(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)](#bosss.foundation.differentialoperator.getfdjacobianbuilder(system.collections.generic.ilist{bosss.foundation.dgfield},system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping))),
event used in [BoSSS.Foundation.IDifferentialOperator.ParameterUpdates](#bosss.foundation.idifferentialoperator.parameterupdates).

**Remark:**
Note:
1. Alternatively, equation components which implement [BoSSS.Foundation.IParameterHandling](#bosss.foundation.iparameterhandling) can be used.
2. For an event, such as [BoSSS.Foundation.IDifferentialOperator.ParameterUpdates](#bosss.foundation.idifferentialoperator.parameterupdates) multiple handlers can be added so it is not necessary to 
put the update of all parameter fields for the operator into one big piece of spaghetti code.
Hence, it can be split among different handlers.

## Class: BoSSS.Foundation.DelParameterFactory <a id="bosss.foundation.delparameterfactory"></a>

**Summary:** Factory for the allocation of storage for storing the parameters for this component
(alternatively, [BoSSS.Foundation.IParameterHandling.MyParameterAlloc(BoSSS.Foundation.DGField[])](#bosss.foundation.iparameterhandling.myparameteralloc(bosss.foundation.dgfield[])) can be used.)

## Class: BoSSS.Foundation.ISpatialOparatorExtensions <a id="bosss.foundation.ispatialoparatorextensions"></a>

**Summary:** Extension functions for [BoSSS.Foundation.IDifferentialOperator](#bosss.foundation.idifferentialoperator)


## Method: BoSSS.Foundation.ISpatialOparatorExtensions.InvokeParameterFactory(BoSSS.Foundation.IDifferentialOperator,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField}) <a id="bosss.foundation.ispatialoparatorextensions.invokeparameterfactory(bosss.foundation.idifferentialoperator,system.collections.generic.ienumerable{bosss.foundation.dgfield})"></a>
**Summary:** Involves all [BoSSS.Foundation.IDifferentialOperator.ParameterFactories](#bosss.foundation.idifferentialoperator.parameterfactories) events 
and all [BoSSS.Foundation.IParameterHandling.MyParameterAlloc(BoSSS.Foundation.DGField[])](#bosss.foundation.iparameterhandling.myparameteralloc(bosss.foundation.dgfield[])) methods in the operators equation components 
in order to allocate operator storage.


## Method: BoSSS.Foundation.ISpatialOparatorExtensions.InvokeParameterUpdate(BoSSS.Foundation.IDifferentialOperator,System.Double,BoSSS.Foundation.DGField[],BoSSS.Foundation.DGField[]) <a id="bosss.foundation.ispatialoparatorextensions.invokeparameterupdate(bosss.foundation.idifferentialoperator,system.double,bosss.foundation.dgfield[],bosss.foundation.dgfield[])"></a>
**Summary:** Involves all [BoSSS.Foundation.IDifferentialOperator.ParameterUpdates](#bosss.foundation.idifferentialoperator.parameterupdates) events 
and all [BoSSS.Foundation.IParameterHandling.MyParameterUpdate(BoSSS.Foundation.DGField[],BoSSS.Foundation.DGField[])](#bosss.foundation.iparameterhandling.myparameterupdate(bosss.foundation.dgfield[],bosss.foundation.dgfield[])) methods in the operators equation components 
in order to allocate operator storage.

## Class: BoSSS.Foundation.JacobianParamUpdate <a id="bosss.foundation.jacobianparamupdate"></a>

**Summary:** Utility to define parameter variables for Jacobian operators ([BoSSS.Foundation.DifferentialOperator.GetJacobiOperator(System.Int32)](#bosss.foundation.differentialoperator.getjacobioperator(system.int32)))


## Method: BoSSS.Foundation.JacobianParamUpdate.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.List{BoSSS.Foundation.IEquationComponent},System.Func{BoSSS.Foundation.IEquationComponent,BoSSS.Foundation.TermActivationFlags},System.Int32) <a id="bosss.foundation.jacobianparamupdate.#ctor(system.collections.generic.ienumerable{system.string},system.collections.generic.ienumerable{system.string},system.collections.generic.list{bosss.foundation.iequationcomponent},system.func{bosss.foundation.iequationcomponent,bosss.foundation.termactivationflags},system.int32)"></a>
**Summary:** Not intended for direct user interaction, but for use by [BoSSS.Foundation.DifferentialOperator.GetJacobiOperator(System.Int32)](#bosss.foundation.differentialoperator.getjacobioperator(system.int32))


## Method: BoSSS.Foundation.JacobianParamUpdate.FindJacobianParams(System.Int32,System.String[],System.Func{BoSSS.Foundation.IEquationComponent,BoSSS.Foundation.TermActivationFlags}) <a id="bosss.foundation.jacobianparamupdate.findjacobianparams(system.int32,system.string[],system.func{bosss.foundation.iequationcomponent,bosss.foundation.termactivationflags})"></a>
**Summary:** Implementation of constructor functionality.


### Property: BoSSS.Foundation.JacobianParamUpdate.JacobianParameterVars <a id="bosss.foundation.jacobianparamupdate.jacobianparametervars"></a>
**Summary:** List of parameter variables required for the Jacobian.


## Method: BoSSS.Foundation.JacobianParamUpdate.PerformUpdate(System.Double,System.Collections.Generic.IReadOnlyDictionary{System.String,BoSSS.Foundation.DGField},System.Collections.Generic.IReadOnlyDictionary{System.String,BoSSS.Foundation.DGField}) <a id="bosss.foundation.jacobianparamupdate.performupdate(system.double,system.collections.generic.ireadonlydictionary{system.string,bosss.foundation.dgfield},system.collections.generic.ireadonlydictionary{system.string,bosss.foundation.dgfield})"></a>
**Summary:** Parameter update function, 
compatible with [BoSSS.Foundation.DelPartialParameterUpdate](#bosss.foundation.delpartialparameterupdate).


## Method: BoSSS.Foundation.JacobianParamUpdate.AllocateParameters(System.Collections.Generic.IReadOnlyDictionary{System.String,BoSSS.Foundation.DGField}) <a id="bosss.foundation.jacobianparamupdate.allocateparameters(system.collections.generic.ireadonlydictionary{system.string,bosss.foundation.dgfield})"></a>
**Summary:** creates clones of the domain fields to store parameter fields;
compiles with [BoSSS.Foundation.DelParameterFactory](#bosss.foundation.delparameterfactory)

## Class: BoSSS.Foundation.Comm.Many2ManyMessenger`1 <a id="bosss.foundation.comm.many2manymessenger`1"></a>

**Summary:** Performs the exchange of general messages (i.e. an array of 's)
from each process to various other processes;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Finalize <a id="bosss.foundation.comm.many2manymessenger`1.finalize"></a>
**Summary:** calls [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Dispose](#bosss.foundation.comm.many2manymessenger`1.dispose)


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.#ctor(MPI.Wrappers.MPI_Comm) <a id="bosss.foundation.comm.many2manymessenger`1.#ctor(mpi.wrappers.mpi_comm)"></a>
**Summary:** ctor
**Parameter:** `comm` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.CheckItemTypeRecursive(System.Type) <a id="bosss.foundation.comm.many2manymessenger`1.checkitemtyperecursive(system.type)"></a>
**Summary:** throws an exception if any member of 't'
is not suited for transport over the network (e.g. pointers);


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_ItemSize <a id="bosss.foundation.comm.many2manymessenger`1.m_itemsize"></a>
**Summary:** size of one data item in bytes


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_ItemType <a id="bosss.foundation.comm.many2manymessenger`1.m_itemtype"></a>
**Summary:** type of item


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32)"></a>
**Summary:** setup procedure;
Informs the messenger that 'NoOfItems' items should be transmitted
1st function (multiple calls) in the setup process; If all communication paths
are set, [BoSSS.Foundation.Comm.Many2ManyMessenger`1.CommitCommPaths](#bosss.foundation.comm.many2manymessenger`1.commitcommpaths) is the next method to call;
**Parameter:** `TargetProcRank` - 
**Parameter:** `NoOfItems` - 


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_MyCommPaths <a id="bosss.foundation.comm.many2manymessenger`1.m_mycommpaths"></a>
**Summary:** A value x at entry m indicates that processor m will receive x items
from this processor;


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_AllCommPaths <a id="bosss.foundation.comm.many2manymessenger`1.m_allcommpaths"></a>
**Summary:** A value x at entry [i,j] indicates that processor j (target process) will receive
x items from processor i (source process);
- 1st index: source process
- 2nd index: target process


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.CommitCommPaths <a id="bosss.foundation.comm.many2manymessenger`1.commitcommpaths"></a>
**Summary:** setup procedure;
- 2nd function (exactly one call in the whole lifecycle of this object is permitted and 
required) in the setup process;
- In normal use, called after [BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32));


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_CommPathsCommited <a id="bosss.foundation.comm.many2manymessenger`1.m_commpathscommited"></a>
**Summary:** true indicates that the setup is finished


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_SendBuffers <a id="bosss.foundation.comm.many2manymessenger`1.m_sendbuffers"></a>


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.SendBuffers(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.sendbuffers(system.int32)"></a>
**Summary:** returns the send buffer to the 'TargetProcessor''th processor;
if no communication path has been set ([BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32))) for the specified processor,
the buffer is null;
The buffers are not available before [BoSSS.Foundation.Comm.Many2ManyMessenger`1.CommitCommPaths](#bosss.foundation.comm.many2manymessenger`1.commitcommpaths) has been called;
**Parameter:** `TargetProcessor` - 
**Returns:**



### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_ReceiveBuffers <a id="bosss.foundation.comm.many2manymessenger`1.m_receivebuffers"></a>


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.ReceiveBuffers(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.receivebuffers(system.int32)"></a>
**Summary:** returns the receive buffer for data from the 'SourceProcessor''th MPI-process;
if no communication path has been set (ANOTHER process has to do that by calling [BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32))) 
for the specified processor to this processor,
the buffer is null;
The buffers are not available before [BoSSS.Foundation.Comm.Many2ManyMessenger`1.CommitCommPaths](#bosss.foundation.comm.many2manymessenger`1.commitcommpaths) has been called;


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_Requests <a id="bosss.foundation.comm.many2manymessenger`1.m_requests"></a>
**Summary:** MPI - request - handles for the unblocking receive and send operations;
the first half of the array contains the requests for receive operations,
the second half requests for send operations.


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_ArrayOfStatuses <a id="bosss.foundation.comm.many2manymessenger`1.m_arrayofstatuses"></a>
**Summary:** MPI status array


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.StartTransmission(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.starttransmission(system.int32)"></a>
**Summary:** transmission procedure, 1st phase;
makes everything ready to transmit data, which is done
by calling to [BoSSS.Foundation.Comm.Many2ManyMessenger`1.TransmittData(System.Int32)](#bosss.foundation.comm.many2manymessenger`1.transmittdata(system.int32))
**Parameter:** `NoOfItemsMultiplyer` -
The number of items for each communication path which were specifyed by 
calling [BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32)) is multiplyed with this number to get
the actual number of items to sent/receive.
this number must be the same in all processes, otherwise the behavior is undefined
- the implementation doesn't checks for that;


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_NoOfItemsMultiplyer <a id="bosss.foundation.comm.many2manymessenger`1.m_noofitemsmultiplyer"></a>
**Summary:** The number of items for each communication path which were specified by 
calling [BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32)) is multiplied with this number to get
the actual number of items to sent/receive.
this number must be the same in all processes, otherwise the behavior is undefined
- the implementation doesn't checks for that;


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.m_TransmittDataReady <a id="bosss.foundation.comm.many2manymessenger`1.m_transmittdataready"></a>
**Summary:** true indicates that [BoSSS.Foundation.Comm.Many2ManyMessenger`1.StartTransmission(System.Int32)](#bosss.foundation.comm.many2manymessenger`1.starttransmission(system.int32)) was called and
calls to [BoSSS.Foundation.Comm.Many2ManyMessenger`1.TransmittData(System.Int32)](#bosss.foundation.comm.many2manymessenger`1.transmittdata(system.int32)) are legal;

## Class: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer <a id="bosss.foundation.comm.many2manymessenger`1.buffer"></a>


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.#ctor(BoSSS.Foundation.Comm.Many2ManyMessenger{`0},System.Boolean,System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.#ctor(bosss.foundation.comm.many2manymessenger{`0},system.boolean,system.int32)"></a>
**Summary:** constructor;
Cannot be called before communication paths of 'owner' are committed
([BoSSS.Foundation.Comm.Many2ManyMessenger`1.CommitCommPaths](#bosss.foundation.comm.many2manymessenger`1.commitcommpaths));
**Parameter:** `owner` - 
**Parameter:** `ReceiveOrTransmit` - true: a receive buffer
false: a transmit (or send) buffer
**Parameter:** `ProcRank` - 


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_Owner <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_owner"></a>
**Summary:** owner


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_Buffer <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_buffer"></a>
**Summary:** unmanaged memory


### Property: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.BufferMemory <a id="bosss.foundation.comm.many2manymessenger`1.buffer.buffermemory"></a>


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_NumberOfAllocatedBytes <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_numberofallocatedbytes"></a>
**Summary:** size of [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_Buffer](#bosss.foundation.comm.many2manymessenger`1.buffer.m_buffer) in bytes;
maybe more memory than actually needed;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CheckAllocation <a id="bosss.foundation.comm.many2manymessenger`1.buffer.checkallocation"></a>
**Summary:** allocates/reallocates memory if needed;
sets [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_MySize](#bosss.foundation.comm.many2manymessenger`1.buffer.m_mysize) to a correct value value;


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_ProcRank <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_procrank"></a>


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_ReceiveOrTransmit <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_receiveortransmit"></a>
**Summary:** true: receive buffer;
false: send buffer


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_UnLocked <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_unlocked"></a>
**Summary:** [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.UnLocked](#bosss.foundation.comm.many2manymessenger`1.buffer.unlocked)


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.SetUnLocked(System.Boolean) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.setunlocked(system.boolean)"></a>
**Summary:** sets [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_UnLocked](#bosss.foundation.comm.many2manymessenger`1.buffer.m_unlocked);
**Parameter:** `newState` - 


### Property: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.UnLocked <a id="bosss.foundation.comm.many2manymessenger`1.buffer.unlocked"></a>
**Summary:** if true, the user is allowed to access data;
if false, the buffer memory is looked for MPI communication;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CheckReady <a id="bosss.foundation.comm.many2manymessenger`1.buffer.checkready"></a>
**Summary:** checks if the user is allowed to access the buffer and throws an exception if he is not
**Returns:**



### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_MySize <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_mysize"></a>
**Summary:** size of buffer (in number of items)


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CheckIndex(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.checkindex(system.int32)"></a>
**Parameter:** `i` - 
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.IndexOf(`0) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.indexof(`0)"></a>
**Summary:** not supported
**Parameter:** `item` - 
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Insert(System.Int32,`0) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.insert(system.int32,`0)"></a>
**Summary:** not supported
**Parameter:** `index` - 
**Parameter:** `item` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.RemoveAt(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.removeat(system.int32)"></a>
**Summary:** not supported
**Parameter:** `index` - 


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_itemMemory <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_itemmemory"></a>
**Summary:** helper memory


### Property: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Item(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.item(system.int32)"></a>
**Summary:** set/get one item;
causes some overhead - use [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyTo(`0[],System.Int32)](#bosss.foundation.comm.many2manymessenger`1.buffer.copyto(`0[],system.int32)) and [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyFrom(`0[],System.Int32)](#bosss.foundation.comm.many2manymessenger`1.buffer.copyfrom(`0[],system.int32)) to avoid that;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Add(`0) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.add(`0)"></a>
**Summary:** not supported
**Parameter:** `item` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Clear <a id="bosss.foundation.comm.many2manymessenger`1.buffer.clear"></a>
**Summary:** sets all entries 0;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Contains(`0) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.contains(`0)"></a>
**Summary:** not supported
**Parameter:** `item` - 
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyTo(`0[],System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copyto(`0[],system.int32)"></a>
**Summary:** copys the content of the unmanged buffer into a managed array
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - offset into 'array'


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyTo(`0[],System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copyto(`0[],system.int32,system.int32,system.int32)"></a>
**Summary:** copys 'len' items form this buffer, starting at index 'srcOffset'
into 'array', starting at index 'arrayIndex'
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - offset into 'array'
**Parameter:** `len` - number of items to copy
**Parameter:** `srcOffset` - offset into this array


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyFrom(`0[],System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copyfrom(`0[],system.int32)"></a>
**Summary:** copys from an (managed) array into the internal unmanaged buffer
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyFromList(System.Collections.Generic.IList{`0},System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copyfromlist(system.collections.generic.ilist{`0},system.int32)"></a>
**Summary:** copys from an (managed) List into the internal unmanaged buffer
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyFrom(`0[],System.Int32[],System.Int32,System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copyfrom(`0[],system.int32[],system.int32,system.int32)"></a>
**Summary:** copys from an (managed) array into the internal unmanaged buffer;
For each entry i in 'arrayIndices', this method
copies the entries i*'l' to i*'l'+'l'-1 of 'array'
into the send buffer in subsequent order, starting at index 'targetoffset'.
**Parameter:** `array` - 
**Parameter:** `arrayIndices` - indices of the entries in 'array' that should be copied
**Parameter:** `l` - multiplyer for the indices in 'arrayIndices'
**Parameter:** `targetoffset` - 


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.CopyToList(System.Collections.Generic.IList{`0},System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.copytolist(system.collections.generic.ilist{`0},system.int32)"></a>
**Summary:** opys the content of the unmanaged buffer into a managed list
**Parameter:** `array` - 
**Parameter:** `arrayIndex` - 


### Property: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Count <a id="bosss.foundation.comm.many2manymessenger`1.buffer.count"></a>
**Summary:** Number of items in buffer


### Property: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.IsReadOnly <a id="bosss.foundation.comm.many2manymessenger`1.buffer.isreadonly"></a>
**Summary:** always false


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Remove(`0) <a id="bosss.foundation.comm.many2manymessenger`1.buffer.remove(`0)"></a>
**Summary:** not supported;
**Parameter:** `item` - 
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.GetEnumerator <a id="bosss.foundation.comm.many2manymessenger`1.buffer.getenumerator"></a>
**Summary:** not implemented
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.comm.many2manymessenger`1.buffer.system#collections#ienumerable#getenumerator"></a>
**Summary:** not implemented
**Returns:**



## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Dispose <a id="bosss.foundation.comm.many2manymessenger`1.buffer.dispose"></a>
**Summary:** frees unmanaged memory


### Field: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.m_disposed <a id="bosss.foundation.comm.many2manymessenger`1.buffer.m_disposed"></a>
**Summary:** true after [BoSSS.Foundation.Comm.Many2ManyMessenger`1.Buffer.Dispose](#bosss.foundation.comm.many2manymessenger`1.buffer.dispose) has been called


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.TransmittData(System.Int32) <a id="bosss.foundation.comm.many2manymessenger`1.transmittdata(system.int32)"></a>
**Summary:** transmission procedure, 2nd phase, multiple calls;
calls must exactly match the comm paths which were set up by
calling [BoSSS.Foundation.Comm.Many2ManyMessenger`1.SetCommPath(System.Int32,System.Int32)](#bosss.foundation.comm.many2manymessenger`1.setcommpath(system.int32,system.int32));
After all data items have ben set, a call to [BoSSS.Foundation.Comm.Many2ManyMessenger`1.FinishBlocking](#bosss.foundation.comm.many2manymessenger`1.finishblocking)
completes the data transmission;
This method ONLY initiates the transmission procedure, the data to transmit must be set
by manipulating the send buffers;
**Parameter:** `TargetProcRank` - index of target process


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.FinishBlocking <a id="bosss.foundation.comm.many2manymessenger`1.finishblocking"></a>
**Summary:** transmission procedure, 3rd (and last) phase;
receives data and blocks until the transmission is finished;
after this method returns, another transmission can be started with
[BoSSS.Foundation.Comm.Many2ManyMessenger`1.StartTransmission(System.Int32)](#bosss.foundation.comm.many2manymessenger`1.starttransmission(system.int32));
after this method retunes, all buffers are unlocked;


## Method: BoSSS.Foundation.Comm.Many2ManyMessenger`1.Dispose <a id="bosss.foundation.comm.many2manymessenger`1.dispose"></a>
**Summary:** frees the internal non-managed buffers

## Class: BoSSS.Foundation.Comm.Master <a id="bosss.foundation.comm.master"></a>

**Summary:** Communication "DatabaseDriver"


### Property: BoSSS.Foundation.Comm.Master.Comm <a id="bosss.foundation.comm.master.comm"></a>
**Summary:** the MPI communicator on which the BoSSS context, and the grid, ... 'live' on. Currently,
this is always [MPI.Wrappers.IMPI_CommConstants.WORLD](MPI.Wrappers.md#mpi.wrappers.impi_commconstants.world).


## Method: BoSSS.Foundation.Comm.Master.#ctor <a id="bosss.foundation.comm.master.#ctor"></a>


## Method: BoSSS.Foundation.Comm.Master.SMPEvaluation <a id="bosss.foundation.comm.master.smpevaluation"></a>
**Summary:** detects how the MPI nodes are distributed over compute nodes (SMP nodes)


### Property: BoSSS.Foundation.Comm.Master.Hostname <a id="bosss.foundation.comm.master.hostname"></a>
**Summary:** name of the compute node of the actual MPI process;


### Field: BoSSS.Foundation.Comm.Master.m_MyRank <a id="bosss.foundation.comm.master.m_myrank"></a>
**Summary:** rank of current process


### Field: BoSSS.Foundation.Comm.Master.m_Size <a id="bosss.foundation.comm.master.m_size"></a>
**Summary:** number of processors


### Property: BoSSS.Foundation.Comm.Master.MyRank <a id="bosss.foundation.comm.master.myrank"></a>
**Summary:** rank of current MPI process


### Property: BoSSS.Foundation.Comm.Master.Size <a id="bosss.foundation.comm.master.size"></a>
**Summary:** number of MPI processes


### Field: BoSSS.Foundation.Comm.Master.m_SMPSize <a id="bosss.foundation.comm.master.m_smpsize"></a>
**Summary:** [BoSSS.Foundation.Comm.Master.SMPSize](#bosss.foundation.comm.master.smpsize)


### Field: BoSSS.Foundation.Comm.Master.m_SMPRanks <a id="bosss.foundation.comm.master.m_smpranks"></a>
**Summary:** [BoSSS.Foundation.Comm.Master.SMPRank(System.Int32)](#bosss.foundation.comm.master.smprank(system.int32))


### Property: BoSSS.Foundation.Comm.Master.SMPSize <a id="bosss.foundation.comm.master.smpsize"></a>
**Summary:** number of compute nodes (Symmetric MultiProcessing - nodes) over which 
the MPI processes are distributed


## Method: BoSSS.Foundation.Comm.Master.SMPRank(System.Int32) <a id="bosss.foundation.comm.master.smprank(system.int32)"></a>
**Summary:** for each MPI rank, a number that identifies the compute node (Symmetric MultiProcessing - node)
on which the MPI process is allocated
**Parameter:** `rank` - an MPI rank, within the current communicator


### Field: BoSSS.Foundation.Comm.Master.m_MPIProcessesPerSMP <a id="bosss.foundation.comm.master.m_mpiprocessespersmp"></a>
**Summary:** see [BoSSS.Foundation.Comm.Master.MPIProcessesPerSMP(System.Int32)](#bosss.foundation.comm.master.mpiprocessespersmp(system.int32));


## Method: BoSSS.Foundation.Comm.Master.MPIProcessesPerSMP(System.Int32) <a id="bosss.foundation.comm.master.mpiprocessespersmp(system.int32)"></a>
**Summary:** returns the number of MPI processes which are assigned to the compute node (Symmetric MultiProcessing - node)
'_SMPrank'.
**Parameter:** `_SMPrank` - 
**Returns:**


## Class: BoSSS.Foundation.Comm.Permutation <a id="bosss.foundation.comm.permutation"></a>

**Summary:** An MPI-parallel data structure to store permutations.


## Method: BoSSS.Foundation.Comm.Permutation.#ctor(System.Int32,MPI.Wrappers.MPI_Comm) <a id="bosss.foundation.comm.permutation.#ctor(system.int32,mpi.wrappers.mpi_comm)"></a>
**Summary:** creates an empty Permutation (filled with invalid, negative entries)
**Parameter:** `comm` - 
**Parameter:** `localLength` - number of items that are stored in this process


## Method: BoSSS.Foundation.Comm.Permutation.#ctor(System.Int64[],MPI.Wrappers.MPI_Comm) <a id="bosss.foundation.comm.permutation.#ctor(system.int64[],mpi.wrappers.mpi_comm)"></a>
**Summary:** creates a permutation with user-defined entries;
The "correctness" (each entry occurs exactly once over all processes,
and the lowest entry is 0 an no number is skipped) is NOT tested;
**Parameter:** `comm` - 
**Parameter:** `values` - permutation values that are stored on this process


### Field: BoSSS.Foundation.Comm.Permutation.m_Partition <a id="bosss.foundation.comm.permutation.m_partition"></a>
**Summary:** [BoSSS.Foundation.Comm.Permutation.Partitioning](#bosss.foundation.comm.permutation.partitioning)


### Property: BoSSS.Foundation.Comm.Permutation.Partitioning <a id="bosss.foundation.comm.permutation.partitioning"></a>
**Summary:** partition over MPI processes for this permutation


## Method: BoSSS.Foundation.Comm.Permutation.#ctor(BoSSS.Foundation.Comm.Permutation) <a id="bosss.foundation.comm.permutation.#ctor(bosss.foundation.comm.permutation)"></a>
**Summary:** constructor used by [BoSSS.Foundation.Comm.Permutation.Invert](#bosss.foundation.comm.permutation.invert), creates a NON-shallow copy;
**Parameter:** `o` - 


### Field: BoSSS.Foundation.Comm.Permutation.m_Comm <a id="bosss.foundation.comm.permutation.m_comm"></a>
**Summary:** MPI communicator on which this permutation 'lives' on


### Property: BoSSS.Foundation.Comm.Permutation.TotalLength <a id="bosss.foundation.comm.permutation.totallength"></a>
**Summary:** total length of the permutation over all processes


### Property: BoSSS.Foundation.Comm.Permutation.i0Offset <a id="bosss.foundation.comm.permutation.i0offset"></a>
**Summary:** index offset for the first entry of the permutation stored by
this process


### Property: BoSSS.Foundation.Comm.Permutation.LocalLength <a id="bosss.foundation.comm.permutation.locallength"></a>
**Summary:** returns the number of permutation entries which are stored by
this processor;


### Field: BoSSS.Foundation.Comm.Permutation.m_Values <a id="bosss.foundation.comm.permutation.m_values"></a>
**Summary:** [BoSSS.Foundation.Comm.Permutation.Values](#bosss.foundation.comm.permutation.values)


### Property: BoSSS.Foundation.Comm.Permutation.Values <a id="bosss.foundation.comm.permutation.values"></a>
**Summary:** permutation values in the actual process; user must ensure that
this values represent a valid permutation among all processes,
otherwise the behavior of the operations is undefined;

## Class: BoSSS.Foundation.Comm.Permutation.PermutationEntry <a id="bosss.foundation.comm.permutation.permutationentry"></a>

**Summary:** Helper structure to transmit permutation entries over the 
network


### Field: BoSSS.Foundation.Comm.Permutation.PermutationEntry.Index <a id="bosss.foundation.comm.permutation.permutationentry.index"></a>
**Summary:** Argument


### Field: BoSSS.Foundation.Comm.Permutation.PermutationEntry.PermVal <a id="bosss.foundation.comm.permutation.permutationentry.permval"></a>
**Summary:** value of the permutation for argument [BoSSS.Foundation.Comm.Permutation.PermutationEntry.Index](#bosss.foundation.comm.permutation.permutationentry.index)


## Method: BoSSS.Foundation.Comm.Permutation.Invert <a id="bosss.foundation.comm.permutation.invert"></a>
**Summary:** performs a parallel inversion of this permutation
**Returns:**



## Method: BoSSS.Foundation.Comm.Permutation.op_Multiply(BoSSS.Foundation.Comm.Permutation,BoSSS.Foundation.Comm.Permutation) <a id="bosss.foundation.comm.permutation.op_multiply(bosss.foundation.comm.permutation,bosss.foundation.comm.permutation)"></a>
**Summary:** Permutation composition.
**Parameter:** `left` - left operand
**Parameter:** `right` - right operand
**Returns:**
The product of 'left'- and 'right'-permutation;
the partitioning ([BoSSS.Foundation.Comm.Permutation.Partitioning](#bosss.foundation.comm.permutation.partitioning) is equal to the 'right' operand.


## Method: BoSSS.Foundation.Comm.Permutation.EvaluatePermutation``2(``0,``1) <a id="bosss.foundation.comm.permutation.evaluatepermutation``2(``0,``1)"></a>
**Summary:** parallel evaluator; For arguments which are not stored on this process,
other processes are asked.
**Parameter:** `Keys` - input; indices at which the permutation should be evaluated;
**Parameter:** `Result` - output; the i-th entry is the value of the permutation for index 
'Keys'[i];


## Method: BoSSS.Foundation.Comm.Permutation.ApplyToVector``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0}) <a id="bosss.foundation.comm.permutation.applytovector``1(system.collections.generic.ilist{``0},system.collections.generic.ilist{``0})"></a>
**Summary:** Resorts a vector according to this permutation, i.e. the
j-th item of the input vector is copied to the
[BoSSS.Foundation.Comm.Permutation.Values](#bosss.foundation.comm.permutation.values)[j]-th entry of the output vector.
**Parameter:** `input` - Input vector, length must be equal to the length of this permutation, unchanged on exit.
**Parameter:** `output` - On exit, 'output'[[BoSSS.Foundation.Comm.Permutation.Values](#bosss.foundation.comm.permutation.values)[j]] = 'input'[j]


## Method: BoSSS.Foundation.Comm.Permutation.ApplyToVector``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},ilPSP.IPartitioning) <a id="bosss.foundation.comm.permutation.applytovector``1(system.collections.generic.ilist{``0},system.collections.generic.ilist{``0},ilpsp.ipartitioning)"></a>
**Summary:** Resorts a vector according to this permutation, i.e. the
j-th item of the input vector is copied to the
[BoSSS.Foundation.Comm.Permutation.Values](#bosss.foundation.comm.permutation.values)[j]-th entry of the output vector.
**Parameter:** `input` - Input vector, length must be equal to the length of this permutation, unchanged on exit.
**Parameter:** `output` - On exit, 'output'[[BoSSS.Foundation.Comm.Permutation.Values](#bosss.foundation.comm.permutation.values)[j]] = 'input'[j]
**Parameter:** `outputPartitioning` - partitioning of 'output' over MPI processes


## Method: BoSSS.Foundation.Comm.Permutation.Equals(System.Object) <a id="bosss.foundation.comm.permutation.equals(system.object)"></a>
**Summary:** equality of permutations;


## Method: BoSSS.Foundation.Comm.Permutation.GetHashCode <a id="bosss.foundation.comm.permutation.gethashcode"></a>
**Summary:** some hash code


## Method: BoSSS.Foundation.Comm.Permutation.Clone <a id="bosss.foundation.comm.permutation.clone"></a>
**Summary:** Cloning.
**Returns:**


## Class: BoSSS.Foundation.Comm.Transceiver <a id="bosss.foundation.comm.transceiver"></a>

**Summary:** performs transmission of DG field coordinates (in the border cells of this process) to 
other processes (Transmitter)
and receives field coordinates from other processes and putts the received values
into the corresponding memory for external cells.


## Method: BoSSS.Foundation.Comm.Transceiver.Finalize <a id="bosss.foundation.comm.transceiver.finalize"></a>
**Summary:** checks if the call to [BoSSS.Foundation.Comm.Transceiver.TransceiveStartImReturn](#bosss.foundation.comm.transceiver.transceivestartimreturn)
is matched by a call to [BoSSS.Foundation.Comm.Transceiver.TransceiveFinish](#bosss.foundation.comm.transceiver.transceivefinish)


## Method: BoSSS.Foundation.Comm.Transceiver.#ctor(BoSSS.Foundation.DGField[]) <a id="bosss.foundation.comm.transceiver.#ctor(bosss.foundation.dgfield[])"></a>
**Summary:** constructor
**Parameter:** `TRXfields` - fields which should be exchanged


## Method: BoSSS.Foundation.Comm.Transceiver.#ctor(System.Collections.Generic.ICollection{BoSSS.Foundation.DGField}) <a id="bosss.foundation.comm.transceiver.#ctor(system.collections.generic.icollection{bosss.foundation.dgfield})"></a>
**Summary:** constructor
**Parameter:** `TRXfields` - fields which should be exchanged


### Field: BoSSS.Foundation.Comm.Transceiver.m_TRXFields <a id="bosss.foundation.comm.transceiver.m_trxfields"></a>


## Method: BoSSS.Foundation.Comm.Transceiver.TransceiveStartImReturn <a id="bosss.foundation.comm.transceiver.transceivestartimreturn"></a>
**Summary:** initiates the send/receive - processes and returns immediately;
Every call of this method must be matched by a later call to [BoSSS.Foundation.Comm.Transceiver.TransceiveFinish](#bosss.foundation.comm.transceiver.transceivefinish);


## Method: BoSSS.Foundation.Comm.Transceiver.TransceiveFinish <a id="bosss.foundation.comm.transceiver.transceivefinish"></a>
**Summary:** blocks until the send/receive - processes started by [BoSSS.Foundation.Comm.Transceiver.TransceiveStartImReturn](#bosss.foundation.comm.transceiver.transceivestartimreturn)
are complete and returns;

## Class: BoSSS.Foundation.Comm.VectorTransceiver`2 <a id="bosss.foundation.comm.vectortransceiver`2"></a>

**Summary:** transceiver for an arbitrary vector


## Method: BoSSS.Foundation.Comm.VectorTransceiver`2.CheckItemTypeRecursive(System.Type) <a id="bosss.foundation.comm.vectortransceiver`2.checkitemtyperecursive(system.type)"></a>
**Summary:** throws an exception if any member of 't'
is not suited for transport over the network (e.g. pointers);


## Method: BoSSS.Foundation.Comm.VectorTransceiver`2.#ctor(BoSSS.Foundation.Grid.IGridData,`0,System.Int32) <a id="bosss.foundation.comm.vectortransceiver`2.#ctor(bosss.foundation.grid.igriddata,`0,system.int32)"></a>
**Summary:** ctor.
**Parameter:** `master` - 
**Parameter:** `vector` - a vector of length J*'ItemsPerCell', where J is the number of local cells (including ghost)
**Parameter:** `ItemsPerCell` - the number of items that should be transmitted/received per cell


## Method: BoSSS.Foundation.Comm.VectorTransceiver`2.TransceiveStartImReturn <a id="bosss.foundation.comm.vectortransceiver`2.transceivestartimreturn"></a>
**Summary:** initiates the send/receive - processes and returns immediately;
Every call of this method must be matched by a later call to [BoSSS.Foundation.Comm.VectorTransceiver`2.TransceiveFinish](#bosss.foundation.comm.vectortransceiver`2.transceivefinish);


## Method: BoSSS.Foundation.Comm.VectorTransceiver`2.TransceiveFinish <a id="bosss.foundation.comm.vectortransceiver`2.transceivefinish"></a>
**Summary:** blocks until the send/receive - processes started by [BoSSS.Foundation.Comm.VectorTransceiver`2.TransceiveStartImReturn](#bosss.foundation.comm.vectortransceiver`2.transceivestartimreturn)
are complete and returns;

## Class: BoSSS.Foundation.Comm.VectorTransceiver_Ext <a id="bosss.foundation.comm.vectortransceiver_ext"></a>

**Summary:** extension methods for MPI communication.


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange(ilPSP.MultidimensionalArray,BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange(ilpsp.multidimensionalarray,bosss.foundation.grid.igriddata)"></a>
**Summary:** exchange of an **ilPSP.MultidimensionalArray**
**Parameter:** `master` - 
**Parameter:** `vector` - The array must be continuous and have zero offset;
first dimension must match local number of cells (including external).


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange(System.Double[],BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange(system.double[],bosss.foundation.grid.igriddata)"></a>
**Summary:** most elegant way of MPI vector exchange....


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange(System.Int32[],BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange(system.int32[],bosss.foundation.grid.igriddata)"></a>
**Summary:** most elegant way of MPI vector exchange....


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange(System.Int64[],BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange(system.int64[],bosss.foundation.grid.igriddata)"></a>
**Summary:** most elegant way of MPI vector exchange....


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange``2(``0,BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange``2(``0,bosss.foundation.grid.igriddata)"></a>
**Summary:** most elegant way of MPI vector exchange....
**Parameter:** `vector` - 
**Parameter:** `master` - 


## Method: BoSSS.Foundation.Comm.VectorTransceiver_Ext.MPIExchange(System.Collections.BitArray,BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.comm.vectortransceiver_ext.mpiexchange(system.collections.bitarray,bosss.foundation.grid.igriddata)"></a>
**Summary:** MPI update of a bit-array
**Parameter:** `b` - 
**Parameter:** `GridData` - 

## Class: BoSSS.Foundation.NodeCoordinateSystem <a id="bosss.foundation.nodecoordinatesystem"></a>

**Summary:** Type of local coordinates.


### Field: BoSSS.Foundation.NodeCoordinateSystem.EdgeCoord <a id="bosss.foundation.nodecoordinatesystem.edgecoord"></a>
**Summary:** Local edge coordinates.


### Field: BoSSS.Foundation.NodeCoordinateSystem.CellCoord <a id="bosss.foundation.nodecoordinatesystem.cellcoord"></a>
**Summary:** Local cell coordinates.

## Class: BoSSS.Foundation.NodeSet <a id="bosss.foundation.nodeset"></a>

**Summary:** Extends the functionality of the **ilPSP.MultidimensionalArray**-class to support caching.
A node set are coordinates in the reference system of a cell; it is always a 2D-array, i.e. a matrix.
- 1st index/rows: point
- 2nd index/columns: spatial direction, i.e. x, y, z components of the respective point
A node set is always bound to a specific reference cell [BoSSS.Foundation.NodeSet.RefElement](#bosss.foundation.nodeset.refelement) 
([BoSSS.Foundation.Grid.RefElements.Line.Instance](#bosss.foundation.grid.refelements.line.instance), [BoSSS.Foundation.Grid.RefElements.Square.Instance](#bosss.foundation.grid.refelements.square.instance), [BoSSS.Foundation.Grid.RefElements.Triangle.Instance](#bosss.foundation.grid.refelements.triangle.instance), [BoSSS.Foundation.Grid.RefElements.Cube.Instance](#bosss.foundation.grid.refelements.cube.instance), [BoSSS.Foundation.Grid.RefElements.Tetra.Instance](#bosss.foundation.grid.refelements.tetra.instance)).


## Method: BoSSS.Foundation.NodeSet.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement,ilPSP.MultidimensionalArray,System.Boolean) <a id="bosss.foundation.nodeset.#ctor(bosss.foundation.grid.refelements.refelement,ilpsp.multidimensionalarray,system.boolean)"></a>
**Summary:** Constructor: initializes this node set as a (non-shallow) clone of the array 'nds'.


## Method: BoSSS.Foundation.NodeSet.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement,System.Double[0:,0:],System.Boolean) <a id="bosss.foundation.nodeset.#ctor(bosss.foundation.grid.refelements.refelement,system.double[0:,0:],system.boolean)"></a>
**Summary:** Constructor: initializes this node set as a (non-shallow) clone of the array 'nds'.


## Method: BoSSS.Foundation.NodeSet.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement,System.Double[],System.Boolean) <a id="bosss.foundation.nodeset.#ctor(bosss.foundation.grid.refelements.refelement,system.double[],system.boolean)"></a>
**Summary:** Constructor: initializes this node set
containing only one point 'point'.


## Method: BoSSS.Foundation.NodeSet.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement,ilPSP.Vector,System.Boolean) <a id="bosss.foundation.nodeset.#ctor(bosss.foundation.grid.refelements.refelement,ilpsp.vector,system.boolean)"></a>
**Summary:** Constructor: initializes this node set
containing only one point 'point'.


## Method: BoSSS.Foundation.NodeSet.#ctor(BoSSS.Foundation.Grid.RefElements.RefElement,System.Int32,System.Int32,System.Boolean) <a id="bosss.foundation.nodeset.#ctor(bosss.foundation.grid.refelements.refelement,system.int32,system.int32,system.boolean)"></a>
**Summary:** Creates a node set with all nodes set to 0 -- these values can still be changed.
Use this constructor with care!
Note that this node set is in an invalid state until **ilPSP.MultidimensionalArray.LockForever** is called.


### Property: BoSSS.Foundation.NodeSet.Reference <a id="bosss.foundation.nodeset.reference"></a>
**Summary:** unique reference number for the node set;
0 indicates a temporary node set


## Method: BoSSS.Foundation.NodeSet.CloneAs <a id="bosss.foundation.nodeset.cloneas"></a>
**Summary:** Clones this node set.


### Property: BoSSS.Foundation.NodeSet.RefElement <a id="bosss.foundation.nodeset.refelement"></a>
**Summary:** The reference element for which this node set is valid; since cached values,
like basis polynomials at nodes depend on the reference element,
the node set needs to be associated with the reference element.


## Method: BoSSS.Foundation.NodeSet.GetVolumeRefElementIndex(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.nodeset.getvolumerefelementindex(bosss.foundation.grid.igriddata)"></a>
**Summary:** The index of [BoSSS.Foundation.NodeSet.RefElement](#bosss.foundation.nodeset.refelement) within the 
reference elements for cells in grid 'gridData'


## Method: BoSSS.Foundation.NodeSet.GetEdgeRefElementIndex(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.nodeset.getedgerefelementindex(bosss.foundation.grid.igriddata)"></a>
**Summary:** The index of [BoSSS.Foundation.NodeSet.RefElement](#bosss.foundation.nodeset.refelement) within the 
reference elements for edges in grid 'gridData'


## Method: BoSSS.Foundation.NodeSet.GetNodeCoordinateSystem(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.nodeset.getnodecoordinatesystem(bosss.foundation.grid.igriddata)"></a>
**Summary:** Determines, for a given grid 'g', whether 
this node set describes local cell-coordinates or edge-coordinates.


### Property: BoSSS.Foundation.NodeSet.NoOfNodes <a id="bosss.foundation.nodeset.noofnodes"></a>
**Summary:** Number of nodes; equal to the 0-th dimension of this array.


### Property: BoSSS.Foundation.NodeSet.SpatialDimension <a id="bosss.foundation.nodeset.spatialdimension"></a>
**Summary:** Vector length of the nodes in this node set; equal to the 1-st dimension of this array.


## Method: BoSSS.Foundation.NodeSet.GetVolumeNodeSet(BoSSS.Foundation.Grid.IGridData,System.Int32,System.Boolean) <a id="bosss.foundation.nodeset.getvolumenodeset(bosss.foundation.grid.igriddata,system.int32,system.boolean)"></a>
**Summary:** If this is a node set defined in the edge coordinate system, this method provides 
the nodes transformed to the cell coordinate system.
**Parameter:** `g` - 
**Parameter:** `Edge2CellTrafoIndex` - The transformation index (from edge to cell coordinate system), i.e. an index into [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafos](#bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafos),
see also [BoSSS.Foundation.Grid.Classic.GridData.EdgeData.Edge2CellTrafoIndex](#bosss.foundation.grid.classic.griddata.edgedata.edge2celltrafoindex).
**Parameter:** `useCaching` - 
**Returns:**


## Class: BoSSS.Foundation.Properties.Resources <a id="bosss.foundation.properties.resources"></a>

**Summary:** A strongly-typed resource class, for looking up localized strings, etc.


### Property: BoSSS.Foundation.Properties.Resources.ResourceManager <a id="bosss.foundation.properties.resources.resourcemanager"></a>
**Summary:** Returns the cached ResourceManager instance used by this class.


### Property: BoSSS.Foundation.Properties.Resources.Culture <a id="bosss.foundation.properties.resources.culture"></a>
**Summary:** Overrides the current thread's CurrentUICulture property for all
resource lookups using this strongly typed resource class.


### Property: BoSSS.Foundation.Properties.Resources.DBE_empty <a id="bosss.foundation.properties.resources.dbe_empty"></a>
**Summary:** Looks up a localized string similar to <?xml version="1.0" encoding="utf-8"?>
<!--
Copyright 2017 Technische Universitaet Darmstadt, Fachgebiet fuer Stroemungsdynamik (chair of fluid dynamics)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" B [rest of string was truncated]";.

## Class: BoSSS.Foundation.QuadOrderFunc <a id="bosss.foundation.quadorderfunc"></a>

**Summary:** Provides a Function to Calculate Quadrature Orders


## Method: BoSSS.Foundation.QuadOrderFunc.MaxDegTimesTwo <a id="bosss.foundation.quadorderfunc.maxdegtimestwo"></a>
**Summary:** Twice the maximum degree of any of the domain, parameter or codomain fields.
**Returns:**



## Method: BoSSS.Foundation.QuadOrderFunc.FixedOrder(System.Int32) <a id="bosss.foundation.quadorderfunc.fixedorder(system.int32)"></a>
**Summary:** A fixed quadrature order, which completely ignored the DG polynomial degrees of any DG field.
**Parameter:** `order` - fixed quadrature order.
**Returns:**
A function which always returns the value 'order'.


## Method: BoSSS.Foundation.QuadOrderFunc.Linear <a id="bosss.foundation.quadorderfunc.linear"></a>
**Summary:** Assumes a linear integrand, resp. flux.
**Returns:**
A function that computes an integration degree according to
1 + $codomainDegree + $parameterDegree
and rounding the result to the next highest even number


## Method: BoSSS.Foundation.QuadOrderFunc.NonLinear(System.Int32) <a id="bosss.foundation.quadorderfunc.nonlinear(system.int32)"></a>
**Summary:** Assumes a non-linear integrand where the highest term behaves like
$u^{\texttt{NonLinDeg"}}$
**Parameter:** `NonLinDeg` - 
**Returns:**
A function that computes an integration degree according to
'NonLinDeg' + $codomainDegree + $parameterDegree
and rounding the result to the next highest even number


## Method: BoSSS.Foundation.QuadOrderFunc.NonLinearWithoutParameters(System.Int32,System.Boolean) <a id="bosss.foundation.quadorderfunc.nonlinearwithoutparameters(system.int32,system.boolean)"></a>
**Summary:** Just as [BoSSS.Foundation.QuadOrderFunc.NonLinear(System.Int32)](#bosss.foundation.quadorderfunc.nonlinear(system.int32)), but ignoring the degree of
the parameter fields.
**Parameter:** `NonLinDeg` - 
**Parameter:** `RoundUp` - 
**Returns:**



## Method: BoSSS.Foundation.QuadOrderFunc.SumOfMaxDegrees(System.Int32,System.Boolean) <a id="bosss.foundation.quadorderfunc.sumofmaxdegrees(system.int32,system.boolean)"></a>
**Summary:** Version of [BoSSS.Foundation.QuadOrderFunc.NonLinear(System.Int32)](#bosss.foundation.quadorderfunc.nonlinear(system.int32)) where rounding can be
controlled
**Parameter:** `NonLinDeg` - 
**Parameter:** `RoundUp` - 
**Returns:**



## Method: BoSSS.Foundation.QuadOrderFunc.SumOfMaxDegreesWithRounding(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Boolean) <a id="bosss.foundation.quadorderfunc.sumofmaxdegreeswithrounding(system.int32[],system.int32[],system.int32[],system.int32,system.boolean)"></a>
**Summary:** used by [BoSSS.Foundation.QuadOrderFunc.SumOfMaxDegrees(System.Int32,System.Boolean)](#bosss.foundation.quadorderfunc.sumofmaxdegrees(system.int32,system.boolean)).


## Method: BoSSS.Foundation.QuadOrderFunc.MaxOr0``1(``0) <a id="bosss.foundation.quadorderfunc.maxor0``1(``0)"></a>
**Summary:** Returns 0 for an empty list

## Class: BoSSS.Foundation.Resource <a id="bosss.foundation.resource"></a>

**Summary:** A strongly-typed resource class, for looking up localized strings, etc.


### Property: BoSSS.Foundation.Resource.ResourceManager <a id="bosss.foundation.resource.resourcemanager"></a>
**Summary:** Returns the cached ResourceManager instance used by this class.


### Property: BoSSS.Foundation.Resource.Culture <a id="bosss.foundation.resource.culture"></a>
**Summary:** Overrides the current thread's CurrentUICulture property for all
resource lookups using this strongly typed resource class.


### Property: BoSSS.Foundation.Resource.LineQuadRules_bin <a id="bosss.foundation.resource.linequadrules_bin"></a>
**Summary:** Looks up a localized string similar to xeoAAARRdWFkcnVsZXMAteoAAAMwAEYAAAAQSXRlbTEAAQAAAARJdGVtMgAYAAAABDAAEAAAAAEwAAAAAAAAAAAAAAAESXRlbTMAEAAAAAEwAAAAAAAAAABAAAADMQBUAQAAEEl0ZW0xABMAAAAESXRlbTIAwwAAAAQwABAAAAABMADa8ioGPirvvwAEMQAQAAAAATAA97KcXpmu678ABDIAEAAAAAEwAJThjSK5veW/AAQzABAAAAABMADYagEJwLzbvwAENAAQAAAAATAAcuKReFAOw78ABDUAEAAAAAEwAHLikXhQDsM/AAQ2ABAAAAABMADYagEJwLzbPwAENwAQAAAAATAAlOGNIrm95T8ABDgAEAAAAAEwAPeynF6Zrus/AAQ5ABAAAAABMADa8ioGPirvPwAABEl0ZW0zAHMAAAABMAAc3GKLXxGxPwExAPTveMg4IcM/ATIAMLwAnQULzD8BMwD4m1V6qjvRPwE0APHWFHDe6dI/ATUA8dYU [rest of string was truncated]";.


### Property: BoSSS.Foundation.Resource.TetraQuadRules_bin <a id="bosss.foundation.resource.tetraquadrules_bin"></a>
**Summary:** Looks up a localized string similar to FZwbAARRdWFkcnVsZXMABZwbAAMwAFwAAAAQSXRlbTEAAQAAAARJdGVtMgAuAAAABDAAJgAAAAEwAAAAAAAAAAAAATEAAAAAAAAAAAABMgAAAAAAAAAAAAAABEl0ZW0zABAAAAABMACB7tHxizn3PwAAAzEA+AAAABBJdGVtMQABAAAABEl0ZW0yAKkAAAAEMAAmAAAAATAA2PbUolSG4L8BMQCSnirZwxTTvwEyAGthYNgZ/Mq/AAQxACYAAAABMAAAAAAAAAAAAAExAAAAAAAAAAAAATIAEElIYhM95D8ABDIAJgAAAAEwAAAAAAAAAAAAATEAkp4q2cMU4z8BMgBrYWDYGfzKvwAEMwAmAAAAATAA2PbUolSG4D8BMQCSnirZwxTTvwEyAGthYNgZ/Mq/AAAESXRlbTMAMQAAAAEwAHju0fGLOdc/ATEAeO7R8Ys51z8BMgB47tHxiznXPwEzAHju0fGLOdc/AAADMgAsAQAAEEl0ZW0xAAIAAAAE [rest of string was truncated]";.


### Property: BoSSS.Foundation.Resource.TriangleQuadRules_bin <a id="bosss.foundation.resource.trianglequadrules_bin"></a>
**Summary:** Looks up a localized string similar to t+8BAARRdWFkcnVsZXMAp+8BAAMwAFEAAAAQSXRlbTEAAQAAAARJdGVtMgAjAAAABDAAGwAAAAEwAAAAAAAAAAAAATEAVVVVVVVV1T8AAARJdGVtMwAQAAAAATAAHDOQRad5AkAAAAMxAMwAAAAQSXRlbTEAAwAAAARJdGVtMgB9AAAABDAAGwAAAAEwALS72sE30+C/ATEAxyGWa/I7z78ABDEAGwAAAAEwALS72sE30+A/ATEAxyGWa/I7z78ABDIAGwAAAAEwAIVm6k12CMK/ATEAx9068FEk7T8ABDMAGwAAAAEwAIVm6k12CMI/ATEAx9068FEk7T8AAARJdGVtMwAxAAAAATAAx9068FEk7T8BMQDH3TrwUSTtPwEyAMchlmvyO88/ATMAxyGWa/I7zz8AAAMyAJkBAAAQSXRlbTEABQAAAARJdGVtMgATAQAABDAAGwAAAAEwAP57NqZdZem/ATEAOo8pk6g93L8ABDEAGwAAAAEwAAAAAAAA [rest of string was truncated]";.

## Class: BoSSS.Foundation.ScalarFunction <a id="bosss.foundation.scalarfunction"></a>

**Summary:** delegate for steady-state scalar functions in D-dimensional space,
vectorized definition.

## Class: BoSSS.Foundation.ScalarFunctionTimeDep <a id="bosss.foundation.scalarfunctiontimedep"></a>

**Summary:** delegate for time-dependent scalar functions in D-dimensional space,
vectorized definition.

## Class: BoSSS.Foundation.ScalarFunctionExt <a id="bosss.foundation.scalarfunctionext"></a>

**Summary:** Extensions functions for [BoSSS.Foundation.ScalarFunction](#bosss.foundation.scalarfunction)


## Method: BoSSS.Foundation.ScalarFunctionExt.SetTime(BoSSS.Foundation.ScalarFunctionTimeDep,System.Double) <a id="bosss.foundation.scalarfunctionext.settime(bosss.foundation.scalarfunctiontimedep,system.double)"></a>
**Summary:** fixing the time for some time-depended function 'f'.

## Class: BoSSS.Foundation.ScalarFunctionEx <a id="bosss.foundation.scalarfunctionex"></a>

**Summary:** Evaluates the scalar function
at points specified in node set 'nodes'
in all cells from 'j0' to
'j0'+'Len'-1 and writes them
to 'result'.

**Remark:**
This method is vectorized: Here, it means that the Points at which the DG field should be evaluated,
are given for one cell in reference coordinates, but
the evaluation is performed for 'Len' cells at once.

## Class: BoSSS.Foundation.ScalarFunctionExtensions <a id="bosss.foundation.scalarfunctionextensions"></a>

**Summary:** extend! extend! extend!


## Method: BoSSS.Foundation.ScalarFunctionExtensions.Map(BoSSS.Foundation.ScalarFunctionEx,System.Func{System.Double,System.Double}) <a id="bosss.foundation.scalarfunctionextensions.map(bosss.foundation.scalarfunctionex,system.func{system.double,system.double})"></a>
**Summary:** creates a [BoSSS.Foundation.ScalarFunctionEx](#bosss.foundation.scalarfunctionex) which represents the comosition
$T \circ f$
**Parameter:** `f` - original function $f$
**Parameter:** `T` - transformation $T$
**Returns:**


## Class: BoSSS.Foundation.SinglePhaseField <a id="bosss.foundation.singlephasefield"></a>

**Summary:** 'normal' DG field


## Method: BoSSS.Foundation.SinglePhaseField.Factory(BoSSS.Foundation.Basis,System.String) <a id="bosss.foundation.singlephasefield.factory(bosss.foundation.basis,system.string)"></a>
**Summary:** a factory for [BoSSS.Foundation.SinglePhaseField](#bosss.foundation.singlephasefield)
**Parameter:** `__Basis` - The basis that is used for this field
**Parameter:** `__Identification` - identification string for this field; This can be null or empty,
however, if IO should be performed for this object, the
identification must be unique within the given context.
**Returns:**
a [BoSSS.Foundation.SinglePhaseField](#bosss.foundation.singlephasefield)-instance


## Method: BoSSS.Foundation.SinglePhaseField.#ctor(BoSSS.Foundation.Basis) <a id="bosss.foundation.singlephasefield.#ctor(bosss.foundation.basis)"></a>
**Summary:** constructs a new field with an empty identification string 
(see [BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification)); Because of this, this
field can't be used for IO;


### Field: BoSSS.Foundation.SinglePhaseField.m_Mda_Coordinates <a id="bosss.foundation.singlephasefield.m_mda_coordinates"></a>
**Summary:** storage for DG coordinates: [BoSSS.Foundation.DGField.Coordinates](#bosss.foundation.dgfield.coordinates)


### Property: BoSSS.Foundation.SinglePhaseField.Coordinates <a id="bosss.foundation.singlephasefield.coordinates"></a>
**Summary:** DG Coordinates


## Method: BoSSS.Foundation.SinglePhaseField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.singlephasefield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** see [BoSSS.Foundation.DGField.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double)](#bosss.foundation.dgfield.evaluate(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double))


## Method: BoSSS.Foundation.SinglePhaseField.EvaluateEdge(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.singlephasefield.evaluateedge(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** Evaluates the field along edges.
**Parameter:** `ResultIndexOffset` - An offset for the first index of 'ValueIN' resp. 'ValueOT',
i.e. the first result will be written to
'ValueIN'['ResultIndexOffset',*].
**Parameter:** `e0` - Index of the first edge to evaluate.
**Parameter:** `Len` - Number of edges to evaluate
**Parameter:** `NS` - nodes to evaluate at
**Parameter:** `ValueIN` - If not null, contains the following output: 
On exit, the value of the DG field at the given nodes are
accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 2-dimensional:


1st index: edge index j - 'e0';


2nd index: node index k, corresponds with 1st index of
the node set 'NS';
**Parameter:** `ValueOT` - Same as 'ValueIN'.
**Parameter:** `MeanValueIN` -
If not null, contains the following output: 
On exit, the mean values of the DG field at the given edges are
accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 2-dimensional:
- 1st index: edge index j - 'e0';
- 2nd index: node index k, corresponds with 1st index of
the node set 'NS';
**Parameter:** `MeanValueOT` - Same as 'MeanValueIN'.
**Parameter:** `GradientIN` -
If not null, contains the following output: 
On exit, the value of the gradient of DG field at the given nodes
are accumulated (!) there. Before the values are added, 
the original content is scaled by 'ResultPreScale'.
The array is 3-dimensional:
- 1st index: edge index j - 'e0';
- 2nd index: node index k, corresponds with 1st index of
the node set 'NS';
- 3rd index: spatial dimension;
**Parameter:** `GradientOT` - Same as 'GradientIN'.
**Parameter:** `ResultPreScale` - Scaling that is applied to 'ValueIN' and 'ValueOT' before
the field evaluation is added


## Method: BoSSS.Foundation.SinglePhaseField.EvaluateGradient(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray,System.Int32,System.Double) <a id="bosss.foundation.singlephasefield.evaluategradient(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray,system.int32,system.double)"></a>
**Summary:** Evaluates the gradient of the field;
**Parameter:** `j0` - local index of the first cell to evaluate
**Parameter:** `Len` - Number of cells to evaluate
**Parameter:** `NS` - As usual, the node set.
**Parameter:** `result` - on exit, result of the evaluations are accumulated there;
the original content is scaled by 'ResultPreScale';
1st index: cell index minus 'j0';
2nd index: node index;
3rd index: spatial coordinate;
**Parameter:** `ResultCellindexOffset` - an offset for the first index of 'result';
**Parameter:** `ResultPreScale` - see 'result'


## Method: BoSSS.Foundation.SinglePhaseField.EvaluateHessian(System.Int32,System.Int32,BoSSS.Foundation.NodeSet,ilPSP.MultidimensionalArray) <a id="bosss.foundation.singlephasefield.evaluatehessian(system.int32,system.int32,bosss.foundation.nodeset,ilpsp.multidimensionalarray)"></a>
**Summary:** Evaluates all 2nd derivatives (by cell-local analytic derivation of
the basis polynomials) of this field;
**Parameter:** `j0` - 
**Parameter:** `Len` - 
**Parameter:** `NS` - 
**Parameter:** `result` -
1st index: cell index j
2nd index: node index m into nodeset 'NS'
3rd index: spatial direction of 1st derivation, k
4th index: spatial direction of 2nd derivation, l

So, the entry [j,m,k,l] = $\frac{\partial}{\partial x_k} \frac{\partial}{\partial x_l} \varphi (\vec{\xi}_m)$ 
where $\vec{xi}_m$  is the m-th
vector in the node set 'NS', in the
j-th cell.
**Remark:**
Because of 2 derivatives taken, this field needs to be at least of
DG degree 2 to get a non-zero result from this method.


## Method: BoSSS.Foundation.SinglePhaseField.#ctor(BoSSS.Foundation.Basis,System.String) <a id="bosss.foundation.singlephasefield.#ctor(bosss.foundation.basis,system.string)"></a>
**Summary:** constructs a new field.
**Parameter:** `__Basis` - The basis that is used for this field
**Parameter:** `__Identification` - identification string for this field;
This can be null or empty, 
however, if IO should be preformed for this object, the identification must be unique 
within the given context;


## Method: BoSSS.Foundation.SinglePhaseField.Clone <a id="bosss.foundation.singlephasefield.clone"></a>
**Summary:** guess what?
**Returns:**



## Method: BoSSS.Foundation.SinglePhaseField.FillMPISendBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.singlephasefield.fillmpisendbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.FillMPISendBuffer(System.Int32,System.Double[],System.Int32)](#bosss.foundation.dgfield.fillmpisendbuffer(system.int32,system.double[],system.int32)), performance-optimized version;


## Method: BoSSS.Foundation.SinglePhaseField.CopyFromMPIrecvBuffer(System.Int32,System.Double[],System.Int32) <a id="bosss.foundation.singlephasefield.copyfrommpirecvbuffer(system.int32,system.double[],system.int32)"></a>
**Summary:** see [BoSSS.Foundation.DGField.CopyFromMPIrecvBuffer(System.Int32,System.Double[],System.Int32)](#bosss.foundation.dgfield.copyfrommpirecvbuffer(system.int32,system.double[],system.int32)), performance-optimized version;


## Method: BoSSS.Foundation.SinglePhaseField.CloneAs <a id="bosss.foundation.singlephasefield.cloneas"></a>
**Summary:** guess what?


## Method: BoSSS.Foundation.SinglePhaseField.Acc(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.singlephasefield.acc(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** see [BoSSS.Foundation.DGField.Acc(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.acc(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask));

## Class: BoSSS.Foundation.SinglePhaseField.SinglePhaseFieldInitializer <a id="bosss.foundation.singlephasefield.singlephasefieldinitializer"></a>

**Summary:** Specialized initializer for single phase fields


## Method: BoSSS.Foundation.SinglePhaseField.SinglePhaseFieldInitializer.Initialize(BoSSS.Foundation.IO.IInitializationContext) <a id="bosss.foundation.singlephasefield.singlephasefieldinitializer.initialize(bosss.foundation.io.iinitializationcontext)"></a>
**Parameter:** `c` - 
**Returns:**



### Field: BoSSS.Foundation.SinglePhaseField.SinglePhaseFieldInitializer.myInstance <a id="bosss.foundation.singlephasefield.singlephasefieldinitializer.myinstance"></a>
**Summary:** Instance of the represented object, if already created.


## Method: BoSSS.Foundation.SinglePhaseField.SinglePhaseFieldInitializer.Equals(BoSSS.Foundation.IO.Initializer{BoSSS.Foundation.DGField}) <a id="bosss.foundation.singlephasefield.singlephasefieldinitializer.equals(bosss.foundation.io.initializer{bosss.foundation.dgfield})"></a>
**Summary:** Compares the given object 'other' with respect
to the [BoSSS.Foundation.DGField.FieldInitializer.Identification](#bosss.foundation.dgfield.fieldinitializer.identification)
and the [BoSSS.Foundation.DGField.FieldInitializer.BasisInfo](#bosss.foundation.dgfield.fieldinitializer.basisinfo).


## Method: BoSSS.Foundation.SinglePhaseField.SinglePhaseFieldInitializer.GetHashCode <a id="bosss.foundation.singlephasefield.singlephasefieldinitializer.gethashcode"></a>
**Summary:** Computes a hash code based on 
[BoSSS.Foundation.DGField.FieldInitializer.Identification](#bosss.foundation.dgfield.fieldinitializer.identification) and
[BoSSS.Foundation.DGField.FieldInitializer.BasisInfo](#bosss.foundation.dgfield.fieldinitializer.basisinfo).


### Property: BoSSS.Foundation.SinglePhaseField.Initializer <a id="bosss.foundation.singlephasefield.initializer"></a>
**Summary:** To support IO-architecture, NOT for direct user interaction. 
Note that it is essential that this member always returns the SAME object (reference-equals)!

## Class: BoSSS.Foundation.ConstantTemporalOperator <a id="bosss.foundation.constanttemporaloperator"></a>

**Summary:** A constant, diagonal operator


## Method: BoSSS.Foundation.ConstantTemporalOperator.#ctor(BoSSS.Foundation.DifferentialOperator,System.Double) <a id="bosss.foundation.constanttemporaloperator.#ctor(bosss.foundation.differentialoperator,system.double)"></a>
**Summary:** Ctor, the same factor in the temporal derivative for all
**Parameter:** `__owner` - 
**Parameter:** `diagonalValue` - 


## Method: BoSSS.Foundation.ConstantTemporalOperator.#ctor(BoSSS.Foundation.DifferentialOperator,System.Double[]) <a id="bosss.foundation.constanttemporaloperator.#ctor(bosss.foundation.differentialoperator,system.double[])"></a>
**Summary:** Ctor
**Parameter:** `__owner` - 
**Parameter:** `diagonal` - Matrix diagonal per variable, i.e. if '__owner' has 4 domain and 4 codomain variables,
this must have 4 entries too, providing a single factor for the temporal derivative of each equation.


## Method: BoSSS.Foundation.ConstantTemporalOperator.SetDiagonal(System.String,System.Double) <a id="bosss.foundation.constanttemporaloperator.setdiagonal(system.string,system.double)"></a>
**Summary:** Modifies the diagonal entries.
**Parameter:** `val` - value to set for the diagonal entry
**Parameter:** `eqnName` - some codomain name in [BoSSS.Foundation.IDifferentialOperator.CodomainVar](#bosss.foundation.idifferentialoperator.codomainvar)


## Method: BoSSS.Foundation.ConstantTemporalOperator.SetDiagonal(System.Int32,System.Double) <a id="bosss.foundation.constanttemporaloperator.setdiagonal(system.int32,system.double)"></a>
**Summary:** Modifies the diagonal entries.
**Parameter:** `eqIdx` - equation index
**Parameter:** `val` - value to set for the diagonal entry


## Method: BoSSS.Foundation.ConstantTemporalOperator.Commit <a id="bosss.foundation.constanttemporaloperator.commit"></a>
**Summary:** locks the configuration of the operator


## Method: BoSSS.Foundation.ConstantTemporalOperator.GetMassMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.constanttemporaloperator.getmassmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** Returns an matrix builder which always accumulates the same diagonal matrix.

## Class: BoSSS.Foundation.ConstantTemporalOperator.InternalBla <a id="bosss.foundation.constanttemporaloperator.internalbla"></a>


### Property: BoSSS.Foundation.ConstantTemporalOperator.InternalBla.time <a id="bosss.foundation.constanttemporaloperator.internalbla.time"></a>
**Summary:** No effect, operator is constant in time


### Property: BoSSS.Foundation.ConstantTemporalOperator.InternalBla.MPITtransceive <a id="bosss.foundation.constanttemporaloperator.internalbla.mpittransceive"></a>
**Summary:** ignored - no effect


### Property: BoSSS.Foundation.ConstantTemporalOperator.InternalBla.Owner <a id="bosss.foundation.constanttemporaloperator.internalbla.owner"></a>


## Method: BoSSS.Foundation.ConstantTemporalOperator.InternalBla.ComputeAffine``1(``0) <a id="bosss.foundation.constanttemporaloperator.internalbla.computeaffine``1(``0)"></a>
**Summary:** No effect;

## Class: BoSSS.Foundation.DependentTemporalOperator <a id="bosss.foundation.dependenttemporaloperator"></a>

**Summary:** Temporal operator which is fully customizable, i.e. can be configured through [BoSSS.Foundation.DependentTemporalOperator.EquationComponents](#bosss.foundation.dependenttemporaloperator.equationcomponents)
in analog fashion to the spatial operator.


## Method: BoSSS.Foundation.DependentTemporalOperator.#ctor(BoSSS.Foundation.DifferentialOperator) <a id="bosss.foundation.dependenttemporaloperator.#ctor(bosss.foundation.differentialoperator)"></a>
**Summary:** ctor-
**Parameter:** `__owner` - 


### Property: BoSSS.Foundation.DependentTemporalOperator.EquationComponents <a id="bosss.foundation.dependenttemporaloperator.equationcomponents"></a>
**Summary:** Components of the Mass matrix


## Method: BoSSS.Foundation.DependentTemporalOperator.Commit <a id="bosss.foundation.dependenttemporaloperator.commit"></a>
**Summary:** locks the configuration of the operator


## Method: BoSSS.Foundation.DependentTemporalOperator.GetMassMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.dependenttemporaloperator.getmassmatrixbuilder(bosss.foundation.unsetteledcoordinatemapping,system.collections.generic.ilist{bosss.foundation.dgfield},bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** as defined by interface

## Class: BoSSS.Foundation.TestingIO <a id="bosss.foundation.testingio"></a>

**Summary:** Utility class for testing: Enables the comparison of calculations with different number of MPI cores, 
typically the comparison of a single-core vs. a parallel run, without using a BoSSS database.

E.g. assume that one would compare a serial run (i.e. 1 MPI core) with a parallel run (e.g. 4 MPI cores):
- one would first run the app with 1 core, next with 4 cores; note that any other comparison is also possible e.g. comparing a 3-core run to a 99 core run.
- if 1 core is the reference computation, [BoSSS.Foundation.TestingIO.ReferenceMPISize](#bosss.foundation.testingio.referencempisize) must be set to 1
- one can compare any numerical data (i.e. doubles) which can be correlated with cells of the mesh
- this triggers saving is the current number of MPI cores is 1 (i.e. the reference size), and loading of data otherwise.
- for runs which have a different number of MPI cores than the reference size, numeraical values will be compared.

The typical use-case of this class is as follows:
1. Instantiate ([BoSSS.Foundation.TestingIO.#ctor(BoSSS.Foundation.Grid.IGridData,System.String,System.Boolean,System.Int32)](#bosss.foundation.testingio.#ctor(bosss.foundation.grid.igriddata,system.string,system.boolean,system.int32)))
2. Add Vectors, DG fields, etc. ([BoSSS.Foundation.TestingIO.AddVector(System.String,System.Collections.Generic.IEnumerable{System.Double})](#bosss.foundation.testingio.addvector(system.string,system.collections.generic.ienumerable{system.double})), [BoSSS.Foundation.TestingIO.AddDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.testingio.adddgfield(bosss.foundation.conventionaldgfield)), [BoSSS.Foundation.TestingIO.AddColumn(System.String,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo)](#bosss.foundation.testingio.addcolumn(system.string,bosss.foundation.grid.executionmask.iteminfo)))
to this IO object; 
3. Call [BoSSS.Foundation.TestingIO.DoIOnow](#bosss.foundation.testingio.doionow) th either save the current data or load the reference data 
4. Use functions such as [BoSSS.Foundation.TestingIO.AllAbsErr](#bosss.foundation.testingio.allabserr), [BoSSS.Foundation.TestingIO.AllRelErr](#bosss.foundation.testingio.allrelerr) to compute difference norms between reference and current data


### Property: BoSSS.Foundation.TestingIO.CSVfile <a id="bosss.foundation.testingio.csvfile"></a>
**Summary:** Data file in which the reference data for comparison is stored


### Property: BoSSS.Foundation.TestingIO.ReferenceMPISize <a id="bosss.foundation.testingio.referencempisize"></a>
**Summary:** The number of MPI course for the reference computation, typically 1 (single core).
- (Reference mode): If the current MPI size is equal to this value, data from [BoSSS.Foundation.TestingIO.CurrentData](#bosss.foundation.testingio.currentdata) is saved in file [BoSSS.Foundation.TestingIO.CSVfile](#bosss.foundation.testingio.csvfile).
- (Comparison mode): If the current MPI size is different, data is loaded from file [BoSSS.Foundation.TestingIO.CSVfile](#bosss.foundation.testingio.csvfile) into [BoSSS.Foundation.TestingIO.ReferenceData](#bosss.foundation.testingio.referencedata)


### Property: BoSSS.Foundation.TestingIO.CurrentData <a id="bosss.foundation.testingio.currentdata"></a>
**Summary:** Data produced in current process 
- key: column name
- content: array containing one value per cell.
Remark: in the case of multiple values per cell (e.g. for a DG field, [BoSSS.Foundation.TestingIO.AddDGField(BoSSS.Foundation.ConventionalDGField)](#bosss.foundation.testingio.adddgfield(bosss.foundation.conventionaldgfield))), each of those values will/must be delegated to a separate columen;
(e.g. for a DG-field, there will be one column per mode).


### Property: BoSSS.Foundation.TestingIO.ReferenceData <a id="bosss.foundation.testingio.referencedata"></a>
**Summary:** Reference data loaded from file


### Property: BoSSS.Foundation.TestingIO.CheckGlobalID <a id="bosss.foundation.testingio.checkglobalid"></a>
**Summary:** - true: cells are compared according to GlobalID
- false: cells are related according to a geometrical code ([BoSSS.Platform.Utils.Geom.GeomBinTreeBranchCode](BoSSS.Platform.md#bosss.platform.utils.geom.geombintreebranchcode))


## Method: BoSSS.Foundation.TestingIO.#ctor(BoSSS.Foundation.Grid.IGridData,System.String,System.Boolean,System.Int32) <a id="bosss.foundation.testingio.#ctor(bosss.foundation.grid.igriddata,system.string,system.boolean,system.int32)"></a>


### Property: BoSSS.Foundation.TestingIO.ColumnNames <a id="bosss.foundation.testingio.columnnames"></a>
**Summary:** Sorted column names;
- 0-th entry is the global id,
- 1st, 2nd, .. entry: cell center coordinates


### Property: BoSSS.Foundation.TestingIO.ColumnNamesWithoutReserved <a id="bosss.foundation.testingio.columnnameswithoutreserved"></a>
**Summary:** Sorted column names


## Method: BoSSS.Foundation.TestingIO.AoA2Dict(System.Double[][]) <a id="bosss.foundation.testingio.aoa2dict(system.double[][])"></a>
**Summary:** Array of Arrays -> dict


## Method: BoSSS.Foundation.TestingIO.DoIOnow <a id="bosss.foundation.testingio.doionow"></a>
**Summary:** Performs the IO operation:
- if current number of MPI processes is equal to [BoSSS.Foundation.TestingIO.ReferenceMPISize](#bosss.foundation.testingio.referencempisize), data is written to file [BoSSS.Foundation.TestingIO.CSVfile](#bosss.foundation.testingio.csvfile)
- otherwise, reference data is loaded


## Method: BoSSS.Foundation.TestingIO.SaveData <a id="bosss.foundation.testingio.savedata"></a>
**Summary:** saves data in [BoSSS.Foundation.TestingIO.CSVfile](#bosss.foundation.testingio.csvfile).


## Method: BoSSS.Foundation.TestingIO.LoadData <a id="bosss.foundation.testingio.loaddata"></a>
**Summary:** Loads data from [BoSSS.Foundation.TestingIO.CSVfile](#bosss.foundation.testingio.csvfile) (on rank 0) and scatters it among MPI processors


## Method: BoSSS.Foundation.TestingIO.AbsError(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.testingio.abserror(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Absolute L2 for DG fields


## Method: BoSSS.Foundation.TestingIO.AbsError(System.String) <a id="bosss.foundation.testingio.abserror(system.string)"></a>
**Summary:** Absolute L2 error between columns


## Method: BoSSS.Foundation.TestingIO.LocError(System.String) <a id="bosss.foundation.testingio.locerror(system.string)"></a>
**Summary:** Difference between data in file and data in column 'Colname'


## Method: BoSSS.Foundation.TestingIO.RelError(System.String) <a id="bosss.foundation.testingio.relerror(system.string)"></a>
**Summary:** Relative L2 error between columns


## Method: BoSSS.Foundation.TestingIO.AllRelErr <a id="bosss.foundation.testingio.allrelerr"></a>
**Summary:** Relative Errors for all known columns


## Method: BoSSS.Foundation.TestingIO.AllAbsErr <a id="bosss.foundation.testingio.allabserr"></a>
**Summary:** Relative Errors for all known columns


## Method: BoSSS.Foundation.TestingIO.AddVector(System.String,System.Collections.Generic.IEnumerable{System.Double}) <a id="bosss.foundation.testingio.addvector(system.string,system.collections.generic.ienumerable{system.double})"></a>


## Method: BoSSS.Foundation.TestingIO.AddColumn(System.String,BoSSS.Foundation.Grid.ExecutionMask.ItemInfo) <a id="bosss.foundation.testingio.addcolumn(system.string,bosss.foundation.grid.executionmask.iteminfo)"></a>
**Summary:** Collects cell-wise data from [BoSSS.Foundation.Grid.ExecutionMask.ItemInfo](#bosss.foundation.grid.executionmask.iteminfo)


## Method: BoSSS.Foundation.TestingIO.AddDGField(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.testingio.adddgfield(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Adds a DG field


## Method: BoSSS.Foundation.TestingIO.LocalError(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.testingio.localerror(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Adds a DG field


## Method: BoSSS.Foundation.TestingIO.OverwriteDGField(BoSSS.Foundation.ConventionalDGField) <a id="bosss.foundation.testingio.overwritedgfield(bosss.foundation.conventionaldgfield)"></a>
**Summary:** Overwrites the memory of a DG field with the reference data
**Parameter:** `f` - 


## Method: BoSSS.Foundation.TestingIO.GatherAndSort(BoSSS.Foundation.Grid.IGridData,System.Double[][]) <a id="bosss.foundation.testingio.gatherandsort(bosss.foundation.grid.igriddata,system.double[][])"></a>
**Summary:** Gathers cell-wise data on rank 0 in a sorted fashion (independent of grid permutation), which can be 
compared among different runs, with different MPI sizes.


## Method: BoSSS.Foundation.TestingIO.ScatterSortedData(BoSSS.Foundation.Grid.IGridData,System.Double[][]) <a id="bosss.foundation.testingio.scattersorteddata(bosss.foundation.grid.igriddata,system.double[][])"></a>
**Summary:** Scatters data from rank 0 (independent of grid permutation) to all processes, according to MPI partition.
**Parameter:** `SortedDataColumns` - Data, sorted according to GlobalId, at rank 0
**Parameter:** `G` - 

## Class: BoSSS.Foundation.UnsetteledCoordinateMapping <a id="bosss.foundation.unsetteledcoordinatemapping"></a>

**Summary:** This class provides bijective mappings:


First, between local field coordinate indices and local unique indices,
by the methods [BoSSS.Foundation.UnsetteledCoordinateMapping.LocalUniqueCoordinateIndex(System.Int32,System.Int32,System.Int32)](#bosss.foundation.unsetteledcoordinatemapping.localuniquecoordinateindex(system.int32,system.int32,system.int32)) and [BoSSS.Foundation.UnsetteledCoordinateMapping.LocalFieldCoordinateIndex(System.Int32,System.Int32@,System.Int32@,System.Int32@)](#bosss.foundation.unsetteledcoordinatemapping.localfieldcoordinateindex(system.int32,system.int32@,system.int32@,system.int32@)), 
and ...


second, between local unique indices and global unique indices,
by the methods [BoSSS.Foundation.UnsetteledCoordinateMapping.Global2LocalIndex(System.Int64)](#bosss.foundation.unsetteledcoordinatemapping.global2localindex(system.int64)) and [BoSSS.Foundation.UnsetteledCoordinateMapping.Local2GlobalIndex(System.Int32)](#bosss.foundation.unsetteledcoordinatemapping.local2globalindex(system.int32)).


In easy words, that means it maps the DG coordinate from a list of fields into one long, one-dimensional vector
and it converts between indices that are valid only on the actual MPI process (local indices)
and indices that are valid among all MPI processes in the current MPI communicator (global indices).

**Remark:**
A "local index" is an index that is valid only on the actual MPI process,
while a "global index" is an index that is valid among all MPI processes 
(in the corresponding MPI communicator).
A "local field coordinate index" is a tuple (f,j,n), where...

f is a [BoSSS.Foundation.DGField](#bosss.foundation.dgfield),
j is a local cell index and 
n is a polynomial index;

A "local unique index" is a single integer that is unique for every field in this mapping, 
for every local cell and for every polynomial;

In this class, the DG fields are not specified. Hence, only a list of
[BoSSS.Foundation.Basis](#bosss.foundation.basis)-objects is provided ([BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)) to do the index computation.
Any list of fields with equal DG basis can be accessed;
If the mapping should be limited to a specific list of DG fields, the [BoSSS.Foundation.CoordinateMapping](#bosss.foundation.coordinatemapping)
class can be used.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.#ctor(BoSSS.Foundation.Grid.IGridData) <a id="bosss.foundation.unsetteledcoordinatemapping.#ctor(bosss.foundation.grid.igriddata)"></a>
**Summary:** Constructs an empty mapping.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.#ctor(BoSSS.Foundation.Basis[]) <a id="bosss.foundation.unsetteledcoordinatemapping.#ctor(bosss.foundation.basis[])"></a>
**Summary:** Constructs a new mapping from an ordered list of basis functions;
**Parameter:** `_basis` - the list of DG basis'es that define this mapping


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.#ctor(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis}) <a id="bosss.foundation.unsetteledcoordinatemapping.#ctor(system.collections.generic.ienumerable{bosss.foundation.basis})"></a>
**Summary:** Constructs a new mapping from an ordered list of basis functions;
**Parameter:** `_basis` - the list of DG basis'es that define this mapping


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.#ctor(BoSSS.Foundation.Grid.IGridData,System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis},MPI.Wrappers.MPI_Comm) <a id="bosss.foundation.unsetteledcoordinatemapping.#ctor(bosss.foundation.grid.igriddata,system.collections.generic.ienumerable{bosss.foundation.basis},mpi.wrappers.mpi_comm)"></a>
**Summary:** Constructs a new mapping from an ordered list of basis functions;
**Parameter:** `_basis` - the list of DG basis'es that define this mapping
**Parameter:** `g` - 
**Parameter:** `_Comm` - 


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.TotalNoOfBlocks <a id="bosss.foundation.unsetteledcoordinatemapping.totalnoofblocks"></a>
**Summary:** Equal to total number of cells, i.e. each cell corresponds to one block, see also
**ilPSP.IBlockPartitioning.TotalNoOfBlocks**.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.LocalNoOfBlocks <a id="bosss.foundation.unsetteledcoordinatemapping.localnoofblocks"></a>
**Summary:** Equal to local number of cells, i.e. each cell corresponds to one block, see also
**ilPSP.IBlockPartitioning.TotalNoOfBlocks**.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.FirstBlock <a id="bosss.foundation.unsetteledcoordinatemapping.firstblock"></a>
**Summary:** **ilPSP.IBlockPartitioning.FirstBlock**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetFirstBlock(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.getfirstblock(system.int32)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetFirstBlock(System.Int32)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetLocalNoOfBlocks(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.getlocalnoofblocks(system.int32)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetLocalNoOfBlocks(System.Int32)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.FindProcessForBlock(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.findprocessforblock(system.int64)"></a>
**Summary:** **ilPSP.IBlockPartitioning.FindProcessForBlock(System.Int64)**


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.AllBlockSizesEqual <a id="bosss.foundation.unsetteledcoordinatemapping.allblocksizesequal"></a>
**Summary:** Always true-frame blocks are used here.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockType(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.getblocktype(system.int64)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetBlockType(System.Int64)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockI0(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.getblocki0(system.int64)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetBlockI0(System.Int64)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockLen(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.getblocklen(system.int64)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetBlockLen(System.Int64)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockIndex(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.getblockindex(system.int64)"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetBlockIndex(System.Int64)**


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetImmutableBlockPartitioning <a id="bosss.foundation.unsetteledcoordinatemapping.getimmutableblockpartitioning"></a>
**Summary:** **ilPSP.IBlockPartitioning.GetImmutableBlockPartitioning**


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.IsMutable <a id="bosss.foundation.unsetteledcoordinatemapping.ismutable"></a>
**Summary:** maybe, it depends...


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.CellDepLength <a id="bosss.foundation.unsetteledcoordinatemapping.celldeplength"></a>
**Summary:** True, if the degrees of freedom are cell-dependent.
This depends on the used DG basis (see [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss));


### Field: BoSSS.Foundation.UnsetteledCoordinateMapping.m_Context <a id="bosss.foundation.unsetteledcoordinatemapping.m_context"></a>
**Summary:** DG context


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.GridDat <a id="bosss.foundation.unsetteledcoordinatemapping.griddat"></a>
**Summary:** The grid on which this mapping relies on.


### Field: BoSSS.Foundation.UnsetteledCoordinateMapping.m_j0CoordinateIndex <a id="bosss.foundation.unsetteledcoordinatemapping.m_j0coordinateindex"></a>
**Summary:** local unique index of the 0th coordinate in the 0th cell for each field;
index: field or basis index;


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetTotalNoOfCoordinatesPerCell(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.gettotalnoofcoordinatespercell(system.int32)"></a>
**Parameter:** `j` - local cell index
**Returns:**



## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetLocalNoOfDOFs <a id="bosss.foundation.unsetteledcoordinatemapping.getlocalnoofdofs"></a>
**Summary:** Local (on this MPI process) number of degrees-of-freedom; 
this can be different than **ilPSP.Partitioning.LocalLength**, e.g. in the XDG case.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetTotalNoOfDOFs <a id="bosss.foundation.unsetteledcoordinatemapping.gettotalnoofdofs"></a>
**Summary:** the sum of [BoSSS.Foundation.UnsetteledCoordinateMapping.GetLocalNoOfDOFs](#bosss.foundation.unsetteledcoordinatemapping.getlocalnoofdofs) over all MPI processors in communicator [MPI.Wrappers.MPI_Comm](MPI.Wrappers.md#mpi.wrappers.mpi_comm).


### Field: BoSSS.Foundation.UnsetteledCoordinateMapping.m_MaxTotalNoOfCoordinatesPerCell <a id="bosss.foundation.unsetteledcoordinatemapping.m_maxtotalnoofcoordinatespercell"></a>
**Summary:** the total number of coordinates of all fields in this mapping in one cell.


### Field: BoSSS.Foundation.UnsetteledCoordinateMapping.m_MinTotalNoOfCoordinatesPerCell <a id="bosss.foundation.unsetteledcoordinatemapping.m_mintotalnoofcoordinatespercell"></a>
**Summary:** the minimum number of coordinates of all fields in this mapping in one cell.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.MaxTotalNoOfCoordinatesPerCell <a id="bosss.foundation.unsetteledcoordinatemapping.maxtotalnoofcoordinatespercell"></a>
**Summary:** the total number of coordinates of all fields in this mapping in one cell.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.MinTotalNoOfCoordinatesPerCell <a id="bosss.foundation.unsetteledcoordinatemapping.mintotalnoofcoordinatespercell"></a>
**Summary:** the total number of coordinates of all fields in this mapping in one cell.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.NoOfCoordinatesPerCell <a id="bosss.foundation.unsetteledcoordinatemapping.noofcoordinatespercell"></a>
**Summary:** Number of DG coordinates  of all fields in this mapping in one cell.


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.NoOfVariables <a id="bosss.foundation.unsetteledcoordinatemapping.noofvariables"></a>
**Summary:** Number of elements in [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss), i.e. number of dependent variables resp. scalar fields.


### Field: BoSSS.Foundation.UnsetteledCoordinateMapping.m_BasisS <a id="bosss.foundation.unsetteledcoordinatemapping.m_basiss"></a>
**Summary:** [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss);


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS <a id="bosss.foundation.unsetteledcoordinatemapping.basiss"></a>
**Summary:** the basis object of all field in this mapping;
**Remark:**
By this list, an basis index, or field index for each basis in this mapping is defined;


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.Global2LocalIndex(System.Int64) <a id="bosss.foundation.unsetteledcoordinatemapping.global2localindex(system.int64)"></a>
**Summary:** converts a global unique coordinate index into a local unique coordinate index
**Parameter:** `iglobal` - 
**Returns:**



### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.Ntotal <a id="bosss.foundation.unsetteledcoordinatemapping.ntotal"></a>
**Summary:** total number of locally stored coordinates
(internal, border and external elements);


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.NExternal <a id="bosss.foundation.unsetteledcoordinatemapping.nexternal"></a>
**Summary:** number of external, or ghost coordinates (DG coordinates in external (aka. ghost) cells);


### Property: BoSSS.Foundation.UnsetteledCoordinateMapping.GlobalCount <a id="bosss.foundation.unsetteledcoordinatemapping.globalcount"></a>
**Summary:** total number of coordinates in all processors


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.Local2GlobalIndex(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.local2globalindex(system.int32)"></a>
**Summary:** converts a local unique coordinate index into a global unique coordinate index
**Parameter:** `iLocal` - 
**Returns:**



## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.TransformLocalExternal(System.Int32,System.Int32@,System.Int32@) <a id="bosss.foundation.unsetteledcoordinatemapping.transformlocalexternal(system.int32,system.int32@,system.int32@)"></a>
**Summary:** finds the owning processor ('TargetProc') and the local index on this processor 
('iLocalTargetProc') which corresponds to 
a local index in the external range of this processor.
**Parameter:** `iLocalExt` - a local index on this processor; If this argument is not within the external range (greater or equal to
[BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells) and smaller than [BoSSS.Foundation.Grid.ILogicalCellData.Count](#bosss.foundation.grid.ilogicalcelldata.count)), this method still works
**Parameter:** `TargetProc` - on exit, the process rank of the owner process of local external index 'iLocalExt';
**Parameter:** `iLocalTargetProc` - on exit, the local index on process 'TargetProc' which corresponds to
'iLocalExt'


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.LocalUniqueCoordinateIndex(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.localuniquecoordinateindex(system.int32,system.int32,system.int32)"></a>
**Summary:** computes a local unique coordinate index ("local" means local on this processor);
this index is unique over all fields (in this mapping), over all cells, over all basis functions, 
but it's only locally (on this processor) valid.
A local index in the update range (smaller than [BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells](#bosss.foundation.grid.ilogicalcelldata.nooflocalupdatedcells)) can be converted into 
a global index by adding **ilPSP.Partitioning.i0**.
**Parameter:** `find` - the field or basis index (see [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss));
**Parameter:** `j` - local cell index
**Parameter:** `n` - basis index.
**Returns:**
the local coordinate index for the given parameters.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GlobalUniqueCoordinateIndex(System.Int32,System.Int32,System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.globaluniquecoordinateindex(system.int32,system.int32,system.int32)"></a>
**Summary:** computes a global unique coordinate index ("global" means over all MPI processors)
from a local field coordinate index (i.e. the tuple of field index 
'find', local cell index 'j' and 
DG coordinate index 'n').
**Parameter:** `find` - the field or basis index (see [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss));
**Parameter:** `j` - local cell index
**Parameter:** `n` - basis index.
**Returns:**
the global DG coordinate index for the given parameters.
**Remark:**
The global unique coordinate index is unique over all fields (in this mapping), 
over all cells, over all basis functions, over all MPI processes in the current
communicator.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GlobalUnique1stCoordinate(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.globalunique1stcoordinate(system.int32)"></a>
**Summary:** Globel index for the first degree-of-freedom (DOF) for cell 'j';
Note: in contrast to [BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockI0(System.Int64)](#bosss.foundation.unsetteledcoordinatemapping.getblocki0(system.int64)), this function supports also external/ghost cells (in local coordinates).
**Parameter:** `j` - local cell index, might be an external/ghost cell
**Returns:**
The global coordinate index for the first DOF for cell 'j'


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.LocalUnique1stCoordinate(System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.localunique1stcoordinate(system.int32)"></a>
**Summary:** Globel index for the first degree-of-freedom (DOF) for cell 'j';
Note: in contrast to [BoSSS.Foundation.UnsetteledCoordinateMapping.GetBlockI0(System.Int64)](#bosss.foundation.unsetteledcoordinatemapping.getblocki0(system.int64)), this function supports also external/ghost cells (in local coordinates).
**Parameter:** `j` - local cell index, might be an external/ghost cell
**Returns:**
The global coordinate index for the first DOF for cell 'j'


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.LocalUnique1stCoordinate(System.Int32,System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.localunique1stcoordinate(system.int32,system.int32)"></a>
**Summary:** Globel index for the first degree-of-freedom (DOF) of the 'find'-th variable for cell 'j';
**Parameter:** `j` - local cell index, might be an external/ghost cell
**Parameter:** `find` - field/variable index
**Returns:**
The global coordinate index for the first DOF for cell 'j'


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GlobalUniqueCoordinateIndex_FromGlobal(System.Int32,System.Int64,System.Int32) <a id="bosss.foundation.unsetteledcoordinatemapping.globaluniquecoordinateindex_fromglobal(system.int32,system.int64,system.int32)"></a>
**Summary:** computes a global unique coordinate index ("global" means over all MPI processors)
from a global field coordinate index (i.e. the tuple of field index 
'find', global cell index 'jGlobal' and 
DG coordinate index 'n').
this index is unique over all fields (in this mapping), over all cells, over all basis functions;
**Parameter:** `find` - the field or basis index (see [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss));
**Parameter:** `jGlobal` - global cell index
**Parameter:** `n` - basis index.
**Returns:**
the global DG coordinate index for the given parameters.
**Remark:**
The global unique coordinate index is unique over all fields (in this mapping), 
over all cells, over all basis functions, over all MPI processes in the current
communicator.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.LocalFieldCoordinateIndex(System.Int32,System.Int32@,System.Int32@,System.Int32@) <a id="bosss.foundation.unsetteledcoordinatemapping.localfieldcoordinateindex(system.int32,system.int32@,system.int32@,system.int32@)"></a>
**Summary:** inverse mapping of [BoSSS.Foundation.UnsetteledCoordinateMapping.LocalUniqueCoordinateIndex(System.Int32,System.Int32,System.Int32)](#bosss.foundation.unsetteledcoordinatemapping.localuniquecoordinateindex(system.int32,system.int32,system.int32));
**Parameter:** `Index` - local unique coordinate index
**Parameter:** `ifld` - on exit, the field or basis index (see
[BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)) of the field
to which 'Index' belongs.
**Parameter:** `j` - on exit, the local cell index
**Parameter:** `n` - on exit, the basis function index
**Returns:**



## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.Equals(System.Object) <a id="bosss.foundation.unsetteledcoordinatemapping.equals(system.object)"></a>
**Summary:** two [BoSSS.Foundation.UnsetteledCoordinateMapping](#bosss.foundation.unsetteledcoordinatemapping), if their [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)-properties
are equal (for every entry);


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.EqualsUnsetteled(BoSSS.Foundation.UnsetteledCoordinateMapping) <a id="bosss.foundation.unsetteledcoordinatemapping.equalsunsetteled(bosss.foundation.unsetteledcoordinatemapping)"></a>
**Summary:** two [BoSSS.Foundation.UnsetteledCoordinateMapping](#bosss.foundation.unsetteledcoordinatemapping), if their [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)-properties
are equal (for every entry);
**Remark:**
This is a non-virtual version of [BoSSS.Foundation.UnsetteledCoordinateMapping.Equals(System.Object)](#bosss.foundation.unsetteledcoordinatemapping.equals(system.object));
See [BoSSS.Foundation.CoordinateMapping.Equals(System.Object)](#bosss.foundation.coordinatemapping.equals(system.object)) for explanation.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetHashCode <a id="bosss.foundation.unsetteledcoordinatemapping.gethashcode"></a>
**Summary:** calls base implementation


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetSubvectorIndices(System.Boolean,System.Int32[]) <a id="bosss.foundation.unsetteledcoordinatemapping.getsubvectorindices(system.boolean,system.int32[])"></a>
**Summary:** Returns global unique indices which correlate to a certain sub-set of this mappings's basises ([BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)).
**Parameter:** `Fields` - indices into [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)
**Parameter:** `lo` -
Inclusion of unused indices:
- true: all indices up to [BoSSS.Foundation.Basis.MaximalLength](#bosss.foundation.basis.maximallength);
- false: only occupied entries, up to [BoSSS.Foundation.Basis.GetLength(System.Int32)](#bosss.foundation.basis.getlength(system.int32))
**Returns:**
a list of global (over all MPI processes) unique indices.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetSubvectorIndices(BoSSS.Foundation.Grid.SubGrid,System.Boolean,System.Int32[]) <a id="bosss.foundation.unsetteledcoordinatemapping.getsubvectorindices(bosss.foundation.grid.subgrid,system.boolean,system.int32[])"></a>
**Summary:** returns global unique indices which correlate to a certain sub-set of this mappings's basis ([BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)),
and to cells in a certain sub-grid ('sgrd').
**Parameter:** `sgrd` - 
**Parameter:** `Fields` - indices into [BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS](#bosss.foundation.unsetteledcoordinatemapping.basiss)
**Parameter:** `lo` -
Inclusion of unused indices:
- true: all indices up to [BoSSS.Foundation.Basis.MaximalLength](#bosss.foundation.basis.maximallength)
- false: only occupied entries, up to [BoSSS.Foundation.Basis.GetLength(System.Int32)](#bosss.foundation.basis.getlength(system.int32))
**Returns:**
a list of global (over all MPI processes) unique indices.


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.op_Implicit(BoSSS.Foundation.Basis[])~BoSSS.Foundation.UnsetteledCoordinateMapping <a id="bosss.foundation.unsetteledcoordinatemapping.op_implicit(bosss.foundation.basis[])~bosss.foundation.unsetteledcoordinatemapping"></a>
**Summary:** implicit conversion


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.op_Implicit(BoSSS.Foundation.UnsetteledCoordinateMapping)~BoSSS.Foundation.Basis[] <a id="bosss.foundation.unsetteledcoordinatemapping.op_implicit(bosss.foundation.unsetteledcoordinatemapping)~bosss.foundation.basis[]"></a>
**Summary:** implicit conversion


## Method: BoSSS.Foundation.UnsetteledCoordinateMapping.GetLocalBlockPartitioning <a id="bosss.foundation.unsetteledcoordinatemapping.getlocalblockpartitioning"></a>
**Summary:** Creates a local clone of this object, which lives only on the MPI_SELF communicator.

## Class: BoSSS.Foundation.VectorField`1 <a id="bosss.foundation.vectorfield`1"></a>

**Summary:** A vector field (stage-1 tensor field) as composition
of scalar fields ([BoSSS.Foundation.DGField](#bosss.foundation.dgfield));


## Method: BoSSS.Foundation.VectorField`1.CheckForNanOrInf(System.Boolean,System.Boolean,System.Boolean) <a id="bosss.foundation.vectorfield`1.checkfornanorinf(system.boolean,system.boolean,system.boolean)"></a>
**Summary:** performs [BoSSS.Foundation.DGField.CheckForNanOrInf(System.Boolean,System.Boolean,System.Boolean)](#bosss.foundation.dgfield.checkfornanorinf(system.boolean,system.boolean,system.boolean)) for each component;


## Method: BoSSS.Foundation.VectorField`1.Clear <a id="bosss.foundation.vectorfield`1.clear"></a>
**Summary:** sets all components of the vector field to 0.0


## Method: BoSSS.Foundation.VectorField`1.Clear(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.clear(bosss.foundation.grid.cellmask)"></a>
**Summary:** sets all coordinates of cells in 'cellMask' of this field to 0;


## Method: BoSSS.Foundation.VectorField`1.#ctor(System.Int32,BoSSS.Foundation.Basis,System.String,System.Func{BoSSS.Foundation.Basis,System.String,`0}) <a id="bosss.foundation.vectorfield`1.#ctor(system.int32,bosss.foundation.basis,system.string,system.func{bosss.foundation.basis,system.string,`0})"></a>
**Summary:** ctor
**Parameter:** `D` - number of components, i.d. dimension (see [BoSSS.Foundation.VectorField`1.Dim](#bosss.foundation.vectorfield`1.dim))
**Parameter:** `b` - 
**Parameter:** `id` - identification string ('name') for the vector 
field; the name of the components is constructed from this name
**Parameter:** `fac` - factory for instantiation of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)-objects; By the
factory model, it becomes possible to use this container for
different subclasses of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield).


## Method: BoSSS.Foundation.VectorField`1.#ctor(System.Int32,BoSSS.Foundation.Basis,System.Func{BoSSS.Foundation.Basis,System.String,`0}) <a id="bosss.foundation.vectorfield`1.#ctor(system.int32,bosss.foundation.basis,system.func{bosss.foundation.basis,system.string,`0})"></a>
**Summary:** ctor
**Parameter:** `D` - number of components, i.d. dimension (see [BoSSS.Foundation.VectorField`1.Dim](#bosss.foundation.vectorfield`1.dim))
**Parameter:** `b` - 
**Parameter:** `fac` - factory for the instantiation of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)-objects; By
the factory model, it becomes possible to use this container for
different subclasses of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield).


## Method: BoSSS.Foundation.VectorField`1.#ctor(`0[]) <a id="bosss.foundation.vectorfield`1.#ctor(`0[])"></a>
**Summary:** ctor;
**Parameter:** `components` - components of the vector field


### Property: BoSSS.Foundation.VectorField`1.Dim <a id="bosss.foundation.vectorfield`1.dim"></a>
**Summary:** dimension (number of vector components) of the vector field.


### Property: BoSSS.Foundation.VectorField`1.GridDat <a id="bosss.foundation.vectorfield`1.griddat"></a>
**Summary:** grid data object for this vector field.


### Field: BoSSS.Foundation.VectorField`1.m_Components <a id="bosss.foundation.vectorfield`1.m_components"></a>
**Summary:** Components


## Method: BoSSS.Foundation.VectorField`1.ToArray <a id="bosss.foundation.vectorfield`1.toarray"></a>
**Summary:** returns the components of this vector field as some array of [BoSSS.Foundation.DGField](#bosss.foundation.dgfield)-objects
**Returns:**



### Property: BoSSS.Foundation.VectorField`1.Identifications <a id="bosss.foundation.vectorfield`1.identifications"></a>
**Summary:** identifications of all components ([BoSSS.Foundation.DGField.Identification](#bosss.foundation.dgfield.identification));


### Property: BoSSS.Foundation.VectorField`1.Mapping <a id="bosss.foundation.vectorfield`1.mapping"></a>
**Summary:** returns a [BoSSS.Foundation.CoordinateMapping](#bosss.foundation.coordinatemapping) for all DG fields in this vector


### Property: BoSSS.Foundation.VectorField`1.CoordinateVector <a id="bosss.foundation.vectorfield`1.coordinatevector"></a>
**Summary:** returns a [BoSSS.Foundation.VectorField`1.CoordinateVector](#bosss.foundation.vectorfield`1.coordinatevector) of the DG coordinates of
the fields in this vector field


### Property: BoSSS.Foundation.VectorField`1.Item(System.Int32) <a id="bosss.foundation.vectorfield`1.item(system.int32)"></a>
**Summary:** access the 'd'-th component of this 
vector filed


## Method: BoSSS.Foundation.VectorField`1.Acc(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.acc(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.cellmask)"></a>
**Summary:** adds an other vector field
'a'*'mult' to this field;


## Method: BoSSS.Foundation.VectorField`1.AccLaidBack(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.acclaidback(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.cellmask)"></a>
**Summary:** 'lax' accumulation (see
[BoSSS.Foundation.DGField.AccLaidBack(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.acclaidback(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask))) of an
other vector field
'a'*'mult' to this field;


## Method: BoSSS.Foundation.VectorField`1.Scale(System.Double,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.scale(system.double,bosss.foundation.grid.cellmask)"></a>
**Summary:** multiplies this vector field by the number 'alpha'
**Parameter:** `alpha` - scaling factor
**Parameter:** `m` - optional cell mask


## Method: BoSSS.Foundation.VectorField`1.ScalePointwise(System.Double,BoSSS.Foundation.DGField) <a id="bosss.foundation.vectorfield`1.scalepointwise(system.double,bosss.foundation.dgfield)"></a>
**Summary:** multiplies this object by 'f'*'alpha';
Note that this is a relatively heavy operation.
**Parameter:** `alpha` - 
**Parameter:** `f` - 


## Method: BoSSS.Foundation.VectorField`1.op_Addition(BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.op_addition(bosss.foundation.vectorfield{`0},bosss.foundation.vectorfield{`0})"></a>
**Summary:** adding two vector fields
**Parameter:** `a` - 
**Parameter:** `b` - 
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Subtraction(BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.op_subtraction(bosss.foundation.vectorfield{`0},bosss.foundation.vectorfield{`0})"></a>
**Summary:** subtracting two vector fields
**Parameter:** `a` - 
**Parameter:** `b` - 
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Multiply(BoSSS.Foundation.VectorField{`0},System.Double) <a id="bosss.foundation.vectorfield`1.op_multiply(bosss.foundation.vectorfield{`0},system.double)"></a>
**Summary:** returns 'a'*'alpha'
**Parameter:** `a` - a vector field
**Parameter:** `alpha` - scalar
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Multiply(System.Double,BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.op_multiply(system.double,bosss.foundation.vectorfield{`0})"></a>
**Summary:** returns 'a'*'alpha'
**Parameter:** `a` - a vector field
**Parameter:** `alpha` - scalar
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Multiply(BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.DGField) <a id="bosss.foundation.vectorfield`1.op_multiply(bosss.foundation.vectorfield{`0},bosss.foundation.dgfield)"></a>
**Summary:** returns 'a'*'alpha'
**Parameter:** `a` - a vector field
**Parameter:** `alpha` - a scalar field
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Multiply(BoSSS.Foundation.DGField,BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.op_multiply(bosss.foundation.dgfield,bosss.foundation.vectorfield{`0})"></a>
**Summary:** returns 'a'*'alpha'
**Parameter:** `a` - a vector field
**Parameter:** `alpha` - a scalar field
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.op_Multiply(BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.op_multiply(bosss.foundation.vectorfield{`0},bosss.foundation.vectorfield{`0})"></a>
**Summary:** returns point-wise dot product of two equal dimensional vector fields 'a'*'b'
**Parameter:** `a` - a vector field
**Parameter:** `b` - a vector field
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.Clone <a id="bosss.foundation.vectorfield`1.clone"></a>
**Summary:** non-shallow copy
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.CloneAs <a id="bosss.foundation.vectorfield`1.cloneas"></a>
**Summary:** non-shallow copy
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.CopyFrom(BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.copyfrom(bosss.foundation.vectorfield{`0})"></a>
**Summary:** copies the values of 'other' to this object
(non-shallow) if possible
**Parameter:** `other` - 


## Method: BoSSS.Foundation.VectorField`1.Curl3D(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.curl3d(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.cellmask)"></a>
**Summary:** accumulates the curl of a 3D DG vector field 'vec' 
times 'alpha' to this vector field, i.e. 
this = this + 'alpha'* Curl('vec')
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Parameter:** `em` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain  would be a waste of
computational power. A proper execution mask for this case would be
e.g. [BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain
**Remark:**
This method is based on
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32)), i.e. it
calculates derivatives by analytic cell-by-cell derivation of the
DG polynomials;


## Method: BoSSS.Foundation.VectorField`1.Curl3DByFlux(System.Double,BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.vectorfield`1.curl3dbyflux(system.double,bosss.foundation.vectorfield{`0},bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** accumulates the curl of 3D DG vector field 'vec' 
times 'alpha'
to this vector field, i.e. 
this = this + 'alpha'* Curl('vec')
**Parameter:** `alpha` - 
**Parameter:** `vec` - 
**Parameter:** `optionalSubGrid` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)
if null, the computation is carried out in the whole domain.
**Parameter:** `bndMode` - 
**Remark:**
This method is based on
[BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)),
i.e. it calculates derivatives by central-difference fluxes;


## Method: BoSSS.Foundation.VectorField`1.Gradient(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.gradient(system.double,bosss.foundation.dgfield,bosss.foundation.grid.cellmask)"></a>
**Summary:** this = this + 'alpha'*Gradient of
'f'
**Parameter:** `alpha` - scaling
**Parameter:** `f` - 
**Parameter:** `em` - optional mask, null is the full domain
**Remark:**
this function is based on the
[BoSSS.Foundation.DGField.Derivative(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.CellMask)](#bosss.foundation.dgfield.derivative(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.cellmask))-method


## Method: BoSSS.Foundation.VectorField`1.GradientByFlux(System.Double,BoSSS.Foundation.DGField,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes) <a id="bosss.foundation.vectorfield`1.gradientbyflux(system.double,bosss.foundation.dgfield,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes)"></a>
**Summary:** Accumulates the derivative of 'f' with respect to
x_i to the i-th component of this vector field by making use of
[BoSSS.Foundation.DGField.DerivativeByFlux(System.Double,BoSSS.Foundation.DGField,System.Int32,BoSSS.Foundation.Grid.SubGrid,BoSSS.Foundation.SubGridBoundaryModes)](#bosss.foundation.dgfield.derivativebyflux(system.double,bosss.foundation.dgfield,system.int32,bosss.foundation.grid.subgrid,bosss.foundation.subgridboundarymodes))
**Parameter:** `alpha` - 
**Parameter:** `f` - 
**Parameter:** `optionalSubGrid` - An optional restriction to the domain in which the derivative is
computed (it may, e.g. be only required in boundary cells, so a
computation over the whole domain would be a waste of computational
power. A proper execution mask would be see e.g. 
[BoSSS.Foundation.Grid.Classic.GridData.BoundaryCells](#bosss.foundation.grid.classic.griddata.boundarycells).)

if null, the computation is carried out in the whole domain.
**Parameter:** `bndMode` - 


## Method: BoSSS.Foundation.VectorField`1.GetEnumerator <a id="bosss.foundation.vectorfield`1.getenumerator"></a>
**Summary:** as defined by interface;


## Method: BoSSS.Foundation.VectorField`1.System#Collections#IEnumerable#GetEnumerator <a id="bosss.foundation.vectorfield`1.system#collections#ienumerable#getenumerator"></a>
**Summary:** as defined by interface;


## Method: BoSSS.Foundation.VectorField`1.InnerProduct(BoSSS.Foundation.VectorField{`0},BoSSS.Foundation.VectorField{`0}) <a id="bosss.foundation.vectorfield`1.innerproduct(bosss.foundation.vectorfield{`0},bosss.foundation.vectorfield{`0})"></a>
**Summary:** The inner product of vector fields 'a' and 'b';


## Method: BoSSS.Foundation.VectorField`1.IndexOf(`0) <a id="bosss.foundation.vectorfield`1.indexof(`0)"></a>
**Summary:** index of 'item';


## Method: BoSSS.Foundation.VectorField`1.Insert(System.Int32,`0) <a id="bosss.foundation.vectorfield`1.insert(system.int32,`0)"></a>
**Summary:** not supported (read - only);


## Method: BoSSS.Foundation.VectorField`1.RemoveAt(System.Int32) <a id="bosss.foundation.vectorfield`1.removeat(system.int32)"></a>
**Summary:** not supported (read - only);


## Method: BoSSS.Foundation.VectorField`1.Add(`0) <a id="bosss.foundation.vectorfield`1.add(`0)"></a>
**Summary:** not supported (read - only);


## Method: BoSSS.Foundation.VectorField`1.Contains(`0) <a id="bosss.foundation.vectorfield`1.contains(`0)"></a>
**Summary:** %


## Method: BoSSS.Foundation.VectorField`1.CopyTo(`0[],System.Int32) <a id="bosss.foundation.vectorfield`1.copyto(`0[],system.int32)"></a>
**Summary:** %


### Property: BoSSS.Foundation.VectorField`1.Count <a id="bosss.foundation.vectorfield`1.count"></a>
**Summary:** alias for [BoSSS.Foundation.VectorField`1.Dim](#bosss.foundation.vectorfield`1.dim);


### Property: BoSSS.Foundation.VectorField`1.IsReadOnly <a id="bosss.foundation.vectorfield`1.isreadonly"></a>
**Summary:** always true


## Method: BoSSS.Foundation.VectorField`1.Remove(`0) <a id="bosss.foundation.vectorfield`1.remove(`0)"></a>
**Summary:** not supported (read - only);


## Method: BoSSS.Foundation.VectorField`1.L2Norm(BoSSS.Foundation.Grid.CellMask) <a id="bosss.foundation.vectorfield`1.l2norm(bosss.foundation.grid.cellmask)"></a>
**Summary:** 2-Norm of the vector field.
**Parameter:** `CM` - optional restriction of the computational domain
**Returns:**



## Method: BoSSS.Foundation.VectorField`1.ProjectField(System.Double,BoSSS.Foundation.VectorFunction,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.vectorfield`1.projectfield(system.double,bosss.foundation.vectorfunction,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.Basis](#bosss.foundation.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `scheme` - 


## Method: BoSSS.Foundation.VectorField`1.ProjectField(System.Double,BoSSS.Foundation.VectorFunction,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.vectorfield`1.projectfield(system.double,bosss.foundation.vectorfunction,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.Basis](#bosss.foundation.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `rule` - quadrature rule


## Method: BoSSS.Foundation.VectorField`1.ProjectField(System.Double,BoSSS.Foundation.VectorFunctionEx,BoSSS.Foundation.Quadrature.ICompositeQuadRule{BoSSS.Foundation.Quadrature.QuadRule}) <a id="bosss.foundation.vectorfield`1.projectfield(system.double,bosss.foundation.vectorfunctionex,bosss.foundation.quadrature.icompositequadrule{bosss.foundation.quadrature.quadrule})"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.Basis](#bosss.foundation.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `rule` - quadrature rule


## Method: BoSSS.Foundation.VectorField`1.ProjectField(System.Double,BoSSS.Foundation.VectorFunctionEx,BoSSS.Foundation.Quadrature.CellQuadratureScheme) <a id="bosss.foundation.vectorfield`1.projectfield(system.double,bosss.foundation.vectorfunctionex,bosss.foundation.quadrature.cellquadraturescheme)"></a>
**Summary:** Accumulates the DG projection (with respect to [BoSSS.Foundation.Basis](#bosss.foundation.basis))
times 'alpha' to this field, i.e. 
this = this + 'alpha'*'func';
**Parameter:** `func` - 
**Parameter:** `alpha` - scaling of 'func'
**Parameter:** `scheme` - 

## Class: BoSSS.Foundation.VectorField`1.ProjectionQuadrature <a id="bosss.foundation.vectorfield`1.projectionquadrature"></a>

**Summary:** projects a vector function onto the DG-space;


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_Owner <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_owner"></a>


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_func <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_func"></a>
**Summary:** the function to project onto [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_Owner](#bosss.foundation.vectorfield`1.projectionquadrature.m_owner)


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_func2 <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_func2"></a>
**Summary:** the function to project onto [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_Owner](#bosss.foundation.vectorfield`1.projectionquadrature.m_owner)


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_alpha <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_alpha"></a>
**Summary:** a constant to multiply [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_func](#bosss.foundation.vectorfield`1.projectionquadrature.m_func) or [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_func2](#bosss.foundation.vectorfield`1.projectionquadrature.m_func2) with;


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_NodesTransformed <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_nodestransformed"></a>
**Summary:** Nodes in global coordinates
- 1st index: cell index (minus some offset);
- 2nd index: node index;
- 3rd index; spatial coordinate;


### Field: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_FunctionValues <a id="bosss.foundation.vectorfield`1.projectionquadrature.m_functionvalues"></a>
**Summary:** results of function evaluation
- 1st index: cell index (minus some offset);
- 2nd index: node index;


## Method: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.AllocateBuffers(System.Int32,BoSSS.Foundation.NodeSet) <a id="bosss.foundation.vectorfield`1.projectionquadrature.allocatebuffers(system.int32,bosss.foundation.nodeset)"></a>
**Summary:** Allocates memory for the global coordinates and the function values


## Method: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.Evaluate(System.Int32,System.Int32,BoSSS.Foundation.Quadrature.QuadRule,ilPSP.MultidimensionalArray) <a id="bosss.foundation.vectorfield`1.projectionquadrature.evaluate(system.int32,system.int32,bosss.foundation.quadrature.quadrule,ilpsp.multidimensionalarray)"></a>
**Summary:** Integrand evaluation.


## Method: BoSSS.Foundation.VectorField`1.ProjectionQuadrature.SaveIntegrationResults(System.Int32,System.Int32,ilPSP.MultidimensionalArray) <a id="bosss.foundation.vectorfield`1.projectionquadrature.saveintegrationresults(system.int32,system.int32,ilpsp.multidimensionalarray)"></a>
**Summary:** performs the accumulation (multiplication of
integration result by [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_alpha](#bosss.foundation.vectorfield`1.projectionquadrature.m_alpha) and addition to)
the DG coordinates of [BoSSS.Foundation.VectorField`1.ProjectionQuadrature.m_Owner](#bosss.foundation.vectorfield`1.projectionquadrature.m_owner);
**Parameter:** `i0` - 
**Parameter:** `Length` - 
**Parameter:** `ResultsOfIntegration` - 

## Class: BoSSS.Foundation.VectorFunction <a id="bosss.foundation.vectorfunction"></a>

**Summary:** delegate for steady-state vector functions in D-dimensional space,
vectorized definition.

## Class: BoSSS.Foundation.VectorFunctionTimeDep <a id="bosss.foundation.vectorfunctiontimedep"></a>

**Summary:** delegate for time-dependent vector functions in D-dimensional space,
vectorized definition.

## Class: BoSSS.Foundation.VectorFunctionExt <a id="bosss.foundation.vectorfunctionext"></a>

**Summary:** Extensions functions for [BoSSS.Foundation.ScalarFunction](#bosss.foundation.scalarfunction)


## Method: BoSSS.Foundation.VectorFunctionExt.SetTime(BoSSS.Foundation.VectorFunctionTimeDep,System.Double) <a id="bosss.foundation.vectorfunctionext.settime(bosss.foundation.vectorfunctiontimedep,system.double)"></a>
**Summary:** fixing the time for some time-depended function 'f'.

## Class: BoSSS.Foundation.VectorFunctionEx <a id="bosss.foundation.vectorfunctionex"></a>

**Summary:** Evaluates the scalar function
at points specified in node set 'nodes'
in all cells from 'j0' to
'j0'+'Len'-1 and writes them
to 'result'.

**Remark:**
This method is vectorized: Here, it means that the Points at which the DG field should be evaluated,
are given for one cell in reference coordinates, but
the evaluation is performed for 'Len' cells at once.



